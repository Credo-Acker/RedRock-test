/*! 版权所有，翻版必究 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

eval("const less = __webpack_require__(1);\nconst web = __webpack_require__(3);\n\nwindow.onload = function () {\n\tlet weather = document.querySelector('#weather'),\n\t    monthDay = document.querySelector('.month-day'),\n\t    weekday = document.querySelector('.weekday'),\n\t    nongli = document.querySelector('.nongli'),\n\t    dayCondition1 = document.querySelector('.day-condition1'),\n\t    dayCondition2 = document.querySelector('.day-condition2'),\n\t    boss = document.querySelector('.boss');\n\n\tboss.addEventListener('click', function () {\n\t\tlet boss1 = document.querySelector('.boss-left'),\n\t\t    boss2 = document.querySelector('.boss-right');\n\n\t\tlet boss1N = boss1.className,\n\t\t    boss2N = boss2.className;\n\t\tboss1.className = boss1N + ' ' + 'boss1';\n\t\tboss2.className = boss2N + ' ' + 'boss2';\n\n\t\tsetTimeout(function () {\n\t\t\tlet bossN = boss.className;\n\t\t\tboss.className = bossN + ' ' + 'boss-click';\n\t\t}, 1000);\n\t});\n\n\tdate();\n\tinitCanvas();\n\n\t//ajax获取数据库天气\n\tajax({\n\t\tmethor: \"get\",\n\t\turl: \"/forecast\",\n\t\tasyn: true,\n\t\tsuccess: function (data) {\n\t\t\tlet Data = JSON.parse(data);\n\t\t\tlet lis = dayCondition2.querySelectorAll('li');\n\t\t\tfor (var i = 0; i < lis.length; i++) {\n\t\t\t\tlis[i].innerHTML = Data[i].weather;\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction date() {\n\t\tlet myDate = new Date();\n\t\tlet lis = dayCondition1.querySelectorAll('li');\n\t\tlet month = myDate.getMonth() + 1 > 10 ? myDate.getMonth() + 1 : \"0\" + (myDate.getMonth() + 1),\n\t\t    day = myDate.getDay();\n\t\tswitch (day) {\n\t\t\tcase 0:\n\t\t\t\tday = \"星期日\";\n\t\t\t\tlis[1].querySelector('span').innerHTML = \"星期日\";\n\t\t\t\tlis[2].querySelector('span').innerHTML = \"星期一\";\n\t\t\t\tlis[3].querySelector('span').innerHTML = \"星期二\";\n\t\t\t\tlis[4].querySelector('span').innerHTML = \"星期三\";\n\t\t\t\tlis[5].querySelector('span').innerHTML = \"星期四\";\n\t\t\t\tlis[6].querySelector('span').innerHTML = \"星期五\";\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tday = \"星期一\";\n\t\t\t\tlis[1].querySelector('span').innerHTML = \"星期一\";\n\t\t\t\tlis[2].querySelector('span').innerHTML = \"星期二\";\n\t\t\t\tlis[3].querySelector('span').innerHTML = \"星期三\";\n\t\t\t\tlis[4].querySelector('span').innerHTML = \"星期四\";\n\t\t\t\tlis[5].querySelector('span').innerHTML = \"星期五\";\n\t\t\t\tlis[6].querySelector('span').innerHTML = \"星期六\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tday = \"星期二\";\n\t\t\t\tlis[1].querySelector('span').innerHTML = \"星期二\";\n\t\t\t\tlis[2].querySelector('span').innerHTML = \"星期三\";\n\t\t\t\tlis[3].querySelector('span').innerHTML = \"星期四\";\n\t\t\t\tlis[4].querySelector('span').innerHTML = \"星期五\";\n\t\t\t\tlis[5].querySelector('span').innerHTML = \"星期六\";\n\t\t\t\tlis[6].querySelector('span').innerHTML = \"星期六日\";\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tday = \"星期三\";\n\t\t\t\tlis[1].querySelector('span').innerHTML = \"星期三\";\n\t\t\t\tlis[2].querySelector('span').innerHTML = \"星期四\";\n\t\t\t\tlis[3].querySelector('span').innerHTML = \"星期五\";\n\t\t\t\tlis[4].querySelector('span').innerHTML = \"星期六\";\n\t\t\t\tlis[5].querySelector('span').innerHTML = \"星期日\";\n\t\t\t\tlis[6].querySelector('span').innerHTML = \"星期一\";\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tday = \"星期四\";\n\t\t\t\tlis[1].querySelector('span').innerHTML = \"星期四\";\n\t\t\t\tlis[2].querySelector('span').innerHTML = \"星期五\";\n\t\t\t\tlis[3].querySelector('span').innerHTML = \"星期六\";\n\t\t\t\tlis[4].querySelector('span').innerHTML = \"星期日\";\n\t\t\t\tlis[5].querySelector('span').innerHTML = \"星期一\";\n\t\t\t\tlis[6].querySelector('span').innerHTML = \"星期二\";\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tday = \"星期五\";\n\t\t\t\tlis[1].querySelector('span').innerHTML = \"星期五\";\n\t\t\t\tlis[2].querySelector('span').innerHTML = \"星期六\";\n\t\t\t\tlis[3].querySelector('span').innerHTML = \"星期日\";\n\t\t\t\tlis[4].querySelector('span').innerHTML = \"星期一\";\n\t\t\t\tlis[5].querySelector('span').innerHTML = \"星期二\";\n\t\t\t\tlis[6].querySelector('span').innerHTML = \"星期三\";\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tday = \"星期六\";\n\t\t\t\tlis[1].querySelector('span').innerHTML = \"星期六\";\n\t\t\t\tlis[2].querySelector('span').innerHTML = \"星期日\";\n\t\t\t\tlis[3].querySelector('span').innerHTML = \"星期一\";\n\t\t\t\tlis[4].querySelector('span').innerHTML = \"星期二\";\n\t\t\t\tlis[5].querySelector('span').innerHTML = \"星期三\";\n\t\t\t\tlis[6].querySelector('span').innerHTML = \"星期四\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tmonthDay.innerHTML = month + \"月\" + myDate.getDate() + \"日\";\n\t\tweekday.innerHTML = day;\n\t}\n\n\tfunction initCanvas() {\n\t\tlet winwidth = window.document.documentElement.getBoundingClientRect().width;\n\t\tlet canvas = document.querySelector('#canvas');\n\t\tif (winwidth > 640) {\n\t\t\twinwidth = 640;\n\t\t}\n\t\tcanvas.width = winwidth;\n\t\tcanvas.height = winwidth / 2;\n\t\tlet cxt = canvas.getContext('2d');\n\n\t\tcxt.beginPath();\n\t\tcxt.moveTo(canvas.width / 21, canvas.height / 21);\n\t\tcxt.lineTo(canvas.width / 21, canvas.height / 21 * 20);\n\t\tcxt.lineTo(canvas.width / 21 * 20, canvas.height / 21 * 20);\n\t\tcxt.stroke();\n\t\tcxt.closePath();\n\n\t\tcxt.beginPath(); //画箭头1\n\t\tcxt.moveTo(canvas.width / 21, canvas.height / 21);\n\t\tcxt.lineTo(canvas.width / 21 - 10, canvas.height / 21 + 15);\n\t\tcxt.stroke();\n\t\tcxt.closePath();\n\n\t\tcxt.beginPath(); //画箭头2\n\t\tcxt.moveTo(canvas.width / 21, canvas.height / 21);\n\t\tcxt.lineTo(canvas.width / 21 + 10, canvas.height / 21 + 15);\n\t\tcxt.stroke();\n\t\tcxt.closePath();\n\n\t\tcxt.beginPath(); //画箭头3\n\t\tcxt.lineTo(canvas.width / 21 * 20, canvas.height / 21 * 20);\n\t\tcxt.lineTo(canvas.width / 21 * 20 - 15, canvas.height / 21 * 20 + 10);\n\t\tcxt.stroke();\n\t\tcxt.closePath();\n\n\t\tcxt.beginPath(); //画箭头4\n\t\tcxt.lineTo(canvas.width / 21 * 20, canvas.height / 21 * 20);\n\t\tcxt.lineTo(canvas.width / 21 * 20 - 15, canvas.height / 21 * 20 - 10);\n\t\tcxt.stroke();\n\t\tcxt.closePath();\n\n\t\tajax({\n\t\t\tmethor: \"get\",\n\t\t\turl: \"/forecast\",\n\t\t\tasyn: true,\n\t\t\tsuccess: function (data) {\n\t\t\t\tlet Data = JSON.parse(data);\n\t\t\t\th1 = Math.ceil((Data[0].max_temp + Data[0].min_temp) / 2);\n\t\t\t\th2 = Math.ceil((Data[1].max_temp + Data[1].min_temp) / 2);\n\t\t\t\th3 = Math.ceil((Data[2].max_temp + Data[2].min_temp) / 2);\n\t\t\t\th4 = Math.ceil((Data[3].max_temp + Data[3].min_temp) / 2);\n\t\t\t\th5 = Math.ceil((Data[4].max_temp + Data[4].min_temp) / 2);\n\t\t\t\th6 = Math.ceil((Data[5].max_temp + Data[5].min_temp) / 2);\n\t\t\t\th7 = Math.ceil((Data[6].max_temp + Data[6].min_temp) / 2);\n\n\t\t\t\tzhexian();\n\t\t\t\tdian();\n\t\t\t\twendu();\n\t\t\t\t//画温度折线\n\t\t\t\tfunction zhexian() {\n\t\t\t\t\tcxt.strokeStyle = \"#999\";\n\t\t\t\t\tcxt.beginPath();\n\t\t\t\t\tcxt.moveTo(Math.floor(canvas.width / 14), Math.floor(canvas.height - canvas.height * h1 / 55));\n\t\t\t\t\tcxt.lineTo(Math.floor(canvas.width / 14 * 3), Math.floor(canvas.height - canvas.height * h2 / 55));\n\t\t\t\t\tcxt.lineTo(Math.floor(canvas.width / 14 * 5), Math.floor(canvas.height - canvas.height * h3 / 55));\n\t\t\t\t\tcxt.lineTo(Math.floor(canvas.width / 14 * 7), Math.floor(canvas.height - canvas.height * h4 / 55));\n\t\t\t\t\tcxt.lineTo(Math.floor(canvas.width / 14 * 9), Math.floor(canvas.height - canvas.height * h5 / 55));\n\t\t\t\t\tcxt.lineTo(Math.floor(canvas.width / 14 * 11), Math.floor(canvas.height - canvas.height * h6 / 55));\n\t\t\t\t\tcxt.lineTo(Math.floor(canvas.width / 14 * 13), Math.floor(canvas.height - canvas.height * h7 / 55));\n\t\t\t\t\tcxt.stroke();\n\t\t\t\t\tcxt.closePath();\n\t\t\t\t}\n\n\t\t\t\t//画温度的点\n\t\t\t\tfunction dian() {\n\t\t\t\t\tcxt.strokeStyle = \"#666\";\n\t\t\t\t\tcxt.beginPath();\n\t\t\t\t\tcxt.arc(Math.floor(canvas.width / 14), Math.floor(canvas.height - canvas.height * h1 / 55), 2, 0, 2 * Math.PI);\n\t\t\t\t\tcxt.arc(Math.floor(canvas.width / 14 * 3), Math.floor(canvas.height - canvas.height * h2 / 55), 2, 0, 2 * Math.PI);\n\t\t\t\t\tcxt.arc(Math.floor(canvas.width / 14 * 5), Math.floor(canvas.height - canvas.height * h3 / 55), 2, 0, 2 * Math.PI);\n\t\t\t\t\tcxt.arc(Math.floor(canvas.width / 14 * 7), Math.floor(canvas.height - canvas.height * h4 / 55), 2, 0, 2 * Math.PI);\n\t\t\t\t\tcxt.arc(Math.floor(canvas.width / 14 * 9), Math.floor(canvas.height - canvas.height * h5 / 55), 2, 0, 2 * Math.PI);\n\t\t\t\t\tcxt.arc(Math.floor(canvas.width / 14 * 11), Math.floor(canvas.height - canvas.height * h6 / 55), 2, 0, 2 * Math.PI);\n\t\t\t\t\tcxt.arc(Math.floor(canvas.width / 14 * 13), Math.floor(canvas.height - canvas.height * h7 / 55), 2, 0, 2 * Math.PI);\n\t\t\t\t\tcxt.stroke();\n\t\t\t\t\tcxt.closePath();\n\t\t\t\t}\n\n\t\t\t\t//写温度\n\t\t\t\tfunction wendu() {\n\t\t\t\t\tcxt.font = \"15px\";\n\t\t\t\t\tcxt.strokeStyle = \"black\";\n\t\t\t\t\tcxt.beginPath();\n\t\t\t\t\t//第一个\n\t\t\t\t\tcxt.strokeText(Data[0].max_temp + \"°\", Math.floor(canvas.width / 14 - 15), Math.floor(canvas.height - canvas.height * h1 / 55 - 15));\n\t\t\t\t\tcxt.strokeText(Data[0].min_temp + \"°\", Math.floor(canvas.width / 14 - 15), Math.floor(canvas.height - canvas.height * h1 / 55 + 20));\n\t\t\t\t\t//第二个\n\t\t\t\t\tcxt.strokeText(Data[1].max_temp + \"°\", Math.floor(canvas.width / 14 * 3 - 15), Math.floor(canvas.height - canvas.height * h2 / 55 - 15));\n\t\t\t\t\tcxt.strokeText(Data[1].min_temp + \"°\", Math.floor(canvas.width / 14 * 3 - 15), Math.floor(canvas.height - canvas.height * h2 / 55 + 15));\n\t\t\t\t\t//第三个\n\t\t\t\t\tcxt.strokeText(Data[2].max_temp + \"°\", Math.floor(canvas.width / 14 * 5 - 15), Math.floor(canvas.height - canvas.height * h3 / 55 - 15));\n\t\t\t\t\tcxt.strokeText(Data[2].min_temp + \"°\", Math.floor(canvas.width / 14 * 5 - 15), Math.floor(canvas.height - canvas.height * h3 / 55 + 20));\n\t\t\t\t\t//第四个\n\t\t\t\t\tcxt.strokeText(Data[3].max_temp + \"°\", Math.floor(canvas.width / 14 * 7 - 15), Math.floor(canvas.height - canvas.height * h4 / 55 - 15));\n\t\t\t\t\tcxt.strokeText(Data[3].min_temp + \"°\", Math.floor(canvas.width / 14 * 7 - 15), Math.floor(canvas.height - canvas.height * h4 / 55 + 20));\n\t\t\t\t\t//第五个\n\t\t\t\t\tcxt.strokeText(Data[4].max_temp + \"°\", Math.floor(canvas.width / 14 * 9 - 15), Math.floor(canvas.height - canvas.height * h5 / 55 - 15));\n\t\t\t\t\tcxt.strokeText(Data[4].min_temp + \"°\", Math.floor(canvas.width / 14 * 9 - 15), Math.floor(canvas.height - canvas.height * h5 / 55 + 20));\n\t\t\t\t\t//第六个\n\t\t\t\t\tcxt.strokeText(Data[5].max_temp + \"°\", Math.floor(canvas.width / 14 * 11 - 15), Math.floor(canvas.height - canvas.height * h6 / 55 - 15));\n\t\t\t\t\tcxt.strokeText(Data[5].min_temp + \"°\", Math.floor(canvas.width / 14 * 11 - 15), Math.floor(canvas.height - canvas.height * h6 / 55 + 20));\n\t\t\t\t\t//第七个\n\t\t\t\t\tcxt.strokeText(Data[6].max_temp + \"°\", Math.floor(canvas.width / 14 * 13 - 15), Math.floor(canvas.height - canvas.height * h7 / 55 - 15));\n\t\t\t\t\tcxt.strokeText(Data[6].min_temp + \"°\", Math.floor(canvas.width / 14 * 13 - 15), Math.floor(canvas.height - canvas.height * h7 / 55 + 20));\n\t\t\t\t\tcxt.closePath();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction ajax(json) {\n\t\t// 创建ajax对象\n\t\tlet xhr = null;\n\t\tlet methor = json.methor || 'get';\n\t\tlet url = json.url;\n\t\tlet asyn = json.asyn ? true : json.asyn == false ? false : true;\n\t\tlet data = json.data || '';\n\t\tlet success = json.success;\n\t\tlet error = json.error;\n\n\t\tif (window.XMLHttpRequest) {\n\t\t\txhr = new XMLHttpRequest();\n\t\t} else {\n\t\t\txhr = new ActiveXObject('Microsoft.XMLHTTP');\n\t\t}\n\t\tif (methor.toLowerCase() === 'get') {\n\t\t\txhr.open(methor, url, asyn);\n\t\t\turl += '?' + data + '&' + new Date().getTime();\n\t\t}\n\t\tif (methor.toLowerCase() === 'post') {\n\t\t\txhr.open(methor, url, asyn);\n\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/json\");\n\t\t}\n\n\t\t// 处理返回数据\n\t\txhr.onreadystatechange = function () {\n\t\t\tif (xhr.readyState == 4) {\n\t\t\t\tif (xhr.status == 200) {\n\t\t\t\t\tsuccess && success(xhr.responseText);\n\t\t\t\t} else {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\terror && error();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\txhr.send(data);\n\t};\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbWFpbi5qcz82YTRiIl0sIm5hbWVzIjpbImxlc3MiLCJyZXF1aXJlIiwid2ViIiwid2luZG93Iiwib25sb2FkIiwid2VhdGhlciIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsIm1vbnRoRGF5Iiwid2Vla2RheSIsIm5vbmdsaSIsImRheUNvbmRpdGlvbjEiLCJkYXlDb25kaXRpb24yIiwiYm9zcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJib3NzMSIsImJvc3MyIiwiYm9zczFOIiwiY2xhc3NOYW1lIiwiYm9zczJOIiwic2V0VGltZW91dCIsImJvc3NOIiwiZGF0ZSIsImluaXRDYW52YXMiLCJhamF4IiwibWV0aG9yIiwidXJsIiwiYXN5biIsInN1Y2Nlc3MiLCJkYXRhIiwiRGF0YSIsIkpTT04iLCJwYXJzZSIsImxpcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpIiwibGVuZ3RoIiwiaW5uZXJIVE1MIiwibXlEYXRlIiwiRGF0ZSIsIm1vbnRoIiwiZ2V0TW9udGgiLCJkYXkiLCJnZXREYXkiLCJnZXREYXRlIiwid2lud2lkdGgiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsImNhbnZhcyIsImhlaWdodCIsImN4dCIsImdldENvbnRleHQiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJzdHJva2UiLCJjbG9zZVBhdGgiLCJoMSIsIk1hdGgiLCJjZWlsIiwibWF4X3RlbXAiLCJtaW5fdGVtcCIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiLCJoNyIsInpoZXhpYW4iLCJkaWFuIiwid2VuZHUiLCJzdHJva2VTdHlsZSIsImZsb29yIiwiYXJjIiwiUEkiLCJmb250Iiwic3Ryb2tlVGV4dCIsImpzb24iLCJ4aHIiLCJlcnJvciIsIlhNTEh0dHBSZXF1ZXN0IiwiQWN0aXZlWE9iamVjdCIsInRvTG93ZXJDYXNlIiwib3BlbiIsImdldFRpbWUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsInN0YXR1cyIsInJlc3BvbnNlVGV4dCIsInNlbmQiXSwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLE9BQU8sbUJBQUFDLENBQVEsQ0FBUixDQUFiO0FBQ0EsTUFBTUMsTUFBTSxtQkFBQUQsQ0FBUSxDQUFSLENBQVo7O0FBRUFFLE9BQU9DLE1BQVAsR0FBZ0IsWUFBWTtBQUMzQixLQUFJQyxVQUFVQyxTQUFTQyxhQUFULENBQXVCLFVBQXZCLENBQWQ7QUFBQSxLQUNDQyxXQUFXRixTQUFTQyxhQUFULENBQXVCLFlBQXZCLENBRFo7QUFBQSxLQUVDRSxVQUFVSCxTQUFTQyxhQUFULENBQXVCLFVBQXZCLENBRlg7QUFBQSxLQUdDRyxTQUFTSixTQUFTQyxhQUFULENBQXVCLFNBQXZCLENBSFY7QUFBQSxLQUlDSSxnQkFBZ0JMLFNBQVNDLGFBQVQsQ0FBdUIsaUJBQXZCLENBSmpCO0FBQUEsS0FLQ0ssZ0JBQWdCTixTQUFTQyxhQUFULENBQXVCLGlCQUF2QixDQUxqQjtBQUFBLEtBTUNNLE9BQU9QLFNBQVNDLGFBQVQsQ0FBdUIsT0FBdkIsQ0FOUjs7QUFRQU0sTUFBS0MsZ0JBQUwsQ0FBc0IsT0FBdEIsRUFBK0IsWUFBWTtBQUMxQyxNQUFJQyxRQUFRVCxTQUFTQyxhQUFULENBQXVCLFlBQXZCLENBQVo7QUFBQSxNQUNDUyxRQUFRVixTQUFTQyxhQUFULENBQXVCLGFBQXZCLENBRFQ7O0FBR0EsTUFBSVUsU0FBU0YsTUFBTUcsU0FBbkI7QUFBQSxNQUNDQyxTQUFTSCxNQUFNRSxTQURoQjtBQUVBSCxRQUFNRyxTQUFOLEdBQWtCRCxTQUFTLEdBQVQsR0FBZSxPQUFqQztBQUNBRCxRQUFNRSxTQUFOLEdBQWtCQyxTQUFTLEdBQVQsR0FBZSxPQUFqQzs7QUFFQUMsYUFBVyxZQUFZO0FBQ3RCLE9BQUlDLFFBQVFSLEtBQUtLLFNBQWpCO0FBQ0FMLFFBQUtLLFNBQUwsR0FBa0JHLFFBQVEsR0FBUixHQUFjLFlBQWhDO0FBQ0EsR0FIRCxFQUdHLElBSEg7QUFJQSxFQWJEOztBQWVBQztBQUNBQzs7QUFFQTtBQUNBQyxNQUFLO0FBQ0pDLFVBQVEsS0FESjtBQUVKQyxPQUFLLFdBRkQ7QUFHSkMsUUFBTSxJQUhGO0FBSUpDLFdBQVMsVUFBVUMsSUFBVixFQUFnQjtBQUN4QixPQUFJQyxPQUFPQyxLQUFLQyxLQUFMLENBQVdILElBQVgsQ0FBWDtBQUNBLE9BQUlJLE1BQU1yQixjQUFjc0IsZ0JBQWQsQ0FBK0IsSUFBL0IsQ0FBVjtBQUNBLFFBQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRixJQUFJRyxNQUF4QixFQUFnQ0QsR0FBaEMsRUFBcUM7QUFDcENGLFFBQUlFLENBQUosRUFBT0UsU0FBUCxHQUFtQlAsS0FBS0ssQ0FBTCxFQUFROUIsT0FBM0I7QUFDQTtBQUNEO0FBVkcsRUFBTDs7QUFhQSxVQUFTaUIsSUFBVCxHQUFnQjtBQUNmLE1BQUlnQixTQUFTLElBQUlDLElBQUosRUFBYjtBQUNBLE1BQUlOLE1BQU10QixjQUFjdUIsZ0JBQWQsQ0FBK0IsSUFBL0IsQ0FBVjtBQUNBLE1BQUlNLFFBQVNGLE9BQU9HLFFBQVAsS0FBb0IsQ0FBckIsR0FBMEIsRUFBMUIsR0FBZ0NILE9BQU9HLFFBQVAsS0FBb0IsQ0FBcEQsR0FBMEQsT0FBT0gsT0FBT0csUUFBUCxLQUFvQixDQUEzQixDQUF0RTtBQUFBLE1BQ0lDLE1BQU1KLE9BQU9LLE1BQVAsRUFEVjtBQUVBLFVBQVFELEdBQVI7QUFDQyxRQUFLLENBQUw7QUFDQ0EsVUFBTSxLQUFOO0FBQ0FULFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0E7QUFDRCxRQUFLLENBQUw7QUFDQ0ssVUFBTSxLQUFOO0FBQ0FULFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0E7QUFDRCxRQUFLLENBQUw7QUFDQ0ssVUFBTSxLQUFOO0FBQ0FULFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLE1BQXpDO0FBQ0E7QUFDRCxRQUFLLENBQUw7QUFDQ0ssVUFBTSxLQUFOO0FBQ0FULFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0E7QUFDRCxRQUFLLENBQUw7QUFDQ0ssVUFBTSxLQUFOO0FBQ0FULFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0E7QUFDRCxRQUFLLENBQUw7QUFDQ0ssVUFBTSxLQUFOO0FBQ0FULFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0E7QUFDRCxRQUFLLENBQUw7QUFDQ0ssVUFBTSxLQUFOO0FBQ0FULFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUksQ0FBSixFQUFPMUIsYUFBUCxDQUFxQixNQUFyQixFQUE2QjhCLFNBQTdCLEdBQXlDLEtBQXpDO0FBQ0FKLFFBQUks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akIsRUFBcUI7QUFDakI3RCxnQkFBV0EsUUFBUW1ELElBQUlXLFlBQVosQ0FBWDtBQUNILEtBRkQsTUFFTztBQUNILFNBQUdWLEtBQUgsRUFBUztBQUNMQSxlQUFTQSxPQUFUO0FBQ0g7QUFDSjtBQUNKO0FBQ0osR0FWRDtBQVdBRCxNQUFJWSxJQUFKLENBQVM5RCxJQUFUO0FBQ0g7QUFFRCxDQXBSRCIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbGVzcyA9IHJlcXVpcmUoJ2xlc3MnKTtcclxuY29uc3Qgd2ViID0gcmVxdWlyZSgnLi9zdHlsZXMvd2ViLmxlc3MnKTtcclxuXHJcbndpbmRvdy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcblx0bGV0IHdlYXRoZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjd2VhdGhlcicpLFxyXG5cdFx0bW9udGhEYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubW9udGgtZGF5JyksXHJcblx0XHR3ZWVrZGF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLndlZWtkYXknKSxcclxuXHRcdG5vbmdsaSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ub25nbGknKSxcclxuXHRcdGRheUNvbmRpdGlvbjEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZGF5LWNvbmRpdGlvbjEnKSxcclxuXHRcdGRheUNvbmRpdGlvbjIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZGF5LWNvbmRpdGlvbjInKSxcclxuXHRcdGJvc3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYm9zcycpO1xyXG5cclxuXHRib3NzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0bGV0IGJvc3MxID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmJvc3MtbGVmdCcpLFxyXG5cdFx0XHRib3NzMiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ib3NzLXJpZ2h0Jyk7XHJcblxyXG5cdFx0bGV0IGJvc3MxTiA9IGJvc3MxLmNsYXNzTmFtZSxcclxuXHRcdFx0Ym9zczJOID0gYm9zczIuY2xhc3NOYW1lO1xyXG5cdFx0Ym9zczEuY2xhc3NOYW1lID0gYm9zczFOICsgJyAnICsgJ2Jvc3MxJztcclxuXHRcdGJvc3MyLmNsYXNzTmFtZSA9IGJvc3MyTiArICcgJyArICdib3NzMic7XHJcblxyXG5cdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGxldCBib3NzTiA9IGJvc3MuY2xhc3NOYW1lO1xyXG5cdFx0XHRib3NzLmNsYXNzTmFtZSA9ICBib3NzTiArICcgJyArICdib3NzLWNsaWNrJztcclxuXHRcdH0sIDEwMDApO1xyXG5cdH0pO1xyXG5cclxuXHRkYXRlKCk7XHJcblx0aW5pdENhbnZhcygpO1xyXG5cclxuXHQvL2FqYXjojrflj5bmlbDmja7lupPlpKnmsJRcclxuXHRhamF4KHtcclxuXHRcdG1ldGhvcjogXCJnZXRcIixcclxuXHRcdHVybDogXCIvZm9yZWNhc3RcIixcclxuXHRcdGFzeW46IHRydWUsXHJcblx0XHRzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xyXG5cdFx0XHRsZXQgRGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XHJcblx0XHRcdGxldCBsaXMgPSBkYXlDb25kaXRpb24yLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpJyk7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0bGlzW2ldLmlubmVySFRNTCA9IERhdGFbaV0ud2VhdGhlcjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRmdW5jdGlvbiBkYXRlKCkge1xyXG5cdFx0bGV0IG15RGF0ZSA9IG5ldyBEYXRlKCk7XHJcblx0XHRsZXQgbGlzID0gZGF5Q29uZGl0aW9uMS5xdWVyeVNlbGVjdG9yQWxsKCdsaScpO1xyXG5cdFx0bGV0IG1vbnRoID0gKG15RGF0ZS5nZXRNb250aCgpICsgMSkgPiAxMCA/IChteURhdGUuZ2V0TW9udGgoKSArIDEpIDogKFwiMFwiICsgKG15RGF0ZS5nZXRNb250aCgpICsgMSkpLFxyXG5cdFx0ICAgIGRheSA9IG15RGF0ZS5nZXREYXkoKTtcclxuXHRcdHN3aXRjaCAoZGF5KSB7XHJcblx0XHRcdGNhc2UgMDpcclxuXHRcdFx0XHRkYXkgPSBcIuaYn+acn+aXpVwiO1xyXG5cdFx0XHRcdGxpc1sxXS5xdWVyeVNlbGVjdG9yKCdzcGFuJykuaW5uZXJIVE1MID0gXCLmmJ/mnJ/ml6VcIjtcclxuXHRcdFx0XHRsaXNbMl0ucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVySFRNTCA9IFwi5pif5pyf5LiAXCI7XHJcblx0XHRcdFx0bGlzWzNdLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS5pbm5lckhUTUwgPSBcIuaYn+acn+S6jFwiO1xyXG5cdFx0XHRcdGxpc1s0XS5xdWVyeVNlbGVjdG9yKCdzcGFuJykuaW5uZXJIVE1MID0gXCLmmJ/mnJ/kuIlcIjtcclxuXHRcdFx0XHRsaXNbNV0ucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVySFRNTCA9IFwi5pif5pyf5ZubXCI7XHJcblx0XHRcdFx0bGlzWzZdLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS5pbm5lckhUTUwgPSBcIuaYn+acn+S6lFwiO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIDE6XHJcblx0XHRcdFx0ZGF5ID0gXCLmmJ/mnJ/kuIBcIjtcclxuXHRcdFx0XHRsaXNbMV0ucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVySFRNTCA9IFwi5pif5pyf5LiAXCI7XHJcblx0XHRcdFx0bGlzWzJdLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS5pbm5lckhUTUwgPSBcIuaYn+acn+S6jFwiO1xyXG5cdFx0XHRcdGxpc1szXS5xdWVyeVNlbGVjdG9yKCdzcGFuJykuaW5uZXJIVE1MID0gXCLmmJ/mnJ/kuIlcIjtcclxuXHRcdFx0XHRsaXNbNF0ucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVySFRNTCA9IFwi5pif5pyf5ZubXCI7XHJcblx0XHRcdFx0bGlzWzVdLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS5pbm5lckhUTUwgPSBcIuaYn+acn+S6lFwiO1xyXG5cdFx0XHRcdGxpc1s2XS5xdWVyeVNlbGVjdG9yKCdzcGFuJykuaW5uZXJIVE1MID0gXCLmmJ/mnJ/lha1cIjtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSAyOlxyXG5cdFx0XHRcdGRheSA9IFwi5pif5pyf5LqMXCI7XHJcblx0XHRcdFx0bGlzWzFdLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS5pbm5lckhUTUwgPSBcIuaYn+acn+S6jFwiO1xyXG5cdFx0XHRcdGxpc1syXS5xdWVyeVNlbGVjdG9yKCdzcGFuJykuaW5uZXJIVE1MID0gXCLmmJ/mnJ/kuIlcIjtcclxuXHRcdFx0XHRsaXNbM10ucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVySFRNTCA9IFwi5pif5pyf5ZubXCI7XHJcblx0XHRcdFx0bGlzWzRdLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS5pbm5lckhUTUwgPSBcIuaYn+acn+S6lFwiO1xyXG5cdFx0XHRcdGxpc1s1XS5xdWVyeVNlbGVjdG9yKCdzcGFuJykuaW5uZXJIVE1MID0gXCLmmJ/mnJ/lha1cIjtcclxuXHRcdFx0XHRsaXNbNl0ucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVySFRNTCA9IFwi5pif5pyf5YWt5pelXCI7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgMzpcclxuXHRcdFx0XHRkYXkgPSBcIuaYn+acn+S4iVwiO1xyXG5cdFx0XHRcdGxpc1sxXS5xdWVyeVNlbGVjdG9yKCdzcGFuJykuaW5uZXJIVE1MID0gXCLmmJ/mnJ/kuIlcIjtcclxuXHRcdFx0XHRsaXNbMl0ucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVySFRNTCA9IFwi5pif5pyf5ZubXCI7XHJcblx0XHRcdFx0bGlzWzNdLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS5pbm5lckhUTUwgPSBcIuaYn+acn+S6lFwiO1xyXG5cdFx0XHRcdGxpc1s0XS5xdWVyeVNlbGVjdG9yKCdzcGFuJykuaW5uZXJIVE1MID0gXCLmmJ/mnJ/lha1cIjtcclxuXHRcdFx0XHRsaXNbNV0ucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVySFRNTCA9IFwi5pif5pyf5pelXCI7XHJcblx0XHRcdFx0bGlzWzZdLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS5pbm5lckhUTUwgPSBcIuaYn+acn+S4gFwiO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIDQ6XHJcblx0XHRcdFx0ZGF5ID0gXCLmmJ/mnJ/lm5tcIjtcclxuXHRcdFx0XHRsaXNbMV0ucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVySFRNTCA9IFwi5pif5pyf5ZubXCI7XHJcblx0XHRcdFx0bGlzWzJdLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS5pbm5lckhUTUwgPSBcIuaYn+acn+S6lFwiO1xyXG5cdFx0XHRcdGxpc1szXS5xdWVyeVNlbGVjdG9yKCdzcGFuJykuaW5uZXJIVE1MID0gXCLmmJ/mnJ/lha1cIjtcclxuXHRcdFx0XHRsaXNbNF0ucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVySFRNTCA9IFwi5pif5pyf5pelXCI7XHJcblx0XHRcdFx0bGlzWzVdLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS5pbm5lckhUTUwgPSBcIuaYn+acn+S4gFwiO1xyXG5cdFx0XHRcdGxpc1s2XS5xdWVyeVNlbGVjdG9yKCdzcGFuJykuaW5uZXJIVE1MID0gXCLmmJ/mnJ/kuoxcIjtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSA1OlxyXG5cdFx0XHRcdGRheSA9IFwi5pif5pyf5LqUXCI7XHJcblx0XHRcdFx0bGlzWzFdLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS5pbm5lckhUTUwgPSBcIuaYn+acn+S6lFwiO1xyXG5cdFx0XHRcdGxpc1syXS5xdWVyeVNlbGVjdG9yKCdzcGFuJykuaW5uZXJIVE1MID0gXCLmmJ/mnJ/lha1cIjtcclxuXHRcdFx0XHRsaXNbM10ucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVySFRNTCA9IFwi5pif5pyf5pelXCI7XHJcblx0XHRcdFx0bGlzWzRdLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS5pbm5lckhUTUwgPSBcIuaYn+acn+S4gFwiO1xyXG5cdFx0XHRcdGxpc1s1XS5xdWVyeVNlbGVjdG9yKCdzcGFuJykuaW5uZXJIVE1MID0gXCLmmJ/mnJ/kuoxcIjtcclxuXHRcdFx0XHRsaXNbNl0ucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVySFRNTCA9IFwi5pif5pyf5LiJXCI7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgNjpcclxuXHRcdFx0XHRkYXkgPSBcIuaYn+acn+WFrVwiO1xyXG5cdFx0XHRcdGxpc1sxXS5xdWVyeVNlbGVjdG9yKCdzcGFuJykuaW5uZXJIVE1MID0gXCLmmJ/mnJ/lha1cIjtcclxuXHRcdFx0XHRsaXNbMl0ucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVySFRNTCA9IFwi5pif5pyf5pelXCI7XHJcblx0XHRcdFx0bGlzWzNdLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS5pbm5lckhUTUwgPSBcIuaYn+acn+S4gFwiO1xyXG5cdFx0XHRcdGxpc1s0XS5xdWVyeVNlbGVjdG9yKCdzcGFuJykuaW5uZXJIVE1MID0gXCLmmJ/mnJ/kuoxcIjtcclxuXHRcdFx0XHRsaXNbNV0ucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVySFRNTCA9IFwi5pif5pyf5LiJXCI7XHJcblx0XHRcdFx0bGlzWzZdLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS5pbm5lckhUTUwgPSBcIuaYn+acn+Wbm1wiO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OiBicmVhaztcclxuXHRcdH1cclxuXHRcdG1vbnRoRGF5LmlubmVySFRNTCA9IG1vbnRoICsgXCLmnIhcIiArIG15RGF0ZS5nZXREYXRlKCkgKyBcIuaXpVwiO1xyXG5cdFx0d2Vla2RheS5pbm5lckhUTUwgPSBkYXk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpbml0Q2FudmFzKCkge1xyXG5cdFx0bGV0IHdpbndpZHRoID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcclxuXHRcdGxldCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY2FudmFzJyk7XHJcblx0XHRpZiAod2lud2lkdGggPiA2NDApIHtcclxuXHRcdFx0d2lud2lkdGggPSA2NDA7XHJcblx0XHR9XHJcblx0XHRjYW52YXMud2lkdGggPSB3aW53aWR0aDtcclxuXHRcdGNhbnZhcy5oZWlnaHQgPSB3aW53aWR0aCAvIDI7XHJcblx0XHRsZXQgY3h0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG5cdFx0Y3h0LmJlZ2luUGF0aCgpO1xyXG5cdFx0Y3h0Lm1vdmVUbyhjYW52YXMud2lkdGggLyAyMSwgY2FudmFzLmhlaWdodCAvIDIxKTtcclxuXHRcdGN4dC5saW5lVG8oY2FudmFzLndpZHRoIC8gMjEsIGNhbnZhcy5oZWlnaHQgLyAyMSAqIDIwKTtcclxuXHRcdGN4dC5saW5lVG8oY2FudmFzLndpZHRoIC8gMjEgKiAyMCwgY2FudmFzLmhlaWdodCAvIDIxICogMjApO1xyXG5cdFx0Y3h0LnN0cm9rZSgpO1xyXG5cdFx0Y3h0LmNsb3NlUGF0aCgpO1xyXG5cclxuXHRcdGN4dC5iZWdpblBhdGgoKTtcdFx0Ly/nlLvnrq3lpLQxXHJcblx0XHRjeHQubW92ZVRvKGNhbnZhcy53aWR0aCAvIDIxLCBjYW52YXMuaGVpZ2h0IC8gMjEpO1xyXG5cdFx0Y3h0LmxpbmVUbyhjYW52YXMud2lkdGggLyAyMSAtIDEwLCBjYW52YXMuaGVpZ2h0IC8gMjEgKyAxNSk7XHJcblx0XHRjeHQuc3Ryb2tlKCk7XHJcblx0XHRjeHQuY2xvc2VQYXRoKCk7XHJcblxyXG5cdFx0Y3h0LmJlZ2luUGF0aCgpO1x0XHQvL+eUu+eureWktDJcclxuXHRcdGN4dC5tb3ZlVG8oY2FudmFzLndpZHRoIC8gMjEsIGNhbnZhcy5oZWlnaHQgLyAyMSk7XHJcblx0XHRjeHQubGluZVRvKGNhbnZhcy53aWR0aCAvIDIxICsgMTAsIGNhbnZhcy5oZWlnaHQgLyAyMSArIDE1KTtcclxuXHRcdGN4dC5zdHJva2UoKTtcclxuXHRcdGN4dC5jbG9zZVBhdGgoKTtcclxuXHJcblx0XHRjeHQuYmVnaW5QYXRoKCk7XHRcdC8v55S7566t5aS0M1xyXG5cdFx0Y3h0LmxpbmVUbyhjYW52YXMud2lkdGggLyAyMSAqIDIwLCBjYW52YXMuaGVpZ2h0IC8gMjEgKiAyMCk7XHJcblx0XHRjeHQubGluZVRvKGNhbnZhcy53aWR0aCAvIDIxICogMjAgLSAxNSwgY2FudmFzLmhlaWdodCAvIDIxICogMjAgKyAxMCk7XHJcblx0XHRjeHQuc3Ryb2tlKCk7XHJcblx0XHRjeHQuY2xvc2VQYXRoKCk7XHJcblxyXG5cdFx0Y3h0LmJlZ2luUGF0aCgpO1x0XHQvL+eUu+eureWktDRcclxuXHRcdGN4dC5saW5lVG8oY2FudmFzLndpZHRoIC8gMjEgKiAyMCwgY2FudmFzLmhlaWdodCAvIDIxICogMjApO1xyXG5cdFx0Y3h0LmxpbmVUbyhjYW52YXMud2lkdGggLyAyMSAqIDIwIC0gMTUsIGNhbnZhcy5oZWlnaHQgLyAyMSAqIDIwIC0gMTApO1xyXG5cdFx0Y3h0LnN0cm9rZSgpO1xyXG5cdFx0Y3h0LmNsb3NlUGF0aCgpO1xyXG5cclxuXHRcdGFqYXgoe1xyXG5cdFx0XHRtZXRob3I6IFwiZ2V0XCIsXHJcblx0XHRcdHVybDogXCIvZm9yZWNhc3RcIixcclxuXHRcdFx0YXN5bjogdHJ1ZSxcclxuXHRcdFx0c3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcclxuXHRcdFx0XHRsZXQgRGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XHJcblx0XHRcdFx0aDEgPSBNYXRoLmNlaWwoKERhdGFbMF0ubWF4X3RlbXAgKyBEYXRhWzBdLm1pbl90ZW1wKSAvIDIpO1xyXG5cdFx0XHRcdGgyID0gTWF0aC5jZWlsKChEYXRhWzFdLm1heF90ZW1wICsgRGF0YVsxXS5taW5fdGVtcCkgLyAyKTtcclxuXHRcdFx0XHRoMyA9IE1hdGguY2VpbCgoRGF0YVsyXS5tYXhfdGVtcCArIERhdGFbMl0ubWluX3RlbXApIC8gMik7XHJcblx0XHRcdFx0aDQgPSBNYXRoLmNlaWwoKERhdGFbM10ubWF4X3RlbXAgKyBEYXRhWzNdLm1pbl90ZW1wKSAvIDIpO1xyXG5cdFx0XHRcdGg1ID0gTWF0aC5jZWlsKChEYXRhWzRdLm1heF90ZW1wICsgRGF0YVs0XS5taW5fdGVtcCkgLyAyKTtcclxuXHRcdFx0XHRoNiA9IE1hdGguY2VpbCgoRGF0YVs1XS5tYXhfdGVtcCArIERhdGFbNV0ubWluX3RlbXApIC8gMik7XHJcblx0XHRcdFx0aDcgPSBNYXRoLmNlaWwoKERhdGFbNl0ubWF4X3RlbXAgKyBEYXRhWzZdLm1pbl90ZW1wKSAvIDIpO1xyXG5cclxuXHRcdFx0XHR6aGV4aWFuKCk7XHJcblx0XHRcdFx0ZGlhbigpO1xyXG5cdFx0XHRcdHdlbmR1KCk7XHJcblx0XHRcdFx0Ly/nlLvmuKnluqbmipjnur9cclxuXHRcdFx0XHRmdW5jdGlvbiB6aGV4aWFuKCkge1xyXG5cdFx0XHRcdFx0Y3h0LnN0cm9rZVN0eWxlID0gXCIjOTk5XCI7XHJcblx0XHRcdFx0XHRjeHQuYmVnaW5QYXRoKCk7XHJcblx0XHRcdFx0XHRjeHQubW92ZVRvKE1hdGguZmxvb3IoY2FudmFzLndpZHRoIC8gMTQpLCBNYXRoLmZsb29yKGNhbnZhcy5oZWlnaHQgLSBjYW52YXMuaGVpZ2h0ICAqIGgxIC8gNTUpKTtcclxuXHRcdFx0XHRcdGN4dC5saW5lVG8oTWF0aC5mbG9vcihjYW52YXMud2lkdGggLyAxNCAqIDMpLCBNYXRoLmZsb29yKGNhbnZhcy5oZWlnaHQgLSBjYW52YXMuaGVpZ2h0ICAqIGgyIC8gNTUpKTtcclxuXHRcdFx0XHRcdGN4dC5saW5lVG8oTWF0aC5mbG9vcihjYW52YXMud2lkdGggLyAxNCAqIDUpLCBNYXRoLmZsb29yKGNhbnZhcy5oZWlnaHQgLSBjYW52YXMuaGVpZ2h0ICogaDMgLyA1NSkpO1xyXG5cdFx0XHRcdFx0Y3h0LmxpbmVUbyhNYXRoLmZsb29yKGNhbnZhcy53aWR0aCAvIDE0ICogNyksIE1hdGguZmxvb3IoY2FudmFzLmhlaWdodCAtIGNhbnZhcy5oZWlnaHQgKiBoNCAvIDU1KSk7XHJcblx0XHRcdFx0XHRjeHQubGluZVRvKE1hdGguZmxvb3IoY2FudmFzLndpZHRoIC8gMTQgKiA5KSwgTWF0aC5mbG9vcihjYW52YXMuaGVpZ2h0IC0gY2FudmFzLmhlaWdodCAqIGg1IC8gNTUpKTtcclxuXHRcdFx0XHRcdGN4dC5saW5lVG8oTWF0aC5mbG9vcihjYW52YXMud2lkdGggLyAxNCAqIDExKSwgTWF0aC5mbG9vcihjYW52YXMuaGVpZ2h0IC0gY2FudmFzLmhlaWdodCAqIGg2IC8gNTUpKTtcclxuXHRcdFx0XHRcdGN4dC5saW5lVG8oTWF0aC5mbG9vcihjYW52YXMud2lkdGggLyAxNCAqIDEzKSwgTWF0aC5mbG9vcihjYW52YXMuaGVpZ2h0IC0gY2FudmFzLmhlaWdodCAqIGg3IC8gNTUpKTtcclxuXHRcdFx0XHRcdGN4dC5zdHJva2UoKTtcclxuXHRcdFx0XHRcdGN4dC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8v55S75rip5bqm55qE54K5XHJcblx0XHRcdFx0ZnVuY3Rpb24gZGlhbigpIHtcclxuXHRcdFx0XHRcdGN4dC5zdHJva2VTdHlsZSA9IFwiIzY2NlwiO1xyXG5cdFx0XHRcdFx0Y3h0LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdFx0Y3h0LmFyYyhNYXRoLmZsb29yKGNhbnZhcy53aWR0aCAvIDE0KSwgTWF0aC5mbG9vcihjYW52YXMuaGVpZ2h0IC0gY2FudmFzLmhlaWdodCAgKiBoMSAvIDU1KSwgMiwgMCwgMiAqIE1hdGguUEkpO1xyXG5cdFx0XHRcdFx0Y3h0LmFyYyhNYXRoLmZsb29yKGNhbnZhcy53aWR0aCAvIDE0ICogMyksIE1hdGguZmxvb3IoY2FudmFzLmhlaWdodCAtIGNhbnZhcy5oZWlnaHQgICogaDIgLyA1NSksIDIsIDAsIDIgKiBNYXRoLlBJKTtcclxuXHRcdFx0XHRcdGN4dC5hcmMoTWF0aC5mbG9vcihjYW52YXMud2lkdGggLyAxNCAqIDUpLCBNYXRoLmZsb29yKGNhbnZhcy5oZWlnaHQgLSBjYW52YXMuaGVpZ2h0ICogaDMgLyA1NSksIDIsIDAsIDIgKiBNYXRoLlBJKTtcclxuXHRcdFx0XHRcdGN4dC5hcmMoTWF0aC5mbG9vcihjYW52YXMud2lkdGggLyAxNCAqIDcpLCBNYXRoLmZsb29yKGNhbnZhcy5oZWlnaHQgLSBjYW52YXMuaGVpZ2h0ICogaDQgLyA1NSksIDIsIDAsIDIgKiBNYXRoLlBJKTtcclxuXHRcdFx0XHRcdGN4dC5hcmMoTWF0aC5mbG9vcihjYW52YXMud2lkdGggLyAxNCAqIDkpLCBNYXRoLmZsb29yKGNhbnZhcy5oZWlnaHQgLSBjYW52YXMuaGVpZ2h0ICogaDUgLyA1NSksIDIsIDAsIDIgKiBNYXRoLlBJKTtcclxuXHRcdFx0XHRcdGN4dC5hcmMoTWF0aC5mbG9vcihjYW52YXMud2lkdGggLyAxNCAqIDExKSwgTWF0aC5mbG9vcihjYW52YXMuaGVpZ2h0IC0gY2FudmFzLmhlaWdodCAqIGg2IC8gNTUpLCAyLCAwLCAyICogTWF0aC5QSSk7XHJcblx0XHRcdFx0XHRjeHQuYXJjKE1hdGguZmxvb3IoY2FudmFzLndpZHRoIC8gMTQgKiAxMyksIE1hdGguZmxvb3IoY2FudmFzLmhlaWdodCAtIGNhbnZhcy5oZWlnaHQgKiBoNyAvIDU1KSwgMiwgMCwgMiAqIE1hdGguUEkpO1xyXG5cdFx0ICAgXHRcdFx0Y3h0LnN0cm9rZSgpO1xyXG5cdFx0XHRcdFx0Y3h0LmNsb3NlUGF0aCgpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly/lhpnmuKnluqZcclxuXHRcdFx0XHRmdW5jdGlvbiB3ZW5kdSgpIHtcclxuXHRcdFx0XHRcdGN4dC5mb250PVwiMTVweFwiO1xyXG5cdFx0XHRcdFx0Y3h0LnN0cm9rZVN0eWxlID0gXCJibGFja1wiO1xyXG5cdFx0XHRcdFx0Y3h0LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdFx0Ly/nrKzkuIDkuKpcclxuXHRcdFx0XHQgICAgY3h0LnN0cm9rZVRleHQoRGF0YVswXS5tYXhfdGVtcCArIFwiwrBcIiwgTWF0aC5mbG9vcihjYW52YXMud2lkdGggLyAxNCAtIDE1KSwgTWF0aC5mbG9vcihjYW52YXMuaGVpZ2h0IC0gY2FudmFzLmhlaWdodCAgKiBoMSAvIDU1IC0gMTUgKSk7XHJcblx0XHRcdFx0XHRjeHQuc3Ryb2tlVGV4dChEYXRhWzBdLm1pbl90ZW1wICsgXCLCsFwiLCBNYXRoLmZsb29yKGNhbnZhcy53aWR0aCAvIDE0IC0gMTUpLCBNYXRoLmZsb29yKGNhbnZhcy5oZWlnaHQgLSBjYW52YXMuaGVpZ2h0ICAqIGgxIC8gNTUgKyAyMCApKTtcclxuXHRcdFx0XHRcdC8v56ys5LqM5LiqXHJcblx0XHRcdFx0XHRjeHQuc3Ryb2tlVGV4dChEYXRhWzFdLm1heF90ZW1wICsgXCLCsFwiLCBNYXRoLmZsb29yKGNhbnZhcy53aWR0aCAvIDE0ICogMyAtIDE1KSwgTWF0aC5mbG9vcihjYW52YXMuaGVpZ2h0IC0gY2FudmFzLmhlaWdodCAgKiBoMiAvIDU1IC0gMTUgKSk7XHJcblx0XHRcdFx0XHRjeHQuc3Ryb2tlVGV4dChEYXRhWzFdLm1pbl90ZW1wICsgXCLCsFwiLCBNYXRoLmZsb29yKGNhbnZhcy53aWR0aCAvIDE0ICogMyAtIDE1KSwgTWF0aC5mbG9vcihjYW52YXMuaGVpZ2h0IC0gY2FudmFzLmhlaWdodCAgKiBoMiAvIDU1ICsgMTUgKSk7XHJcblx0XHRcdFx0XHQvL+esrOS4ieS4qlxyXG5cdFx0XHRcdFx0Y3h0LnN0cm9rZVRleHQoRGF0YVsyXS5tYXhfdGVtcCArIFwiwrBcIiwgTWF0aC5mbG9vcihjYW52YXMud2lkdGggLyAxNCAqIDUgLSAxNSksIE1hdGguZmxvb3IoY2FudmFzLmhlaWdodCAtIGNhbnZhcy5oZWlnaHQgICogaDMgLyA1NSAtIDE1ICkpO1xyXG5cdFx0XHRcdFx0Y3h0LnN0cm9rZVRleHQoRGF0YVsyXS5taW5fdGVtcCArIFwiwrBcIiwgTWF0aC5mbG9vcihjYW52YXMud2lkdGggLyAxNCAqIDUgLSAxNSksIE1hdGguZmxvb3IoY2FudmFzLmhlaWdodCAtIGNhbnZhcy5oZWlnaHQgICogaDMgLyA1NSArIDIwICkpO1xyXG5cdFx0XHRcdFx0Ly/nrKzlm5vkuKpcclxuXHRcdFx0XHRcdGN4dC5zdHJva2VUZXh0KERhdGFbM10ubWF4X3RlbXAgKyBcIsKwXCIsIE1hdGguZmxvb3IoY2FudmFzLndpZHRoIC8gMTQgKiA3IC0gMTUpLCBNYXRoLmZsb29yKGNhbnZhcy5oZWlnaHQgLSBjYW52YXMuaGVpZ2h0ICAqIGg0IC8gNTUgLSAxNSApKTtcclxuXHRcdFx0XHRcdGN4dC5zdHJva2VUZXh0KERhdGFbM10ubWluX3RlbXAgKyBcIsKwXCIsIE1hdGguZmxvb3IoY2FudmFzLndpZHRoIC8gMTQgKiA3IC0gMTUpLCBNYXRoLmZsb29yKGNhbnZhcy5oZWlnaHQgLSBjYW52YXMuaGVpZ2h0ICAqIGg0IC8gNTUgKyAyMCApKTtcclxuXHRcdFx0XHRcdC8v56ys5LqU5LiqXHJcblx0XHRcdFx0XHRjeHQuc3Ryb2tlVGV4dChEYXRhWzRdLm1heF90ZW1wICsgXCLCsFwiLCBNYXRoLmZsb29yKGNhbnZhcy53aWR0aCAvIDE0ICogOSAtIDE1KSwgTWF0aC5mbG9vcihjYW52YXMuaGVpZ2h0IC0gY2FudmFzLmhlaWdodCAgKiBoNSAvIDU1IC0gMTUgKSk7XHJcblx0XHRcdFx0XHRjeHQuc3Ryb2tlVGV4dChEYXRhWzRdLm1pbl90ZW1wICsgXCLCsFwiLCBNYXRoLmZsb29yKGNhbnZhcy53aWR0aCAvIDE0ICogOSAtIDE1KSwgTWF0aC5mbG9vcihjYW52YXMuaGVpZ2h0IC0gY2FudmFzLmhlaWdodCAgKiBoNSAvIDU1ICsgMjAgKSk7XHJcblx0XHRcdFx0XHQvL+esrOWFreS4qlxyXG5cdFx0XHRcdFx0Y3h0LnN0cm9rZVRleHQoRGF0YVs1XS5tYXhfdGVtcCArIFwiwrBcIiwgTWF0aC5mbG9vcihjYW52YXMud2lkdGggLyAxNCAqIDExIC0gMTUpLCBNYXRoLmZsb29yKGNhbnZhcy5oZWlnaHQgLSBjYW52YXMuaGVpZ2h0ICAqIGg2IC8gNTUgLSAxNSApKTtcclxuXHRcdFx0XHRcdGN4dC5zdHJva2VUZXh0KERhdGFbNV0ubWluX3RlbXAgKyBcIsKwXCIsIE1hdGguZmxvb3IoY2FudmFzLndpZHRoIC8gMTQgKiAxMSAtIDE1KSwgTWF0aC5mbG9vcihjYW52YXMuaGVpZ2h0IC0gY2FudmFzLmhlaWdodCAgKiBoNiAvIDU1ICsgMjAgKSk7XHJcblx0XHRcdFx0XHQvL+esrOS4g+S4qlxyXG5cdFx0XHRcdFx0Y3h0LnN0cm9rZVRleHQoRGF0YVs2XS5tYXhfdGVtcCArIFwiwrBcIiwgTWF0aC5mbG9vcihjYW52YXMud2lkdGggLyAxNCAqIDEzIC0gMTUpLCBNYXRoLmZsb29yKGNhbnZhcy5oZWlnaHQgLSBjYW52YXMuaGVpZ2h0ICAqIGg3IC8gNTUgLSAxNSApKTtcclxuXHRcdFx0XHRcdGN4dC5zdHJva2VUZXh0KERhdGFbNl0ubWluX3RlbXAgKyBcIsKwXCIsIE1hdGguZmxvb3IoY2FudmFzLndpZHRoIC8gMTQgKiAxMyAtIDE1KSwgTWF0aC5mbG9vcihjYW52YXMuaGVpZ2h0IC0gY2FudmFzLmhlaWdodCAgKiBoNyAvIDU1ICsgMjAgKSk7XHJcblx0XHRcdFx0XHRjeHQuY2xvc2VQYXRoKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBhamF4KGpzb24pIHtcclxuXHQgICAgLy8g5Yib5bu6YWpheOWvueixoVxyXG5cdCAgICBsZXQgeGhyID0gbnVsbDtcclxuXHQgICAgbGV0IG1ldGhvciA9IGpzb24ubWV0aG9yIHx8ICdnZXQnO1xyXG5cdCAgICBsZXQgdXJsID0ganNvbi51cmw7XHJcblx0ICAgIGxldCBhc3luID0ganNvbi5hc3luID8gdHJ1ZSA6IGpzb24uYXN5biA9PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcclxuXHQgICAgbGV0IGRhdGEgPSBqc29uLmRhdGEgfHwgJyc7XHJcblx0ICAgIGxldCBzdWNjZXNzID0ganNvbi5zdWNjZXNzO1xyXG5cdCAgICBsZXQgZXJyb3IgPSBqc29uLmVycm9yO1xyXG5cclxuXHQgICAgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xyXG5cdCAgICAgICAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICB4aHIgPSBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKVxyXG5cdCAgICB9XHJcblx0ICAgIGlmIChtZXRob3IudG9Mb3dlckNhc2UoKSA9PT0gJ2dldCcpe1xyXG5cdCAgICAgICAgeGhyLm9wZW4obWV0aG9yLHVybCxhc3luKTtcclxuXHQgICAgICAgIHVybCArPSAnPycgKyBkYXRhICsgJyYnICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKG1ldGhvci50b0xvd2VyQ2FzZSgpID09PSAncG9zdCcpIHtcclxuXHQgICAgICAgICAgICB4aHIub3BlbihtZXRob3IsIHVybCwgYXN5bik7XHJcblx0ICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICAvLyDlpITnkIbov5Tlm57mlbDmja5cclxuXHQgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XHJcblx0ICAgICAgICBpZih4aHIucmVhZHlTdGF0ZSA9PSA0KXtcclxuXHQgICAgICAgICAgICBpZih4aHIuc3RhdHVzID09IDIwMCl7XHJcblx0ICAgICAgICAgICAgICAgIHN1Y2Nlc3MgJiYgc3VjY2Vzcyh4aHIucmVzcG9uc2VUZXh0KTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZihlcnJvcil7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlcnJvciAmJiBlcnJvcigpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIHhoci5zZW5kKGRhdGEpO1xyXG5cdH07XHJcblxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC9tYWluLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/*!\n * Less - Leaner CSS v2.7.2\n * http://lesscss.org\n *\n * Copyright (c) 2009-2017, Alexis Sellier <self@cloudhead.net>\n * Licensed under the Apache-2.0 License.\n *\n */\n\n /** * @license Apache-2.0\n */\n\n(function(f){if(true){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.less = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar addDataAttr = require(\"./utils\").addDataAttr,\n    browser = require(\"./browser\");\n\nmodule.exports = function(window, options) {\n\n    // use options from the current script tag data attribues\n    addDataAttr(options, browser.currentScript(window));\n\n    if (options.isFileProtocol === undefined) {\n        options.isFileProtocol = /^(file|(chrome|safari)(-extension)?|resource|qrc|app):/.test(window.location.protocol);\n    }\n\n    // Load styles asynchronously (default: false)\n    //\n    // This is set to `false` by default, so that the body\n    // doesn't start loading before the stylesheets are parsed.\n    // Setting this to `true` can result in flickering.\n    //\n    options.async = options.async || false;\n    options.fileAsync = options.fileAsync || false;\n\n    // Interval between watch polls\n    options.poll = options.poll || (options.isFileProtocol ? 1000 : 1500);\n\n    options.env = options.env || (window.location.hostname == '127.0.0.1' ||\n        window.location.hostname == '0.0.0.0'   ||\n        window.location.hostname == 'localhost' ||\n        (window.location.port &&\n            window.location.port.length > 0)      ||\n        options.isFileProtocol                   ? 'development'\n        : 'production');\n\n    var dumpLineNumbers = /!dumpLineNumbers:(comments|mediaquery|all)/.exec(window.location.hash);\n    if (dumpLineNumbers) {\n        options.dumpLineNumbers = dumpLineNumbers[1];\n    }\n\n    if (options.useFileCache === undefined) {\n        options.useFileCache = true;\n    }\n\n    if (options.onReady === undefined) {\n        options.onReady = true;\n    }\n\n};\n\n},{\"./browser\":3,\"./utils\":10}],2:[function(require,module,exports){\n/**\n * Kicks off less and compiles any stylesheets\n * used in the browser distributed version of less\n * to kick-start less using the browser api\n */\n/*global window, document */\n\n// shim Promise if required\nrequire('promise/polyfill.js');\n\nvar options = window.less || {};\nrequire(\"./add-default-options\")(window, options);\n\nvar less = module.exports = require(\"./index\")(window, options);\n\nwindow.less = less;\n\nvar css, head, style;\n\n// Always restore page visibility\nfunction resolveOrReject(data) {\n    if (data.filename) {\n        console.warn(data);\n    }\n    if (!options.async) {\n        head.removeChild(style);\n    }\n}\n\nif (options.onReady) {\n    if (/!watch/.test(window.location.hash)) {\n        less.watch();\n    }\n    // Simulate synchronous stylesheet loading by blocking page rendering\n    if (!options.async) {\n        css = 'body { display: none !important }';\n        head = document.head || document.getElementsByTagName('head')[0];\n        style = document.createElement('style');\n\n        style.type = 'text/css';\n        if (style.styleSheet) {\n            style.styleSheet.cssText = css;\n        } else {\n            style.appendChild(document.createTextNode(css));\n        }\n\n        head.appendChild(style);\n    }\n    less.registerStylesheetsImmediately();\n    less.pageLoadFinished = less.refresh(less.env === 'development').then(resolveOrReject, resolveOrReject);\n}\n\n},{\"./add-default-options\":1,\"./index\":8,\"promise/polyfill.js\":97}],3:[function(require,module,exports){\nvar utils = require(\"./utils\");\nmodule.exports = {\n    createCSS: function (document, styles, sheet) {\n        // Strip the query-string\n        var href = sheet.href || '';\n\n        // If there is no title set, use the filename, minus the extension\n        var id = 'less:' + (sheet.title || utils.extractId(href));\n\n        // If this has already been inserted into the DOM, we may need to replace it\n        var oldStyleNode = document.getElementById(id);\n        var keepOldStyleNode = false;\n\n        // Create a new stylesheet node for insertion or (if necessary) replacement\n        var styleNode = document.createElement('style');\n        styleNode.setAttribute('type', 'text/css');\n        if (sheet.media) {\n            styleNode.setAttribute('media', sheet.media);\n        }\n        styleNode.id = id;\n\n        if (!styleNode.styleSheet) {\n            styleNode.appendChild(document.createTextNode(styles));\n\n            // If new contents match contents of oldStyleNode, don't replace oldStyleNode\n            keepOldStyleNode = (oldStyleNode !== null && oldStyleNode.childNodes.length > 0 && styleNode.childNodes.length > 0 &&\n                oldStyleNode.firstChild.nodeValue === styleNode.firstChild.nodeValue);\n        }\n\n        var head = document.getElementsByTagName('head')[0];\n\n        // If there is no oldStyleNode, just append; otherwise, only append if we need\n        // to replace oldStyleNode with an updated stylesheet\n        if (oldStyleNode === null || keepOldStyleNode === false) {\n            var nextEl = sheet && sheet.nextSibling || null;\n            if (nextEl) {\n                nextEl.parentNode.insertBefore(styleNode, nextEl);\n            } else {\n                head.appendChild(styleNode);\n            }\n        }\n        if (oldStyleNode && keepOldStyleNode === false) {\n            oldStyleNode.parentNode.removeChild(oldStyleNode);\n        }\n\n        // For IE.\n        // This needs to happen *after* the style element is added to the DOM, otherwise IE 7 and 8 may crash.\n        // See http://social.msdn.microsoft.com/Forums/en-US/7e081b65-878a-4c22-8e68-c10d39c2ed32/internet-explorer-crashes-appending-style-element-to-head\n        if (styleNode.styleSheet) {\n            try {\n                styleNode.styleSheet.cssText = styles;\n            } catch (e) {\n                throw new Error(\"Couldn't reassign styleSheet.cssText.\");\n            }\n        }\n    },\n    currentScript: function(window) {\n        var document = window.document;\n        return document.currentScript || (function() {\n            var scripts = document.getElementsByTagName(\"script\");\n            return scripts[scripts.length - 1];\n        })();\n    }\n};\n\n},{\"./utils\":10}],4:[function(require,module,exports){\n// Cache system is a bit outdated and could do with work\n\nmodule.exports = function(window, options, logger) {\n    var cache = null;\n    if (options.env !== 'development') {\n        try {\n            cache = (typeof window.localStorage === 'undefined') ? null : window.localStorage;\n        } catch (_) {}\n    }\n    return {\n        setCSS: function(path, lastModified, modifyVars, styles) {\n            if (cache) {\n                logger.info('saving ' + path + ' to cache.');\n                try {\n                    cache.setItem(path, styles);\n                    cache.setItem(path + ':timestamp', lastModified);\n                    if (modifyVars) {\n                        cache.setItem(path + ':vars', JSON.stringify(modifyVars));\n                    }\n                } catch(e) {\n                    //TODO - could do with adding more robust error handling\n                    logger.error('failed to save \"' + path + '\" to local storage for caching.');\n                }\n            }\n        },\n        getCSS: function(path, webInfo, modifyVars) {\n            var css       = cache && cache.getItem(path),\n                timestamp = cache && cache.getItem(path + ':timestamp'),\n                vars      = cache && cache.getItem(path + ':vars');\n\n            modifyVars = modifyVars || {};\n\n            if (timestamp && webInfo.lastModified &&\n                (new Date(webInfo.lastModified).valueOf() ===\n                    new Date(timestamp).valueOf()) &&\n                (!modifyVars && !vars || JSON.stringify(modifyVars) === vars)) {\n                // Use local copy\n                return css;\n            }\n        }\n    };\n};\n\n},{}],5:[function(require,module,exports){\nvar utils = require(\"./utils\"),\n    browser = require(\"./browser\");\n\nmodule.exports = function(window, less, options) {\n\n    function errorHTML(e, rootHref) {\n        var id = 'less-error-message:' + utils.extractId(rootHref || \"\");\n        var template = '<li><label>{line}</label><pre class=\"{class}\">{content}</pre></li>';\n        var elem = window.document.createElement('div'), timer, content, errors = [];\n        var filename = e.filename || rootHref;\n        var filenameNoPath = filename.match(/([^\\/]+(\\?.*)?)$/)[1];\n\n        elem.id        = id;\n        elem.className = \"less-error-message\";\n\n        content = '<h3>'  + (e.type || \"Syntax\") + \"Error: \" + (e.message || 'There is an error in your .less file') +\n            '</h3>' + '<p>in <a href=\"' + filename   + '\">' + filenameNoPath + \"</a> \";\n\n        var errorline = function (e, i, classname) {\n            if (e.extract[i] !== undefined) {\n                errors.push(template.replace(/\\{line\\}/, (parseInt(e.line, 10) || 0) + (i - 1))\n                    .replace(/\\{class\\}/, classname)\n                    .replace(/\\{content\\}/, e.extract[i]));\n            }\n        };\n\n        if (e.extract) {\n            errorline(e, 0, '');\n            errorline(e, 1, 'line');\n            errorline(e, 2, '');\n            content += 'on line ' + e.line + ', column ' + (e.column + 1) + ':</p>' +\n                '<ul>' + errors.join('') + '</ul>';\n        }\n        if (e.stack && (e.extract || options.logLevel >= 4)) {\n            content += '<br/>Stack Trace</br />' + e.stack.split('\\n').slice(1).join('<br/>');\n        }\n        elem.innerHTML = content;\n\n        // CSS for error messages\n        browser.createCSS(window.document, [\n            '.less-error-message ul, .less-error-message li {',\n            'list-style-type: none;',\n            'margin-right: 15px;',\n            'padding: 4px 0;',\n            'margin: 0;',\n            '}',\n            '.less-error-message label {',\n            'font-size: 12px;',\n            'margin-right: 15px;',\n            'padding: 4px 0;',\n            'color: #cc7777;',\n            '}',\n            '.less-error-message pre {',\n            'color: #dd6666;',\n            'padding: 4px 0;',\n            'margin: 0;',\n            'display: inline-block;',\n            '}',\n            '.less-error-message pre.line {',\n            'color: #ff0000;',\n            '}',\n            '.less-error-message h3 {',\n            'font-size: 20px;',\n            'font-weight: bold;',\n            'padding: 15px 0 5px 0;',\n            'margin: 0;',\n            '}',\n            '.less-error-message a {',\n            'color: #10a',\n            '}',\n            '.less-error-message .error {',\n            'color: red;',\n            'font-weight: bold;',\n            'padding-bottom: 2px;',\n            'border-bottom: 1px dashed red;',\n            '}'\n        ].join('\\n'), { title: 'error-message' });\n\n        elem.style.cssText = [\n            \"font-family: Arial, sans-serif\",\n            \"border: 1px solid #e00\",\n            \"background-color: #eee\",\n            \"border-radius: 5px\",\n            \"-webkit-border-radius: 5px\",\n            \"-moz-border-radius: 5px\",\n            \"color: #e00\",\n            \"padding: 15px\",\n            \"margin-bottom: 15px\"\n        ].join(';');\n\n        if (options.env === 'development') {\n            timer = setInterval(function () {\n                var document = window.document,\n                    body = document.body;\n                if (body) {\n                    if (document.getElementById(id)) {\n                        body.replaceChild(elem, document.getElementById(id));\n                    } else {\n                        body.insertBefore(elem, body.firstChild);\n                    }\n                    clearInterval(timer);\n                }\n            }, 10);\n        }\n    }\n\n    function removeErrorHTML(path) {\n        var node = window.document.getElementById('less-error-message:' + utils.extractId(path));\n        if (node) {\n            node.parentNode.removeChild(node);\n        }\n    }\n\n    function removeErrorConsole(path) {\n        //no action\n    }\n\n    function removeError(path) {\n        if (!options.errorReporting || options.errorReporting === \"html\") {\n            removeErrorHTML(path);\n        } else if (options.errorReporting === \"console\") {\n            removeErrorConsole(path);\n        } else if (typeof options.errorReporting === 'function') {\n            options.errorReporting(\"remove\", path);\n        }\n    }\n\n    function errorConsole(e, rootHref) {\n        var template = '{line} {content}';\n        var filename = e.filename || rootHref;\n        var errors = [];\n        var content = (e.type || \"Syntax\") + \"Error: \" + (e.message || 'There is an error in your .less file') +\n            \" in \" + filename + \" \";\n\n        var errorline = function (e, i, classname) {\n            if (e.extract[i] !== undefined) {\n                errors.push(template.replace(/\\{line\\}/, (parseInt(e.line, 10) || 0) + (i - 1))\n                    .replace(/\\{class\\}/, classname)\n                    .replace(/\\{content\\}/, e.extract[i]));\n            }\n        };\n\n        if (e.extract) {\n            errorline(e, 0, '');\n            errorline(e, 1, 'line');\n            errorline(e, 2, '');\n            content += 'on line ' + e.line + ', column ' + (e.column + 1) + ':\\n' +\n                errors.join('\\n');\n        }\n        if (e.stack && (e.extract || options.logLevel >= 4)) {\n            content += '\\nStack Trace\\n' + e.stack;\n        }\n        less.logger.error(content);\n    }\n\n    function error(e, rootHref) {\n        if (!options.errorReporting || options.errorReporting === \"html\") {\n            errorHTML(e, rootHref);\n        } else if (options.errorReporting === \"console\") {\n            errorConsole(e, rootHref);\n        } else if (typeof options.errorReporting === 'function') {\n            options.errorReporting(\"add\", e, rootHref);\n        }\n    }\n\n    return {\n        add: error,\n        remove: removeError\n    };\n};\n\n},{\"./browser\":3,\"./utils\":10}],6:[function(require,module,exports){\n/*global window, XMLHttpRequest */\n\nmodule.exports = function(options, logger) {\n\n    var AbstractFileManager = require(\"../less/environment/abstract-file-manager.js\");\n\n    var fileCache = {};\n\n    //TODOS - move log somewhere. pathDiff and doing something similar in node. use pathDiff in the other browser file for the initial load\n\n    function getXMLHttpRequest() {\n        if (window.XMLHttpRequest && (window.location.protocol !== \"file:\" || !(\"ActiveXObject\" in window))) {\n            return new XMLHttpRequest();\n        } else {\n            try {\n                /*global ActiveXObject */\n                return new ActiveXObject(\"Microsoft.XMLHTTP\");\n            } catch (e) {\n                logger.error(\"browser doesn't support AJAX.\");\n                return null;\n            }\n        }\n    }\n\n    var FileManager = function() {\n    };\n\n    FileManager.prototype = new AbstractFileManager();\n\n    FileManager.prototype.alwaysMakePathsAbsolute = function alwaysMakePathsAbsolute() {\n        return true;\n    };\n    FileManager.prototype.join = function join(basePath, laterPath) {\n        if (!basePath) {\n            return laterPath;\n        }\n        return this.extractUrlParts(laterPath, basePath).path;\n    };\n    FileManager.prototype.doXHR = function doXHR(url, type, callback, errback) {\n\n        var xhr = getXMLHttpRequest();\n        var async = options.isFileProtocol ? options.fileAsync : true;\n\n        if (typeof xhr.overrideMimeType === 'function') {\n            xhr.overrideMimeType('text/css');\n        }\n        logger.debug(\"XHR: Getting '\" + url + \"'\");\n        xhr.open('GET', url, async);\n        xhr.setRequestHeader('Accept', type || 'text/x-less, text/css; q=0.9, */*; q=0.5');\n        xhr.send(null);\n\n        function handleResponse(xhr, callback, errback) {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                callback(xhr.responseText,\n                    xhr.getResponseHeader(\"Last-Modified\"));\n            } else if (typeof errback === 'function') {\n                errback(xhr.status, url);\n            }\n        }\n\n        if (options.isFileProtocol && !options.fileAsync) {\n            if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)) {\n                callback(xhr.responseText);\n            } else {\n                errback(xhr.status, url);\n            }\n        } else if (async) {\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState == 4) {\n                    handleResponse(xhr, callback, errback);\n                }\n            };\n        } else {\n            handleResponse(xhr, callback, errback);\n        }\n    };\n    FileManager.prototype.supports = function(filename, currentDirectory, options, environment) {\n        return true;\n    };\n\n    FileManager.prototype.clearFileCache = function() {\n        fileCache = {};\n    };\n\n    FileManager.prototype.loadFile = function loadFile(filename, currentDirectory, options, environment, callback) {\n        if (currentDirectory && !this.isPathAbsolute(filename)) {\n            filename = currentDirectory + filename;\n        }\n\n        options = options || {};\n\n        // sheet may be set to the stylesheet for the initial load or a collection of properties including\n        // some context variables for imports\n        var hrefParts = this.extractUrlParts(filename, window.location.href);\n        var href      = hrefParts.url;\n\n        if (options.useFileCache && fileCache[href]) {\n            try {\n                var lessText = fileCache[href];\n                callback(null, { contents: lessText, filename: href, webInfo: { lastModified: new Date() }});\n            } catch (e) {\n                callback({filename: href, message: \"Error loading file \" + href + \" error was \" + e.message});\n            }\n            return;\n        }\n\n        this.doXHR(href, options.mime, function doXHRCallback(data, lastModified) {\n            // per file cache\n            fileCache[href] = data;\n\n            // Use remote copy (re-parse)\n            callback(null, { contents: data, filename: href, webInfo: { lastModified: lastModified }});\n        }, function doXHRError(status, url) {\n            callback({ type: 'File', message: \"'\" + url + \"' wasn't found (\" + status + \")\", href: href });\n        });\n    };\n\n    return FileManager;\n};\n\n},{\"../less/environment/abstract-file-manager.js\":15}],7:[function(require,module,exports){\nmodule.exports = function() {\n\n    var functionRegistry = require(\"./../less/functions/function-registry\");\n\n    function imageSize() {\n        throw {\n            type: \"Runtime\",\n            message: \"Image size functions are not supported in browser version of less\"\n        };\n    }\n\n    var imageFunctions = {\n        \"image-size\": function(filePathNode) {\n            imageSize(this, filePathNode);\n            return -1;\n        },\n        \"image-width\": function(filePathNode) {\n            imageSize(this, filePathNode);\n            return -1;\n        },\n        \"image-height\": function(filePathNode) {\n            imageSize(this, filePathNode);\n            return -1;\n        }\n    };\n\n    functionRegistry.addMultiple(imageFunctions);\n};\n\n},{\"./../less/functions/function-registry\":22}],8:[function(require,module,exports){\n//\n// index.js\n// Should expose the additional browser functions on to the less object\n//\nvar addDataAttr = require(\"./utils\").addDataAttr,\n    browser = require(\"./browser\");\n\nmodule.exports = function(window, options) {\n    var document = window.document;\n    var less = require('../less')();\n\n    //module.exports = less;\n    less.options = options;\n    var environment = less.environment,\n        FileManager = require(\"./file-manager\")(options, less.logger),\n        fileManager = new FileManager();\n    environment.addFileManager(fileManager);\n    less.FileManager = FileManager;\n\n    require(\"./log-listener\")(less, options);\n    var errors = require(\"./error-reporting\")(window, less, options);\n    var cache = less.cache = options.cache || require(\"./cache\")(window, options, less.logger);\n    require('./image-size')(less.environment);\n\n    //Setup user functions\n    if (options.functions) {\n        less.functions.functionRegistry.addMultiple(options.functions);\n    }\n\n    var typePattern = /^text\\/(x-)?less$/;\n\n    function postProcessCSS(styles) { // deprecated, use a plugin for postprocesstasks\n        if (options.postProcessor && typeof options.postProcessor === 'function') {\n            styles = options.postProcessor.call(styles, styles) || styles;\n        }\n        return styles;\n    }\n\n    function clone(obj) {\n        var cloned = {};\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                cloned[prop] = obj[prop];\n            }\n        }\n        return cloned;\n    }\n\n    // only really needed for phantom\n    function bind(func, thisArg) {\n        var curryArgs = Array.prototype.slice.call(arguments, 2);\n        return function() {\n            var args = curryArgs.concat(Array.prototype.slice.call(arguments, 0));\n            return func.apply(thisArg, args);\n        };\n    }\n\n    function loadStyles(modifyVars) {\n        var styles = document.getElementsByTagName('style'),\n            style;\n\n        for (var i = 0; i < styles.length; i++) {\n            style = styles[i];\n            if (style.type.match(typePattern)) {\n                var instanceOptions = clone(options);\n                instanceOptions.modifyVars = modifyVars;\n                var lessText = style.innerHTML || '';\n                instanceOptions.filename = document.location.href.replace(/#.*$/, '');\n\n                /*jshint loopfunc:true */\n                // use closure to store current style\n                less.render(lessText, instanceOptions,\n                        bind(function(style, e, result) {\n                            if (e) {\n                                errors.add(e, \"inline\");\n                            } else {\n                                style.type = 'text/css';\n                                if (style.styleSheet) {\n                                    style.styleSheet.cssText = result.css;\n                                } else {\n                                    style.innerHTML = result.css;\n                                }\n                            }\n                        }, null, style));\n            }\n        }\n    }\n\n    function loadStyleSheet(sheet, callback, reload, remaining, modifyVars) {\n\n        var instanceOptions = clone(options);\n        addDataAttr(instanceOptions, sheet);\n        instanceOptions.mime = sheet.type;\n\n        if (modifyVars) {\n            instanceOptions.modifyVars = modifyVars;\n        }\n\n        function loadInitialFileCallback(loadedFile) {\n\n            var data = loadedFile.contents,\n                path = loadedFile.filename,\n                webInfo = loadedFile.webInfo;\n\n            var newFileInfo = {\n                currentDirectory: fileManager.getPath(path),\n                filename: path,\n                rootFilename: path,\n                relativeUrls: instanceOptions.relativeUrls};\n\n            newFileInfo.entryPath = newFileInfo.currentDirectory;\n            newFileInfo.rootpath = instanceOptions.rootpath || newFileInfo.currentDirectory;\n\n            if (webInfo) {\n                webInfo.remaining = remaining;\n\n                var css = cache.getCSS(path, webInfo, instanceOptions.modifyVars);\n                if (!reload && css) {\n                    webInfo.local = true;\n                    callback(null, css, data, sheet, webInfo, path);\n                    return;\n                }\n\n            }\n\n            //TODO add tests around how this behaves when reloading\n            errors.remove(path);\n\n            instanceOptions.rootFileInfo = newFileInfo;\n            less.render(data, instanceOptions, function(e, result) {\n                if (e) {\n                    e.href = path;\n                    callback(e);\n                } else {\n                    result.css = postProcessCSS(result.css);\n                    cache.setCSS(sheet.href, webInfo.lastModified, instanceOptions.modifyVars, result.css);\n                    callback(null, result.css, data, sheet, webInfo, path);\n                }\n            });\n        }\n\n        fileManager.loadFile(sheet.href, null, instanceOptions, environment, function(e, loadedFile) {\n            if (e) {\n                callback(e);\n                return;\n            }\n            loadInitialFileCallback(loadedFile);\n        });\n    }\n\n    function loadStyleSheets(callback, reload, modifyVars) {\n        for (var i = 0; i < less.sheets.length; i++) {\n            loadStyleSheet(less.sheets[i], callback, reload, less.sheets.length - (i + 1), modifyVars);\n        }\n    }\n\n    function initRunningMode() {\n        if (less.env === 'development') {\n            less.watchTimer = setInterval(function () {\n                if (less.watchMode) {\n                    fileManager.clearFileCache();\n                    loadStyleSheets(function (e, css, _, sheet, webInfo) {\n                        if (e) {\n                            errors.add(e, e.href || sheet.href);\n                        } else if (css) {\n                            browser.createCSS(window.document, css, sheet);\n                        }\n                    });\n                }\n            }, options.poll);\n        }\n    }\n\n    //\n    // Watch mode\n    //\n    less.watch   = function () {\n        if (!less.watchMode ) {\n            less.env = 'development';\n            initRunningMode();\n        }\n        this.watchMode = true;\n        return true;\n    };\n\n    less.unwatch = function () {clearInterval(less.watchTimer); this.watchMode = false; return false; };\n\n    //\n    // Synchronously get all <link> tags with the 'rel' attribute set to\n    // \"stylesheet/less\".\n    //\n    less.registerStylesheetsImmediately = function() {\n        var links = document.getElementsByTagName('link');\n        less.sheets = [];\n\n        for (var i = 0; i < links.length; i++) {\n            if (links[i].rel === 'stylesheet/less' || (links[i].rel.match(/stylesheet/) &&\n                (links[i].type.match(typePattern)))) {\n                less.sheets.push(links[i]);\n            }\n        }\n    };\n\n    //\n    // Asynchronously get all <link> tags with the 'rel' attribute set to\n    // \"stylesheet/less\", returning a Promise.\n    //\n    less.registerStylesheets = function() {\n        return new Promise(function(resolve, reject) {\n            less.registerStylesheetsImmediately();\n            resolve();\n        });\n    };\n\n    //\n    // With this function, it's possible to alter variables and re-render\n    // CSS without reloading less-files\n    //\n    less.modifyVars = function(record) {\n        return less.refresh(true, record, false);\n    };\n\n    less.refresh = function (reload, modifyVars, clearFileCache) {\n        if ((reload || clearFileCache) && clearFileCache !== false) {\n            fileManager.clearFileCache();\n        }\n        return new Promise(function (resolve, reject) {\n            var startTime, endTime, totalMilliseconds, remainingSheets;\n            startTime = endTime = new Date();\n\n            // Set counter for remaining unprocessed sheets\n            remainingSheets = less.sheets.length;\n\n            if (remainingSheets === 0) {\n\n                endTime = new Date();\n                totalMilliseconds = endTime - startTime;\n                less.logger.info(\"Less has finished and no sheets were loaded.\");\n                resolve({\n                    startTime: startTime,\n                    endTime: endTime,\n                    totalMilliseconds: totalMilliseconds,\n                    sheets: less.sheets.length\n                });\n\n            } else {\n                // Relies on less.sheets array, callback seems to be guaranteed to be called for every element of the array\n                loadStyleSheets(function (e, css, _, sheet, webInfo) {\n                    if (e) {\n                        errors.add(e, e.href || sheet.href);\n                        reject(e);\n                        return;\n                    }\n                    if (webInfo.local) {\n                        less.logger.info(\"Loading \" + sheet.href + \" from cache.\");\n                    } else {\n                        less.logger.info(\"Rendered \" + sheet.href + \" successfully.\");\n                    }\n                    browser.createCSS(window.document, css, sheet);\n                    less.logger.info(\"CSS for \" + sheet.href + \" generated in \" + (new Date() - endTime) + 'ms');\n\n                    // Count completed sheet\n                    remainingSheets--;\n\n                    // Check if the last remaining sheet was processed and then call the promise\n                    if (remainingSheets === 0) {\n                        totalMilliseconds = new Date() - startTime;\n                        less.logger.info(\"Less has finished. CSS generated in \" + totalMilliseconds + 'ms');\n                        resolve({\n                            startTime: startTime,\n                            endTime: endTime,\n                            totalMilliseconds: totalMilliseconds,\n                            sheets: less.sheets.length\n                        });\n                    }\n                    endTime = new Date();\n                }, reload, modifyVars);\n            }\n\n            loadStyles(modifyVars);\n        });\n    };\n\n    less.refreshStyles = loadStyles;\n    return less;\n};\n\n},{\"../less\":31,\"./browser\":3,\"./cache\":4,\"./error-reporting\":5,\"./file-manager\":6,\"./image-size\":7,\"./log-listener\":9,\"./utils\":10}],9:[function(require,module,exports){\nmodule.exports = function(less, options) {\n\n    var logLevel_debug = 4,\n        logLevel_info = 3,\n        logLevel_warn = 2,\n        logLevel_error = 1;\n\n    // The amount of logging in the javascript console.\n    // 3 - Debug, information and errors\n    // 2 - Information and errors\n    // 1 - Errors\n    // 0 - None\n    // Defaults to 2\n    options.logLevel = typeof options.logLevel !== 'undefined' ? options.logLevel : (options.env === 'development' ?  logLevel_info : logLevel_error);\n\n    if (!options.loggers) {\n        options.loggers = [{\n            debug: function(msg) {\n                if (options.logLevel >= logLevel_debug) {\n                    console.log(msg);\n                }\n            },\n            info: function(msg) {\n                if (options.logLevel >= logLevel_info) {\n                    console.log(msg);\n                }\n            },\n            warn: function(msg) {\n                if (options.logLevel >= logLevel_warn) {\n                    console.warn(msg);\n                }\n            },\n            error: function(msg) {\n                if (options.logLevel >= logLevel_error) {\n                    console.error(msg);\n                }\n            }\n        }];\n    }\n    for (var i = 0; i < options.loggers.length; i++) {\n        less.logger.addListener(options.loggers[i]);\n    }\n};\n\n},{}],10:[function(require,module,exports){\nmodule.exports = {\n    extractId: function(href) {\n        return href.replace(/^[a-z-]+:\\/+?[^\\/]+/, '')  // Remove protocol & domain\n            .replace(/[\\?\\&]livereload=\\w+/, '')        // Remove LiveReload cachebuster\n            .replace(/^\\//, '')                         // Remove root /\n            .replace(/\\.[a-zA-Z]+$/, '')                // Remove simple extension\n            .replace(/[^\\.\\w-]+/g, '-')                 // Replace illegal characters\n            .replace(/\\./g, ':');                       // Replace dots with colons(for valid id)\n    },\n    addDataAttr: function(options, tag) {\n        for (var opt in tag.dataset) {\n            if (tag.dataset.hasOwnProperty(opt)) {\n                if (opt === \"env\" || opt === \"dumpLineNumbers\" || opt === \"rootpath\" || opt === \"errorReporting\") {\n                    options[opt] = tag.dataset[opt];\n                } else {\n                    try {\n                        options[opt] = JSON.parse(tag.dataset[opt]);\n                    }\n                    catch(_) {}\n                }\n            }\n        }\n    }\n};\n\n},{}],11:[function(require,module,exports){\nvar contexts = {};\nmodule.exports = contexts;\n\nvar copyFromOriginal = function copyFromOriginal(original, destination, propertiesToCopy) {\n    if (!original) { return; }\n\n    for (var i = 0; i < propertiesToCopy.length; i++) {\n        if (original.hasOwnProperty(propertiesToCopy[i])) {\n            destination[propertiesToCopy[i]] = original[propertiesToCopy[i]];\n        }\n    }\n};\n\n/*\n parse is used whilst parsing\n */\nvar parseCopyProperties = [\n    // options\n    'paths',            // option - unmodified - paths to search for imports on\n    'relativeUrls',     // option - whether to adjust URL's to be relative\n    'rootpath',         // option - rootpath to append to URL's\n    'strictImports',    // option -\n    'insecure',         // option - whether to allow imports from insecure ssl hosts\n    'dumpLineNumbers',  // option - whether to dump line numbers\n    'compress',         // option - whether to compress\n    'syncImport',       // option - whether to import synchronously\n    'chunkInput',       // option - whether to chunk input. more performant but causes parse issues.\n    'mime',             // browser only - mime type for sheet import\n    'useFileCache',     // browser only - whether to use the per file session cache\n    // context\n    'processImports',   // option & context - whether to process imports. if false then imports will not be imported.\n                        // Used by the import manager to stop multiple import visitors being created.\n    'pluginManager'     // Used as the plugin manager for the session\n];\n\ncontexts.Parse = function(options) {\n    copyFromOriginal(options, this, parseCopyProperties);\n\n    if (typeof this.paths === \"string\") { this.paths = [this.paths]; }\n};\n\nvar evalCopyProperties = [\n    'paths',          // additional include paths\n    'compress',       // whether to compress\n    'ieCompat',       // whether to enforce IE compatibility (IE8 data-uri)\n    'strictMath',     // whether math has to be within parenthesis\n    'strictUnits',    // whether units need to evaluate correctly\n    'sourceMap',      // whether to output a source map\n    'importMultiple', // whether we are currently importing multiple copies\n    'urlArgs',        // whether to add args into url tokens\n    'javascriptEnabled',// option - whether JavaScript is enabled. if undefined, defaults to true\n    'pluginManager',  // Used as the plugin manager for the session\n    'importantScope'  // used to bubble up !important statements\n    ];\n\ncontexts.Eval = function(options, frames) {\n    copyFromOriginal(options, this, evalCopyProperties);\n\n    if (typeof this.paths === \"string\") { this.paths = [this.paths]; }\n\n    this.frames = frames || [];\n    this.importantScope = this.importantScope || [];\n};\n\ncontexts.Eval.prototype.inParenthesis = function () {\n    if (!this.parensStack) {\n        this.parensStack = [];\n    }\n    this.parensStack.push(true);\n};\n\ncontexts.Eval.prototype.outOfParenthesis = function () {\n    this.parensStack.pop();\n};\n\ncontexts.Eval.prototype.isMathOn = function () {\n    return this.strictMath ? (this.parensStack && this.parensStack.length) : true;\n};\n\ncontexts.Eval.prototype.isPathRelative = function (path) {\n    return !/^(?:[a-z-]+:|\\/|#)/i.test(path);\n};\n\ncontexts.Eval.prototype.normalizePath = function( path ) {\n    var\n      segments = path.split(\"/\").reverse(),\n      segment;\n\n    path = [];\n    while (segments.length !== 0 ) {\n        segment = segments.pop();\n        switch( segment ) {\n            case \".\":\n                break;\n            case \"..\":\n                if ((path.length === 0) || (path[path.length - 1] === \"..\")) {\n                    path.push( segment );\n                } else {\n                    path.pop();\n                }\n                break;\n            default:\n                path.push( segment );\n                break;\n        }\n    }\n\n    return path.join(\"/\");\n};\n\n//todo - do the same for the toCSS ?\n\n},{}],12:[function(require,module,exports){\nmodule.exports = {\n    'aliceblue':'#f0f8ff',\n    'antiquewhite':'#faebd7',\n    'aqua':'#00ffff',\n    'aquamarine':'#7fffd4',\n    'azure':'#f0ffff',\n    'beige':'#f5f5dc',\n    'bisque':'#ffe4c4',\n    'black':'#000000',\n    'blanchedalmond':'#ffebcd',\n    'blue':'#0000ff',\n    'blueviolet':'#8a2be2',\n    'brown':'#a52a2a',\n    'burlywood':'#deb887',\n    'cadetblue':'#5f9ea0',\n    'chartreuse':'#7fff00',\n    'chocolate':'#d2691e',\n    'coral':'#ff7f50',\n    'cornflowerblue':'#6495ed',\n    'cornsilk':'#fff8dc',\n    'crimson':'#dc143c',\n    'cyan':'#00ffff',\n    'darkblue':'#00008b',\n    'darkcyan':'#008b8b',\n    'darkgoldenrod':'#b8860b',\n    'darkgray':'#a9a9a9',\n    'darkgrey':'#a9a9a9',\n    'darkgreen':'#006400',\n    'darkkhaki':'#bdb76b',\n    'darkmagenta':'#8b008b',\n    'darkolivegreen':'#556b2f',\n    'darkorange':'#ff8c00',\n    'darkorchid':'#9932cc',\n    'darkred':'#8b0000',\n    'darksalmon':'#e9967a',\n    'darkseagreen':'#8fbc8f',\n    'darkslateblue':'#483d8b',\n    'darkslategray':'#2f4f4f',\n    'darkslategrey':'#2f4f4f',\n    'darkturquoise':'#00ced1',\n    'darkviolet':'#9400d3',\n    'deeppink':'#ff1493',\n    'deepskyblue':'#00bfff',\n    'dimgray':'#696969',\n    'dimgrey':'#696969',\n    'dodgerblue':'#1e90ff',\n    'firebrick':'#b22222',\n    'floralwhite':'#fffaf0',\n    'forestgreen':'#228b22',\n    'fuchsia':'#ff00ff',\n    'gainsboro':'#dcdcdc',\n    'ghostwhite':'#f8f8ff',\n    'gold':'#ffd700',\n    'goldenrod':'#daa520',\n    'gray':'#808080',\n    'grey':'#808080',\n    'green':'#008000',\n    'greenyellow':'#adff2f',\n    'honeydew':'#f0fff0',\n    'hotpink':'#ff69b4',\n    'indianred':'#cd5c5c',\n    'indigo':'#4b0082',\n    'ivory':'#fffff0',\n    'khaki':'#f0e68c',\n    'lavender':'#e6e6fa',\n    'lavenderblush':'#fff0f5',\n    'lawngreen':'#7cfc00',\n    'lemonchiffon':'#fffacd',\n    'lightblue':'#add8e6',\n    'lightcoral':'#f08080',\n    'lightcyan':'#e0ffff',\n    'lightgoldenrodyellow':'#fafad2',\n    'lightgray':'#d3d3d3',\n    'lightgrey':'#d3d3d3',\n    'lightgreen':'#90ee90',\n    'lightpink':'#ffb6c1',\n    'lightsalmon':'#ffa07a',\n    'lightseagreen':'#20b2aa',\n    'lightskyblue':'#87cefa',\n    'lightslategray':'#778899',\n    'lightslategrey':'#778899',\n    'lightsteelblue':'#b0c4de',\n    'lightyellow':'#ffffe0',\n    'lime':'#00ff00',\n    'limegreen':'#32cd32',\n    'linen':'#faf0e6',\n    'magenta':'#ff00ff',\n    'maroon':'#800000',\n    'mediumaquamarine':'#66cdaa',\n    'mediumblue':'#0000cd',\n    'mediumorchid':'#ba55d3',\n    'mediumpurple':'#9370d8',\n    'mediumseagreen':'#3cb371',\n    'mediumslateblue':'#7b68ee',\n    'mediumspringgreen':'#00fa9a',\n    'mediumturquoise':'#48d1cc',\n    'mediumvioletred':'#c71585',\n    'midnightblue':'#191970',\n    'mintcream':'#f5fffa',\n    'mistyrose':'#ffe4e1',\n    'moccasin':'#ffe4b5',\n    'navajowhite':'#ffdead',\n    'navy':'#000080',\n    'oldlace':'#fdf5e6',\n    'olive':'#808000',\n    'olivedrab':'#6b8e23',\n    'orange':'#ffa500',\n    'orangered':'#ff4500',\n    'orchid':'#da70d6',\n    'palegoldenrod':'#eee8aa',\n    'palegreen':'#98fb98',\n    'paleturquoise':'#afeeee',\n    'palevioletred':'#d87093',\n    'papayawhip':'#ffefd5',\n    'peachpuff':'#ffdab9',\n    'peru':'#cd853f',\n    'pink':'#ffc0cb',\n    'plum':'#dda0dd',\n    'powderblue':'#b0e0e6',\n    'purple':'#800080',\n    'rebeccapurple':'#663399',\n    'red':'#ff0000',\n    'rosybrown':'#bc8f8f',\n    'royalblue':'#4169e1',\n    'saddlebrown':'#8b4513',\n    'salmon':'#fa8072',\n    'sandybrown':'#f4a460',\n    'seagreen':'#2e8b57',\n    'seashell':'#fff5ee',\n    'sienna':'#a0522d',\n    'silver':'#c0c0c0',\n    'skyblue':'#87ceeb',\n    'slateblue':'#6a5acd',\n    'slategray':'#708090',\n    'slategrey':'#708090',\n    'snow':'#fffafa',\n    'springgreen':'#00ff7f',\n    'steelblue':'#4682b4',\n    'tan':'#d2b48c',\n    'teal':'#008080',\n    'thistle':'#d8bfd8',\n    'tomato':'#ff6347',\n    'turquoise':'#40e0d0',\n    'violet':'#ee82ee',\n    'wheat':'#f5deb3',\n    'white':'#ffffff',\n    'whitesmoke':'#f5f5f5',\n    'yellow':'#ffff00',\n    'yellowgreen':'#9acd32'\n};\n},{}],13:[function(require,module,exports){\nmodule.exports = {\n    colors: require(\"./colors\"),\n    unitConversions: require(\"./unit-conversions\")\n};\n\n},{\"./colors\":12,\"./unit-conversions\":14}],14:[function(require,module,exports){\nmodule.exports = {\n    length: {\n        'm': 1,\n        'cm': 0.01,\n        'mm': 0.001,\n        'in': 0.0254,\n        'px': 0.0254 / 96,\n        'pt': 0.0254 / 72,\n        'pc': 0.0254 / 72 * 12\n    },\n    duration: {\n        's': 1,\n        'ms': 0.001\n    },\n    angle: {\n        'rad': 1 / (2 * Math.PI),\n        'deg': 1 / 360,\n        'grad': 1 / 400,\n        'turn': 1\n    }\n};\n},{}],15:[function(require,module,exports){\nvar abstractFileManager = function() {\n};\n\nabstractFileManager.prototype.getPath = function (filename) {\n    var j = filename.lastIndexOf('?');\n    if (j > 0) {\n        filename = filename.slice(0, j);\n    }\n    j = filename.lastIndexOf('/');\n    if (j < 0) {\n        j = filename.lastIndexOf('\\\\');\n    }\n    if (j < 0) {\n        return \"\";\n    }\n    return filename.slice(0, j + 1);\n};\n\nabstractFileManager.prototype.tryAppendExtension = function(path, ext) {\n    return /(\\.[a-z]*$)|([\\?;].*)$/.test(path) ? path : path + ext;\n};\n\nabstractFileManager.prototype.tryAppendLessExtension = function(path) {\n    return this.tryAppendExtension(path, '.less');\n};\n\nabstractFileManager.prototype.supportsSync = function() {\n    return false;\n};\n\nabstractFileManager.prototype.alwaysMakePathsAbsolute = function() {\n    return false;\n};\n\nabstractFileManager.prototype.isPathAbsolute = function(filename) {\n    return (/^(?:[a-z-]+:|\\/|\\\\|#)/i).test(filename);\n};\n\nabstractFileManager.prototype.join = function(basePath, laterPath) {\n    if (!basePath) {\n        return laterPath;\n    }\n    return basePath + laterPath;\n};\nabstractFileManager.prototype.pathDiff = function pathDiff(url, baseUrl) {\n    // diff between two paths to create a relative path\n\n    var urlParts = this.extractUrlParts(url),\n        baseUrlParts = this.extractUrlParts(baseUrl),\n        i, max, urlDirectories, baseUrlDirectories, diff = \"\";\n    if (urlParts.hostPart !== baseUrlParts.hostPart) {\n        return \"\";\n    }\n    max = Math.max(baseUrlParts.directories.length, urlParts.directories.length);\n    for (i = 0; i < max; i++) {\n        if (baseUrlParts.directories[i] !== urlParts.directories[i]) { break; }\n    }\n    baseUrlDirectories = baseUrlParts.directories.slice(i);\n    urlDirectories = urlParts.directories.slice(i);\n    for (i = 0; i < baseUrlDirectories.length - 1; i++) {\n        diff += \"../\";\n    }\n    for (i = 0; i < urlDirectories.length - 1; i++) {\n        diff += urlDirectories[i] + \"/\";\n    }\n    return diff;\n};\n// helper function, not part of API\nabstractFileManager.prototype.extractUrlParts = function extractUrlParts(url, baseUrl) {\n    // urlParts[1] = protocol://hostname/ OR /\n    // urlParts[2] = / if path relative to host base\n    // urlParts[3] = directories\n    // urlParts[4] = filename\n    // urlParts[5] = parameters\n\n    var urlPartsRegex = /^((?:[a-z-]+:)?\\/{2}(?:[^\\/\\?#]*\\/)|([\\/\\\\]))?((?:[^\\/\\\\\\?#]*[\\/\\\\])*)([^\\/\\\\\\?#]*)([#\\?].*)?$/i,\n        urlParts = url.match(urlPartsRegex),\n        returner = {}, directories = [], i, baseUrlParts;\n\n    if (!urlParts) {\n        throw new Error(\"Could not parse sheet href - '\" + url + \"'\");\n    }\n\n    // Stylesheets in IE don't always return the full path\n    if (baseUrl && (!urlParts[1] || urlParts[2])) {\n        baseUrlParts = baseUrl.match(urlPartsRegex);\n        if (!baseUrlParts) {\n            throw new Error(\"Could not parse page url - '\" + baseUrl + \"'\");\n        }\n        urlParts[1] = urlParts[1] || baseUrlParts[1] || \"\";\n        if (!urlParts[2]) {\n            urlParts[3] = baseUrlParts[3] + urlParts[3];\n        }\n    }\n\n    if (urlParts[3]) {\n        directories = urlParts[3].replace(/\\\\/g, \"/\").split(\"/\");\n\n        // extract out . before .. so .. doesn't absorb a non-directory\n        for (i = 0; i < directories.length; i++) {\n            if (directories[i] === \".\") {\n                directories.splice(i, 1);\n                i -= 1;\n            }\n        }\n\n        for (i = 0; i < directories.length; i++) {\n            if (directories[i] === \"..\" && i > 0) {\n                directories.splice(i - 1, 2);\n                i -= 2;\n            }\n        }\n    }\n\n    returner.hostPart = urlParts[1];\n    returner.directories = directories;\n    returner.path = (urlParts[1] || \"\") + directories.join(\"/\");\n    returner.fileUrl = returner.path + (urlParts[4] || \"\");\n    returner.url = returner.fileUrl + (urlParts[5] || \"\");\n    return returner;\n};\n\nmodule.exports = abstractFileManager;\n\n},{}],16:[function(require,module,exports){\nvar logger = require(\"../logger\");\nvar environment = function(externalEnvironment, fileManagers) {\n    this.fileManagers = fileManagers || [];\n    externalEnvironment = externalEnvironment || {};\n\n    var optionalFunctions = [\"encodeBase64\", \"mimeLookup\", \"charsetLookup\", \"getSourceMapGenerator\"],\n        requiredFunctions = [],\n        functions = requiredFunctions.concat(optionalFunctions);\n\n    for (var i = 0; i < functions.length; i++) {\n        var propName = functions[i],\n            environmentFunc = externalEnvironment[propName];\n        if (environmentFunc) {\n            this[propName] = environmentFunc.bind(externalEnvironment);\n        } else if (i < requiredFunctions.length) {\n            this.warn(\"missing required function in environment - \" + propName);\n        }\n    }\n};\n\nenvironment.prototype.getFileManager = function (filename, currentDirectory, options, environment, isSync) {\n\n    if (!filename) {\n        logger.warn(\"getFileManager called with no filename.. Please report this issue. continuing.\");\n    }\n    if (currentDirectory == null) {\n        logger.warn(\"getFileManager called with null directory.. Please report this issue. continuing.\");\n    }\n\n    var fileManagers = this.fileManagers;\n    if (options.pluginManager) {\n        fileManagers = [].concat(fileManagers).concat(options.pluginManager.getFileManagers());\n    }\n    for (var i = fileManagers.length - 1; i >= 0 ; i--) {\n        var fileManager = fileManagers[i];\n        if (fileManager[isSync ? \"supportsSync\" : \"supports\"](filename, currentDirectory, options, environment)) {\n            return fileManager;\n        }\n    }\n    return null;\n};\n\nenvironment.prototype.addFileManager = function (fileManager) {\n    this.fileManagers.push(fileManager);\n};\n\nenvironment.prototype.clearFileManagers = function () {\n    this.fileManagers = [];\n};\n\nmodule.exports = environment;\n\n},{\"../logger\":33}],17:[function(require,module,exports){\nvar Color = require(\"../tree/color\"),\n    functionRegistry = require(\"./function-registry\");\n\n// Color Blending\n// ref: http://www.w3.org/TR/compositing-1\n\nfunction colorBlend(mode, color1, color2) {\n    var ab = color1.alpha, cb, // backdrop\n        as = color2.alpha, cs, // source\n        ar, cr, r = [];        // result\n\n    ar = as + ab * (1 - as);\n    for (var i = 0; i < 3; i++) {\n        cb = color1.rgb[i] / 255;\n        cs = color2.rgb[i] / 255;\n        cr = mode(cb, cs);\n        if (ar) {\n            cr = (as * cs + ab * (cb -\n                  as * (cb + cs - cr))) / ar;\n        }\n        r[i] = cr * 255;\n    }\n\n    return new Color(r, ar);\n}\n\nvar colorBlendModeFunctions = {\n    multiply: function(cb, cs) {\n        return cb * cs;\n    },\n    screen: function(cb, cs) {\n        return cb + cs - cb * cs;\n    },\n    overlay: function(cb, cs) {\n        cb *= 2;\n        return (cb <= 1) ?\n            colorBlendModeFunctions.multiply(cb, cs) :\n            colorBlendModeFunctions.screen(cb - 1, cs);\n    },\n    softlight: function(cb, cs) {\n        var d = 1, e = cb;\n        if (cs > 0.5) {\n            e = 1;\n            d = (cb > 0.25) ? Math.sqrt(cb)\n                : ((16 * cb - 12) * cb + 4) * cb;\n        }\n        return cb - (1 - 2 * cs) * e * (d - cb);\n    },\n    hardlight: function(cb, cs) {\n        return colorBlendModeFunctions.overlay(cs, cb);\n    },\n    difference: function(cb, cs) {\n        return Math.abs(cb - cs);\n    },\n    exclusion: function(cb, cs) {\n        return cb + cs - 2 * cb * cs;\n    },\n\n    // non-w3c functions:\n    average: function(cb, cs) {\n        return (cb + cs) / 2;\n    },\n    negation: function(cb, cs) {\n        return 1 - Math.abs(cb + cs - 1);\n    }\n};\n\nfor (var f in colorBlendModeFunctions) {\n    if (colorBlendModeFunctions.hasOwnProperty(f)) {\n        colorBlend[f] = colorBlend.bind(null, colorBlendModeFunctions[f]);\n    }\n}\n\nfunctionRegistry.addMultiple(colorBlend);\n\n},{\"../tree/color\":50,\"./function-registry\":22}],18:[function(require,module,exports){\nvar Dimension = require(\"../tree/dimension\"),\n    Color = require(\"../tree/color\"),\n    Quoted = require(\"../tree/quoted\"),\n    Anonymous = require(\"../tree/anonymous\"),\n    functionRegistry = require(\"./function-registry\"),\n    colorFunctions;\n\nfunction clamp(val) {\n    return Math.min(1, Math.max(0, val));\n}\nfunction hsla(color) {\n    return colorFunctions.hsla(color.h, color.s, color.l, color.a);\n}\nfunction number(n) {\n    if (n instanceof Dimension) {\n        return parseFloat(n.unit.is('%') ? n.value / 100 : n.value);\n    } else if (typeof n === 'number') {\n        return n;\n    } else {\n        throw {\n            type: \"Argument\",\n            message: \"color functions take numbers as parameters\"\n        };\n    }\n}\nfunction scaled(n, size) {\n    if (n instanceof Dimension && n.unit.is('%')) {\n        return parseFloat(n.value * size / 100);\n    } else {\n        return number(n);\n    }\n}\ncolorFunctions = {\n    rgb: function (r, g, b) {\n        return colorFunctions.rgba(r, g, b, 1.0);\n    },\n    rgba: function (r, g, b, a) {\n        var rgb = [r, g, b].map(function (c) { return scaled(c, 255); });\n        a = number(a);\n        return new Color(rgb, a);\n    },\n    hsl: function (h, s, l) {\n        return colorFunctions.hsla(h, s, l, 1.0);\n    },\n    hsla: function (h, s, l, a) {\n\n        var m1, m2;\n\n        function hue(h) {\n            h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);\n            if (h * 6 < 1) {\n                return m1 + (m2 - m1) * h * 6;\n            }\n            else if (h * 2 < 1) {\n                return m2;\n            }\n            else if (h * 3 < 2) {\n                return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n            }\n            else {\n                return m1;\n            }\n        }\n\n        h = (number(h) % 360) / 360;\n        s = clamp(number(s)); l = clamp(number(l)); a = clamp(number(a));\n\n        m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        m1 = l * 2 - m2;\n\n        return colorFunctions.rgba(hue(h + 1 / 3) * 255,\n            hue(h)       * 255,\n            hue(h - 1 / 3) * 255,\n            a);\n    },\n\n    hsv: function(h, s, v) {\n        return colorFunctions.hsva(h, s, v, 1.0);\n    },\n\n    hsva: function(h, s, v, a) {\n        h = ((number(h) % 360) / 360) * 360;\n        s = number(s); v = number(v); a = number(a);\n\n        var i, f;\n        i = Math.floor((h / 60) % 6);\n        f = (h / 60) - i;\n\n        var vs = [v,\n            v * (1 - s),\n            v * (1 - f * s),\n            v * (1 - (1 - f) * s)];\n        var perm = [[0, 3, 1],\n            [2, 0, 1],\n            [1, 0, 3],\n            [1, 2, 0],\n            [3, 1, 0],\n            [0, 1, 2]];\n\n        return colorFunctions.rgba(vs[perm[i][0]] * 255,\n            vs[perm[i][1]] * 255,\n            vs[perm[i][2]] * 255,\n            a);\n    },\n\n    hue: function (color) {\n        return new Dimension(color.toHSL().h);\n    },\n    saturation: function (color) {\n        return new Dimension(color.toHSL().s * 100, '%');\n    },\n    lightness: function (color) {\n        return new Dimension(color.toHSL().l * 100, '%');\n    },\n    hsvhue: function(color) {\n        return new Dimension(color.toHSV().h);\n    },\n    hsvsaturation: function (color) {\n        return new Dimension(color.toHSV().s * 100, '%');\n    },\n    hsvvalue: function (color) {\n        return new Dimension(color.toHSV().v * 100, '%');\n    },\n    red: function (color) {\n        return new Dimension(color.rgb[0]);\n    },\n    green: function (color) {\n        return new Dimension(color.rgb[1]);\n    },\n    blue: function (color) {\n        return new Dimension(color.rgb[2]);\n    },\n    alpha: function (color) {\n        return new Dimension(color.toHSL().a);\n    },\n    luma: function (color) {\n        return new Dimension(color.luma() * color.alpha * 100, '%');\n    },\n    luminance: function (color) {\n        var luminance =\n            (0.2126 * color.rgb[0] / 255) +\n                (0.7152 * color.rgb[1] / 255) +\n                (0.0722 * color.rgb[2] / 255);\n\n        return new Dimension(luminance * color.alpha * 100, '%');\n    },\n    saturate: function (color, amount, method) {\n        // filter: saturate(3.2);\n        // should be kept as is, so check for color\n        if (!color.rgb) {\n            return null;\n        }\n        var hsl = color.toHSL();\n\n        if (typeof method !== \"undefined\" && method.value === \"relative\") {\n            hsl.s +=  hsl.s * amount.value / 100;\n        }\n        else {\n            hsl.s += amount.value / 100;\n        }\n        hsl.s = clamp(hsl.s);\n        return hsla(hsl);\n    },\n    desaturate: function (color, amount, method) {\n        var hsl = color.toHSL();\n\n        if (typeof method !== \"undefined\" && method.value === \"relative\") {\n            hsl.s -=  hsl.s * amount.value / 100;\n        }\n        else {\n            hsl.s -= amount.value / 100;\n        }\n        hsl.s = clamp(hsl.s);\n        return hsla(hsl);\n    },\n    lighten: function (color, amount, method) {\n        var hsl = color.toHSL();\n\n        if (typeof method !== \"undefined\" && method.value === \"relative\") {\n            hsl.l +=  hsl.l * amount.value / 100;\n        }\n        else {\n            hsl.l += amount.value / 100;\n        }\n        hsl.l = clamp(hsl.l);\n        return hsla(hsl);\n    },\n    darken: function (color, amount, method) {\n        var hsl = color.toHSL();\n\n        if (typeof method !== \"undefined\" && method.value === \"relative\") {\n            hsl.l -=  hsl.l * amount.value / 100;\n        }\n        else {\n            hsl.l -= amount.value / 100;\n        }\n        hsl.l = clamp(hsl.l);\n        return hsla(hsl);\n    },\n    fadein: function (color, amount, method) {\n        var hsl = color.toHSL();\n\n        if (typeof method !== \"undefined\" && method.value === \"relative\") {\n            hsl.a +=  hsl.a * amount.value / 100;\n        }\n        else {\n            hsl.a += amount.value / 100;\n        }\n        hsl.a = clamp(hsl.a);\n        return hsla(hsl);\n    },\n    fadeout: function (color, amount, method) {\n        var hsl = color.toHSL();\n\n        if (typeof method !== \"undefined\" && method.value === \"relative\") {\n            hsl.a -=  hsl.a * amount.value / 100;\n        }\n        else {\n            hsl.a -= amount.value / 100;\n        }\n        hsl.a = clamp(hsl.a);\n        return hsla(hsl);\n    },\n    fade: function (color, amount) {\n        var hsl = color.toHSL();\n\n        hsl.a = amount.value / 100;\n        hsl.a = clamp(hsl.a);\n        return hsla(hsl);\n    },\n    spin: function (color, amount) {\n        var hsl = color.toHSL();\n        var hue = (hsl.h + amount.value) % 360;\n\n        hsl.h = hue < 0 ? 360 + hue : hue;\n\n        return hsla(hsl);\n    },\n    //\n    // Copyright (c) 2006-2009 Hampton Catlin, Natalie Weizenbaum, and Chris Eppstein\n    // http://sass-lang.com\n    //\n    mix: function (color1, color2, weight) {\n        if (!color1.toHSL || !color2.toHSL) {\n            console.log(color2.type);\n            console.dir(color2);\n        }\n        if (!weight) {\n            weight = new Dimension(50);\n        }\n        var p = weight.value / 100.0;\n        var w = p * 2 - 1;\n        var a = color1.toHSL().a - color2.toHSL().a;\n\n        var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n        var w2 = 1 - w1;\n\n        var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,\n            color1.rgb[1] * w1 + color2.rgb[1] * w2,\n            color1.rgb[2] * w1 + color2.rgb[2] * w2];\n\n        var alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n        return new Color(rgb, alpha);\n    },\n    greyscale: function (color) {\n        return colorFunctions.desaturate(color, new Dimension(100));\n    },\n    contrast: function (color, dark, light, threshold) {\n        // filter: contrast(3.2);\n        // should be kept as is, so check for color\n        if (!color.rgb) {\n            return null;\n        }\n        if (typeof light === 'undefined') {\n            light = colorFunctions.rgba(255, 255, 255, 1.0);\n        }\n        if (typeof dark === 'undefined') {\n            dark = colorFunctions.rgba(0, 0, 0, 1.0);\n        }\n        //Figure out which is actually light and dark!\n        if (dark.luma() > light.luma()) {\n            var t = light;\n            light = dark;\n            dark = t;\n        }\n        if (typeof threshold === 'undefined') {\n            threshold = 0.43;\n        } else {\n            threshold = number(threshold);\n        }\n        if (color.luma() < threshold) {\n            return light;\n        } else {\n            return dark;\n        }\n    },\n    argb: function (color) {\n        return new Anonymous(color.toARGB());\n    },\n    color: function(c) {\n        if ((c instanceof Quoted) &&\n            (/^#([a-f0-9]{6}|[a-f0-9]{3})$/i.test(c.value))) {\n            return new Color(c.value.slice(1));\n        }\n        if ((c instanceof Color) || (c = Color.fromKeyword(c.value))) {\n            c.value = undefined;\n            return c;\n        }\n        throw {\n            type:    \"Argument\",\n            message: \"argument must be a color keyword or 3/6 digit hex e.g. #FFF\"\n        };\n    },\n    tint: function(color, amount) {\n        return colorFunctions.mix(colorFunctions.rgb(255, 255, 255), color, amount);\n    },\n    shade: function(color, amount) {\n        return colorFunctions.mix(colorFunctions.rgb(0, 0, 0), color, amount);\n    }\n};\nfunctionRegistry.addMultiple(colorFunctions);\n\n},{\"../tree/anonymous\":46,\"../tree/color\":50,\"../tree/dimension\":56,\"../tree/quoted\":73,\"./function-registry\":22}],19:[function(require,module,exports){\nmodule.exports = function(environment) {\n    var Quoted = require(\"../tree/quoted\"),\n        URL = require(\"../tree/url\"),\n        functionRegistry = require(\"./function-registry\"),\n        fallback = function(functionThis, node) {\n            return new URL(node, functionThis.index, functionThis.currentFileInfo).eval(functionThis.context);\n        },\n        logger = require('../logger');\n\n    functionRegistry.add(\"data-uri\", function(mimetypeNode, filePathNode) {\n\n        if (!filePathNode) {\n            filePathNode = mimetypeNode;\n            mimetypeNode = null;\n        }\n\n        var mimetype = mimetypeNode && mimetypeNode.value;\n        var filePath = filePathNode.value;\n        var currentFileInfo = this.currentFileInfo;\n        var currentDirectory = currentFileInfo.relativeUrls ?\n            currentFileInfo.currentDirectory : currentFileInfo.entryPath;\n\n        var fragmentStart = filePath.indexOf('#');\n        var fragment = '';\n        if (fragmentStart !== -1) {\n            fragment = filePath.slice(fragmentStart);\n            filePath = filePath.slice(0, fragmentStart);\n        }\n\n        var fileManager = environment.getFileManager(filePath, currentDirectory, this.context, environment, true);\n\n        if (!fileManager) {\n            return fallback(this, filePathNode);\n        }\n\n        var useBase64 = false;\n\n        // detect the mimetype if not given\n        if (!mimetypeNode) {\n\n            mimetype = environment.mimeLookup(filePath);\n\n            if (mimetype === \"image/svg+xml\") {\n                useBase64 = false;\n            } else {\n                // use base 64 unless it's an ASCII or UTF-8 format\n                var charset = environment.charsetLookup(mimetype);\n                useBase64 = ['US-ASCII', 'UTF-8'].indexOf(charset) < 0;\n            }\n            if (useBase64) { mimetype += ';base64'; }\n        }\n        else {\n            useBase64 = /;base64$/.test(mimetype);\n        }\n\n        var fileSync = fileManager.loadFileSync(filePath, currentDirectory, this.context, environment);\n        if (!fileSync.contents) {\n            logger.warn(\"Skipped data-uri embedding of \" + filePath + \" because file not found\");\n            return fallback(this, filePathNode || mimetypeNode);\n        }\n        var buf = fileSync.contents;\n        if (useBase64 && !environment.encodeBase64) {\n            return fallback(this, filePathNode);\n        }\n\n        buf = useBase64 ? environment.encodeBase64(buf) : encodeURIComponent(buf);\n\n        var uri = \"data:\" + mimetype + ',' + buf + fragment;\n\n        // IE8 cannot handle a data-uri larger than 32,768 characters. If this is exceeded\n        // and the --ieCompat flag is enabled, return a normal url() instead.\n        var DATA_URI_MAX = 32768;\n        if (uri.length >= DATA_URI_MAX) {\n\n            if (this.context.ieCompat !== false) {\n                logger.warn(\"Skipped data-uri embedding of \" + filePath + \" because its size (\" + uri.length +\n                    \" characters) exceeds IE8-safe \" + DATA_URI_MAX + \" characters!\");\n\n                return fallback(this, filePathNode || mimetypeNode);\n            }\n        }\n\n        return new URL(new Quoted('\"' + uri + '\"', uri, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);\n    });\n};\n\n},{\"../logger\":33,\"../tree/quoted\":73,\"../tree/url\":80,\"./function-registry\":22}],20:[function(require,module,exports){\nvar Keyword = require(\"../tree/keyword\"),\n    functionRegistry = require(\"./function-registry\");\n\nvar defaultFunc = {\n    eval: function () {\n        var v = this.value_, e = this.error_;\n        if (e) {\n            throw e;\n        }\n        if (v != null) {\n            return v ? Keyword.True : Keyword.False;\n        }\n    },\n    value: function (v) {\n        this.value_ = v;\n    },\n    error: function (e) {\n        this.error_ = e;\n    },\n    reset: function () {\n        this.value_ = this.error_ = null;\n    }\n};\n\nfunctionRegistry.add(\"default\", defaultFunc.eval.bind(defaultFunc));\n\nmodule.exports = defaultFunc;\n\n},{\"../tree/keyword\":65,\"./function-registry\":22}],21:[function(require,module,exports){\nvar Expression = require(\"../tree/expression\");\n\nvar functionCaller = function(name, context, index, currentFileInfo) {\n    this.name = name.toLowerCase();\n    this.index = index;\n    this.context = context;\n    this.currentFileInfo = currentFileInfo;\n\n    this.func = context.frames[0].functionRegistry.get(this.name);\n};\nfunctionCaller.prototype.isValid = function() {\n    return Boolean(this.func);\n};\nfunctionCaller.prototype.call = function(args) {\n\n    // This code is terrible and should be replaced as per this issue...\n    // https://github.com/less/less.js/issues/2477\n    if (Array.isArray(args)) {\n        args = args.filter(function (item) {\n            if (item.type === \"Comment\") {\n                return false;\n            }\n            return true;\n        })\n        .map(function(item) {\n            if (item.type === \"Expression\") {\n                var subNodes = item.value.filter(function (item) {\n                    if (item.type === \"Comment\") {\n                        return false;\n                    }\n                    return true;\n                });\n                if (subNodes.length === 1) {\n                    return subNodes[0];\n                } else {\n                    return new Expression(subNodes);\n                }\n            }\n            return item;\n        });\n    }\n\n    return this.func.apply(this, args);\n};\n\nmodule.exports = functionCaller;\n\n},{\"../tree/expression\":59}],22:[function(require,module,exports){\nfunction makeRegistry( base ) {\n    return {\n        _data: {},\n        add: function(name, func) {\n            // precautionary case conversion, as later querying of\n            // the registry by function-caller uses lower case as well.\n            name = name.toLowerCase();\n\n            if (this._data.hasOwnProperty(name)) {\n                //TODO warn\n            }\n            this._data[name] = func;\n        },\n        addMultiple: function(functions) {\n            Object.keys(functions).forEach(\n                function(name) {\n                    this.add(name, functions[name]);\n                }.bind(this));\n        },\n        get: function(name) {\n            return this._data[name] || ( base && base.get( name ));\n        },\n        inherit : function() {\n            return makeRegistry( this );\n        }\n    };\n}\n\nmodule.exports = makeRegistry( null );\n},{}],23:[function(require,module,exports){\nmodule.exports = function(environment) {\n    var functions = {\n        functionRegistry: require(\"./function-registry\"),\n        functionCaller: require(\"./function-caller\")\n    };\n\n    //register functions\n    require(\"./default\");\n    require(\"./color\");\n    require(\"./color-blending\");\n    require(\"./data-uri\")(environment);\n    require(\"./math\");\n    require(\"./number\");\n    require(\"./string\");\n    require(\"./svg\")(environment);\n    require(\"./types\");\n\n    return functions;\n};\n\n},{\"./color\":18,\"./color-blending\":17,\"./data-uri\":19,\"./default\":20,\"./function-caller\":21,\"./function-registry\":22,\"./math\":25,\"./number\":26,\"./string\":27,\"./svg\":28,\"./types\":29}],24:[function(require,module,exports){\nvar Dimension = require(\"../tree/dimension\");\n\nvar MathHelper = function() {\n};\nMathHelper._math = function (fn, unit, n) {\n    if (!(n instanceof Dimension)) {\n        throw { type: \"Argument\", message: \"argument must be a number\" };\n    }\n    if (unit == null) {\n        unit = n.unit;\n    } else {\n        n = n.unify();\n    }\n    return new Dimension(fn(parseFloat(n.value)), unit);\n};\nmodule.exports = MathHelper;\n},{\"../tree/dimension\":56}],25:[function(require,module,exports){\nvar functionRegistry = require(\"./function-registry\"),\n    mathHelper = require(\"./math-helper.js\");\n\nvar mathFunctions = {\n    // name,  unit\n    ceil:  null,\n    floor: null,\n    sqrt:  null,\n    abs:   null,\n    tan:   \"\",\n    sin:   \"\",\n    cos:   \"\",\n    atan:  \"rad\",\n    asin:  \"rad\",\n    acos:  \"rad\"\n};\n\nfor (var f in mathFunctions) {\n    if (mathFunctions.hasOwnProperty(f)) {\n        mathFunctions[f] = mathHelper._math.bind(null, Math[f], mathFunctions[f]);\n    }\n}\n\nmathFunctions.round = function (n, f) {\n    var fraction = typeof f === \"undefined\" ? 0 : f.value;\n    return mathHelper._math(function(num) { return num.toFixed(fraction); }, null, n);\n};\n\nfunctionRegistry.addMultiple(mathFunctions);\n\n},{\"./function-registry\":22,\"./math-helper.js\":24}],26:[function(require,module,exports){\nvar Dimension = require(\"../tree/dimension\"),\n    Anonymous = require(\"../tree/anonymous\"),\n    functionRegistry = require(\"./function-registry\"),\n    mathHelper = require(\"./math-helper.js\");\n\nvar minMax = function (isMin, args) {\n    args = Array.prototype.slice.call(args);\n    switch(args.length) {\n        case 0: throw { type: \"Argument\", message: \"one or more arguments required\" };\n    }\n    var i, j, current, currentUnified, referenceUnified, unit, unitStatic, unitClone,\n        order  = [], // elems only contains original argument values.\n        values = {}; // key is the unit.toString() for unified Dimension values,\n    // value is the index into the order array.\n    for (i = 0; i < args.length; i++) {\n        current = args[i];\n        if (!(current instanceof Dimension)) {\n            if (Array.isArray(args[i].value)) {\n                Array.prototype.push.apply(args, Array.prototype.slice.call(args[i].value));\n            }\n            continue;\n        }\n        currentUnified = current.unit.toString() === \"\" && unitClone !== undefined ? new Dimension(current.value, unitClone).unify() : current.unify();\n        unit = currentUnified.unit.toString() === \"\" && unitStatic !== undefined ? unitStatic : currentUnified.unit.toString();\n        unitStatic = unit !== \"\" && unitStatic === undefined || unit !== \"\" && order[0].unify().unit.toString() === \"\" ? unit : unitStatic;\n        unitClone = unit !== \"\" && unitClone === undefined ? current.unit.toString() : unitClone;\n        j = values[\"\"] !== undefined && unit !== \"\" && unit === unitStatic ? values[\"\"] : values[unit];\n        if (j === undefined) {\n            if (unitStatic !== undefined && unit !== unitStatic) {\n                throw{ type: \"Argument\", message: \"incompatible types\" };\n            }\n            values[unit] = order.length;\n            order.push(current);\n            continue;\n        }\n        referenceUnified = order[j].unit.toString() === \"\" && unitClone !== undefined ? new Dimension(order[j].value, unitClone).unify() : order[j].unify();\n        if ( isMin && currentUnified.value < referenceUnified.value ||\n            !isMin && currentUnified.value > referenceUnified.value) {\n            order[j] = current;\n        }\n    }\n    if (order.length == 1) {\n        return order[0];\n    }\n    args = order.map(function (a) { return a.toCSS(this.context); }).join(this.context.compress ? \",\" : \", \");\n    return new Anonymous((isMin ? \"min\" : \"max\") + \"(\" + args + \")\");\n};\nfunctionRegistry.addMultiple({\n    min: function () {\n        return minMax(true, arguments);\n    },\n    max: function () {\n        return minMax(false, arguments);\n    },\n    convert: function (val, unit) {\n        return val.convertTo(unit.value);\n    },\n    pi: function () {\n        return new Dimension(Math.PI);\n    },\n    mod: function(a, b) {\n        return new Dimension(a.value % b.value, a.unit);\n    },\n    pow: function(x, y) {\n        if (typeof x === \"number\" && typeof y === \"number\") {\n            x = new Dimension(x);\n            y = new Dimension(y);\n        } else if (!(x instanceof Dimension) || !(y instanceof Dimension)) {\n            throw { type: \"Argument\", message: \"arguments must be numbers\" };\n        }\n\n        return new Dimension(Math.pow(x.value, y.value), x.unit);\n    },\n    percentage: function (n) {\n        var result = mathHelper._math(function(num) {\n            return num * 100;\n        }, '%', n);\n\n        return result;\n    }\n});\n\n},{\"../tree/anonymous\":46,\"../tree/dimension\":56,\"./function-registry\":22,\"./math-helper.js\":24}],27:[function(require,module,exports){\nvar Quoted = require(\"../tree/quoted\"),\n    Anonymous = require(\"../tree/anonymous\"),\n    JavaScript = require(\"../tree/javascript\"),\n    functionRegistry = require(\"./function-registry\");\n\nfunctionRegistry.addMultiple({\n    e: function (str) {\n        return new Anonymous(str instanceof JavaScript ? str.evaluated : str.value);\n    },\n    escape: function (str) {\n        return new Anonymous(\n            encodeURI(str.value).replace(/=/g, \"%3D\").replace(/:/g, \"%3A\").replace(/#/g, \"%23\").replace(/;/g, \"%3B\")\n                .replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\"));\n    },\n    replace: function (string, pattern, replacement, flags) {\n        var result = string.value;\n        replacement = (replacement.type === \"Quoted\") ?\n            replacement.value : replacement.toCSS();\n        result = result.replace(new RegExp(pattern.value, flags ? flags.value : ''), replacement);\n        return new Quoted(string.quote || '', result, string.escaped);\n    },\n    '%': function (string /* arg, arg, ...*/) {\n        var args = Array.prototype.slice.call(arguments, 1),\n            result = string.value;\n\n        for (var i = 0; i < args.length; i++) {\n            /*jshint loopfunc:true */\n            result = result.replace(/%[sda]/i, function(token) {\n                var value = ((args[i].type === \"Quoted\") &&\n                    token.match(/s/i)) ? args[i].value : args[i].toCSS();\n                return token.match(/[A-Z]$/) ? encodeURIComponent(value) : value;\n            });\n        }\n        result = result.replace(/%%/g, '%');\n        return new Quoted(string.quote || '', result, string.escaped);\n    }\n});\n\n},{\"../tree/anonymous\":46,\"../tree/javascript\":63,\"../tree/quoted\":73,\"./function-registry\":22}],28:[function(require,module,exports){\nmodule.exports = function(environment) {\n    var Dimension = require(\"../tree/dimension\"),\n        Color = require(\"../tree/color\"),\n        Expression = require(\"../tree/expression\"),\n        Quoted = require(\"../tree/quoted\"),\n        URL = require(\"../tree/url\"),\n        functionRegistry = require(\"./function-registry\");\n\n    functionRegistry.add(\"svg-gradient\", function(direction) {\n\n        var stops,\n            gradientDirectionSvg,\n            gradientType = \"linear\",\n            rectangleDimension = 'x=\"0\" y=\"0\" width=\"1\" height=\"1\"',\n            renderEnv = {compress: false},\n            returner,\n            directionValue = direction.toCSS(renderEnv),\n\t\t\ti, color, position, positionValue, alpha;\n\n        function throwArgumentDescriptor() {\n            throw { type: \"Argument\",\n\t\t\t\t\tmessage: \"svg-gradient expects direction, start_color [start_position], [color position,]...,\" +\n\t\t\t\t\t\t\t\" end_color [end_position] or direction, color list\" };\n        }\n\n        if (arguments.length == 2) {\n            if (arguments[1].value.length < 2) {\n                throwArgumentDescriptor();\n            }\n            stops = arguments[1].value;\n        } else if (arguments.length < 3) {\n            throwArgumentDescriptor();\n        } else {\n            stops = Array.prototype.slice.call(arguments, 1);\n        }\n\n        switch (directionValue) {\n            case \"to bottom\":\n                gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\"';\n                break;\n            case \"to right\":\n                gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\"';\n                break;\n            case \"to bottom right\":\n                gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"100%\"';\n                break;\n            case \"to top right\":\n                gradientDirectionSvg = 'x1=\"0%\" y1=\"100%\" x2=\"100%\" y2=\"0%\"';\n                break;\n            case \"ellipse\":\n            case \"ellipse at center\":\n                gradientType = \"radial\";\n                gradientDirectionSvg = 'cx=\"50%\" cy=\"50%\" r=\"75%\"';\n                rectangleDimension = 'x=\"-50\" y=\"-50\" width=\"101\" height=\"101\"';\n                break;\n            default:\n                throw { type: \"Argument\", message: \"svg-gradient direction must be 'to bottom', 'to right',\" +\n                    \" 'to bottom right', 'to top right' or 'ellipse at center'\" };\n        }\n        returner = '<?xml version=\"1.0\" ?>' +\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"100%\" height=\"100%\" viewBox=\"0 0 1 1\" preserveAspectRatio=\"none\">' +\n            '<' + gradientType + 'Gradient id=\"gradient\" gradientUnits=\"userSpaceOnUse\" ' + gradientDirectionSvg + '>';\n\n        for (i = 0; i < stops.length; i+= 1) {\n            if (stops[i] instanceof Expression) {\n                color = stops[i].value[0];\n                position = stops[i].value[1];\n            } else {\n                color = stops[i];\n                position = undefined;\n            }\n\n            if (!(color instanceof Color) || (!((i === 0 || i + 1 === stops.length) && position === undefined) && !(position instanceof Dimension))) {\n                throwArgumentDescriptor();\n            }\n            positionValue = position ? position.toCSS(renderEnv) : i === 0 ? \"0%\" : \"100%\";\n            alpha = color.alpha;\n            returner += '<stop offset=\"' + positionValue + '\" stop-color=\"' + color.toRGB() + '\"' + (alpha < 1 ? ' stop-opacity=\"' + alpha + '\"' : '') + '/>';\n        }\n        returner += '</' + gradientType + 'Gradient>' +\n            '<rect ' + rectangleDimension + ' fill=\"url(#gradient)\" /></svg>';\n\n        returner = encodeURIComponent(returner);\n\n        returner = \"data:image/svg+xml,\" + returner;\n        return new URL(new Quoted(\"'\" + returner + \"'\", returner, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);\n    });\n};\n\n},{\"../tree/color\":50,\"../tree/dimension\":56,\"../tree/expression\":59,\"../tree/quoted\":73,\"../tree/url\":80,\"./function-registry\":22}],29:[function(require,module,exports){\nvar Keyword = require(\"../tree/keyword\"),\n    DetachedRuleset = require(\"../tree/detached-ruleset\"),\n    Dimension = require(\"../tree/dimension\"),\n    Color = require(\"../tree/color\"),\n    Quoted = require(\"../tree/quoted\"),\n    Anonymous = require(\"../tree/anonymous\"),\n    URL = require(\"../tree/url\"),\n    Operation = require(\"../tree/operation\"),\n    functionRegistry = require(\"./function-registry\");\n\nvar isa = function (n, Type) {\n        return (n instanceof Type) ? Keyword.True : Keyword.False;\n    },\n    isunit = function (n, unit) {\n        if (unit === undefined) {\n            throw { type: \"Argument\", message: \"missing the required second argument to isunit.\" };\n        }\n        unit = typeof unit.value === \"string\" ? unit.value : unit;\n        if (typeof unit !== \"string\") {\n            throw { type: \"Argument\", message: \"Second argument to isunit should be a unit or a string.\" };\n        }\n        return (n instanceof Dimension) && n.unit.is(unit) ? Keyword.True : Keyword.False;\n    },\n    getItemsFromNode = function(node) {\n        // handle non-array values as an array of length 1\n        // return 'undefined' if index is invalid\n        var items = Array.isArray(node.value) ?\n            node.value : Array(node);\n\n        return items;\n    };\nfunctionRegistry.addMultiple({\n    isruleset: function (n) {\n        return isa(n, DetachedRuleset);\n    },\n    iscolor: function (n) {\n        return isa(n, Color);\n    },\n    isnumber: function (n) {\n        return isa(n, Dimension);\n    },\n    isstring: function (n) {\n        return isa(n, Quoted);\n    },\n    iskeyword: function (n) {\n        return isa(n, Keyword);\n    },\n    isurl: function (n) {\n        return isa(n, URL);\n    },\n    ispixel: function (n) {\n        return isunit(n, 'px');\n    },\n    ispercentage: function (n) {\n        return isunit(n, '%');\n    },\n    isem: function (n) {\n        return isunit(n, 'em');\n    },\n    isunit: isunit,\n    unit: function (val, unit) {\n        if (!(val instanceof Dimension)) {\n            throw { type: \"Argument\",\n                message: \"the first argument to unit must be a number\" +\n                    (val instanceof Operation ? \". Have you forgotten parenthesis?\" : \"\") };\n        }\n        if (unit) {\n            if (unit instanceof Keyword) {\n                unit = unit.value;\n            } else {\n                unit = unit.toCSS();\n            }\n        } else {\n            unit = \"\";\n        }\n        return new Dimension(val.value, unit);\n    },\n    \"get-unit\": function (n) {\n        return new Anonymous(n.unit);\n    },\n    extract: function(values, index) {\n        index = index.value - 1; // (1-based index)\n\n        return getItemsFromNode(values)[index];\n    },\n    length: function(values) {\n        return new Dimension(getItemsFromNode(values).length);\n    }\n});\n\n},{\"../tree/anonymous\":46,\"../tree/color\":50,\"../tree/detached-ruleset\":55,\"../tree/dimension\":56,\"../tree/keyword\":65,\"../tree/operation\":71,\"../tree/quoted\":73,\"../tree/url\":80,\"./function-registry\":22}],30:[function(require,module,exports){\nvar contexts = require(\"./contexts\"),\n    Parser = require('./parser/parser'),\n    FunctionImporter = require('./plugins/function-importer');\n\nmodule.exports = function(environment) {\n\n    // FileInfo = {\n    //  'relativeUrls' - option - whether to adjust URL's to be relative\n    //  'filename' - full resolved filename of current file\n    //  'rootpath' - path to append to normal URLs for this node\n    //  'currentDirectory' - path to the current file, absolute\n    //  'rootFilename' - filename of the base file\n    //  'entryPath' - absolute path to the entry file\n    //  'reference' - whether the file should not be output and only output parts that are referenced\n\n    var ImportManager = function(context, rootFileInfo) {\n        this.rootFilename = rootFileInfo.filename;\n        this.paths = context.paths || [];  // Search paths, when importing\n        this.contents = {};             // map - filename to contents of all the files\n        this.contentsIgnoredChars = {}; // map - filename to lines at the beginning of each file to ignore\n        this.mime = context.mime;\n        this.error = null;\n        this.context = context;\n        // Deprecated? Unused outside of here, could be useful.\n        this.queue = [];        // Files which haven't been imported yet\n        this.files = {};        // Holds the imported parse trees.\n    };\n    /**\n     * Add an import to be imported\n     * @param path - the raw path\n     * @param tryAppendLessExtension - whether to try appending the less extension (if the path has no extension)\n     * @param currentFileInfo - the current file info (used for instance to work out relative paths)\n     * @param importOptions - import options\n     * @param callback - callback for when it is imported\n     */\n    ImportManager.prototype.push = function (path, tryAppendLessExtension, currentFileInfo, importOptions, callback) {\n        var importManager = this;\n        this.queue.push(path);\n\n        var fileParsedFunc = function (e, root, fullPath) {\n            importManager.queue.splice(importManager.queue.indexOf(path), 1); // Remove the path from the queue\n\n            var importedEqualsRoot = fullPath === importManager.rootFilename;\n            if (importOptions.optional && e) {\n                callback(null, {rules:[]}, false, null);\n            }\n            else {\n                importManager.files[fullPath] = root;\n                if (e && !importManager.error) { importManager.error = e; }\n                callback(e, root, importedEqualsRoot, fullPath);\n            }\n        };\n\n        var newFileInfo = {\n            relativeUrls: this.context.relativeUrls,\n            entryPath: currentFileInfo.entryPath,\n            rootpath: currentFileInfo.rootpath,\n            rootFilename: currentFileInfo.rootFilename\n        };\n\n        var fileManager = environment.getFileManager(path, currentFileInfo.currentDirectory, this.context, environment);\n\n        if (!fileManager) {\n            fileParsedFunc({ message: \"Could not find a file-manager for \" + path });\n            return;\n        }\n\n        if (tryAppendLessExtension) {\n            path = fileManager.tryAppendExtension(path, importOptions.plugin ? \".js\" : \".less\");\n        }\n\n        var loadFileCallback = function(loadedFile) {\n            var resolvedFilename = loadedFile.filename,\n                contents = loadedFile.contents.replace(/^\\uFEFF/, '');\n\n            // Pass on an updated rootpath if path of imported file is relative and file\n            // is in a (sub|sup) directory\n            //\n            // Examples:\n            // - If path of imported file is 'module/nav/nav.less' and rootpath is 'less/',\n            //   then rootpath should become 'less/module/nav/'\n            // - If path of imported file is '../mixins.less' and rootpath is 'less/',\n            //   then rootpath should become 'less/../'\n            newFileInfo.currentDirectory = fileManager.getPath(resolvedFilename);\n            if (newFileInfo.relativeUrls) {\n                newFileInfo.rootpath = fileManager.join(\n                    (importManager.context.rootpath || \"\"),\n                    fileManager.pathDiff(newFileInfo.currentDirectory, newFileInfo.entryPath));\n\n                if (!fileManager.isPathAbsolute(newFileInfo.rootpath) && fileManager.alwaysMakePathsAbsolute()) {\n                    newFileInfo.rootpath = fileManager.join(newFileInfo.entryPath, newFileInfo.rootpath);\n                }\n            }\n            newFileInfo.filename = resolvedFilename;\n\n            var newEnv = new contexts.Parse(importManager.context);\n\n            newEnv.processImports = false;\n            importManager.contents[resolvedFilename] = contents;\n\n            if (currentFileInfo.reference || importOptions.reference) {\n                newFileInfo.reference = true;\n            }\n\n            if (importOptions.plugin) {\n                new FunctionImporter(newEnv, newFileInfo).eval(contents, function (e, root) {\n                    fileParsedFunc(e, root, resolvedFilename);\n                });\n            } else if (importOptions.inline) {\n                fileParsedFunc(null, contents, resolvedFilename);\n            } else {\n                new Parser(newEnv, importManager, newFileInfo).parse(contents, function (e, root) {\n                    fileParsedFunc(e, root, resolvedFilename);\n                });\n            }\n        };\n\n        var promise = fileManager.loadFile(path, currentFileInfo.currentDirectory, this.context, environment,\n            function(err, loadedFile) {\n            if (err) {\n                fileParsedFunc(err);\n            } else {\n                loadFileCallback(loadedFile);\n            }\n        });\n        if (promise) {\n            promise.then(loadFileCallback, fileParsedFunc);\n        }\n    };\n    return ImportManager;\n};\n\n},{\"./contexts\":11,\"./parser/parser\":38,\"./plugins/function-importer\":40}],31:[function(require,module,exports){\nmodule.exports = function(environment, fileManagers) {\n    var SourceMapOutput, SourceMapBuilder, ParseTree, ImportManager, Environment;\n\n    var less = {\n        version: [2, 7, 2],\n        data: require('./data'),\n        tree: require('./tree'),\n        Environment: (Environment = require(\"./environment/environment\")),\n        AbstractFileManager: require(\"./environment/abstract-file-manager\"),\n        environment: (environment = new Environment(environment, fileManagers)),\n        visitors: require('./visitors'),\n        Parser: require('./parser/parser'),\n        functions: require('./functions')(environment),\n        contexts: require(\"./contexts\"),\n        SourceMapOutput: (SourceMapOutput = require('./source-map-output')(environment)),\n        SourceMapBuilder: (SourceMapBuilder = require('./source-map-builder')(SourceMapOutput, environment)),\n        ParseTree: (ParseTree = require('./parse-tree')(SourceMapBuilder)),\n        ImportManager: (ImportManager = require('./import-manager')(environment)),\n        render: require(\"./render\")(environment, ParseTree, ImportManager),\n        parse: require(\"./parse\")(environment, ParseTree, ImportManager),\n        LessError: require('./less-error'),\n        transformTree: require('./transform-tree'),\n        utils: require('./utils'),\n        PluginManager: require('./plugin-manager'),\n        logger: require('./logger')\n    };\n\n    return less;\n};\n\n},{\"./contexts\":11,\"./data\":13,\"./environment/abstract-file-manager\":15,\"./environment/environment\":16,\"./functions\":23,\"./import-manager\":30,\"./less-error\":32,\"./logger\":33,\"./parse\":35,\"./parse-tree\":34,\"./parser/parser\":38,\"./plugin-manager\":39,\"./render\":41,\"./source-map-builder\":42,\"./source-map-output\":43,\"./transform-tree\":44,\"./tree\":62,\"./utils\":83,\"./visitors\":87}],32:[function(require,module,exports){\nvar utils = require(\"./utils\");\n\nvar LessError = module.exports = function LessError(e, importManager, currentFilename) {\n\n    Error.call(this);\n\n    var filename = e.filename || currentFilename;\n\n    if (importManager && filename) {\n        var input = importManager.contents[filename],\n            loc = utils.getLocation(e.index, input),\n            line = loc.line,\n            col  = loc.column,\n            callLine = e.call && utils.getLocation(e.call, input).line,\n            lines = input.split('\\n');\n\n        this.type = e.type || 'Syntax';\n        this.filename = filename;\n        this.index = e.index;\n        this.line = typeof line === 'number' ? line + 1 : null;\n        this.callLine = callLine + 1;\n        this.callExtract = lines[callLine];\n        this.column = col;\n        this.extract = [\n            lines[line - 1],\n            lines[line],\n            lines[line + 1]\n        ];\n    }\n    this.message = e.message;\n    this.stack = e.stack;\n};\n\nif (typeof Object.create === 'undefined') {\n    var F = function () {};\n    F.prototype = Error.prototype;\n    LessError.prototype = new F();\n} else {\n    LessError.prototype = Object.create(Error.prototype);\n}\n\nLessError.prototype.constructor = LessError;\n\n},{\"./utils\":83}],33:[function(require,module,exports){\nmodule.exports = {\n    error: function(msg) {\n        this._fireEvent(\"error\", msg);\n    },\n    warn: function(msg) {\n        this._fireEvent(\"warn\", msg);\n    },\n    info: function(msg) {\n        this._fireEvent(\"info\", msg);\n    },\n    debug: function(msg) {\n        this._fireEvent(\"debug\", msg);\n    },\n    addListener: function(listener) {\n        this._listeners.push(listener);\n    },\n    removeListener: function(listener) {\n        for (var i = 0; i < this._listeners.length; i++) {\n            if (this._listeners[i] === listener) {\n                this._listeners.splice(i, 1);\n                return;\n            }\n        }\n    },\n    _fireEvent: function(type, msg) {\n        for (var i = 0; i < this._listeners.length; i++) {\n            var logFunction = this._listeners[i][type];\n            if (logFunction) {\n                logFunction(msg);\n            }\n        }\n    },\n    _listeners: []\n};\n\n},{}],34:[function(require,module,exports){\nvar LessError = require('./less-error'),\n    transformTree = require(\"./transform-tree\"),\n    logger = require(\"./logger\");\n\nmodule.exports = function(SourceMapBuilder) {\n    var ParseTree = function(root, imports) {\n        this.root = root;\n        this.imports = imports;\n    };\n\n    ParseTree.prototype.toCSS = function(options) {\n        var evaldRoot, result = {}, sourceMapBuilder;\n        try {\n            evaldRoot = transformTree(this.root, options);\n        } catch (e) {\n            throw new LessError(e, this.imports);\n        }\n\n        try {\n            var compress = Boolean(options.compress);\n            if (compress) {\n                logger.warn(\"The compress option has been deprecated. We recommend you use a dedicated css minifier, for instance see less-plugin-clean-css.\");\n            }\n\n            var toCSSOptions = {\n                compress: compress,\n                dumpLineNumbers: options.dumpLineNumbers,\n                strictUnits: Boolean(options.strictUnits),\n                numPrecision: 8};\n\n            if (options.sourceMap) {\n                sourceMapBuilder = new SourceMapBuilder(options.sourceMap);\n                result.css = sourceMapBuilder.toCSS(evaldRoot, toCSSOptions, this.imports);\n            } else {\n                result.css = evaldRoot.toCSS(toCSSOptions);\n            }\n        } catch (e) {\n            throw new LessError(e, this.imports);\n        }\n\n        if (options.pluginManager) {\n            var postProcessors = options.pluginManager.getPostProcessors();\n            for (var i = 0; i < postProcessors.length; i++) {\n                result.css = postProcessors[i].process(result.css, { sourceMap: sourceMapBuilder, options: options, imports: this.imports });\n            }\n        }\n        if (options.sourceMap) {\n            result.map = sourceMapBuilder.getExternalSourceMap();\n        }\n\n        result.imports = [];\n        for (var file in this.imports.files) {\n            if (this.imports.files.hasOwnProperty(file) && file !== this.imports.rootFilename) {\n                result.imports.push(file);\n            }\n        }\n        return result;\n    };\n    return ParseTree;\n};\n\n},{\"./less-error\":32,\"./logger\":33,\"./transform-tree\":44}],35:[function(require,module,exports){\nvar PromiseConstructor,\n    contexts = require(\"./contexts\"),\n    Parser = require('./parser/parser'),\n    PluginManager = require('./plugin-manager');\n\nmodule.exports = function(environment, ParseTree, ImportManager) {\n    var parse = function (input, options, callback) {\n        options = options || {};\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n\n        if (!callback) {\n            if (!PromiseConstructor) {\n                PromiseConstructor = typeof Promise === 'undefined' ? require('promise') : Promise;\n            }\n            var self = this;\n            return new PromiseConstructor(function (resolve, reject) {\n                parse.call(self, input, options, function(err, output) {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(output);\n                    }\n                });\n            });\n        } else {\n            var context,\n                rootFileInfo,\n                pluginManager = new PluginManager(this);\n\n            pluginManager.addPlugins(options.plugins);\n            options.pluginManager = pluginManager;\n\n            context = new contexts.Parse(options);\n\n            if (options.rootFileInfo) {\n                rootFileInfo = options.rootFileInfo;\n            } else {\n                var filename = options.filename || \"input\";\n                var entryPath = filename.replace(/[^\\/\\\\]*$/, \"\");\n                rootFileInfo = {\n                    filename: filename,\n                    relativeUrls: context.relativeUrls,\n                    rootpath: context.rootpath || \"\",\n                    currentDirectory: entryPath,\n                    entryPath: entryPath,\n                    rootFilename: filename\n                };\n                // add in a missing trailing slash\n                if (rootFileInfo.rootpath && rootFileInfo.rootpath.slice(-1) !== \"/\") {\n                    rootFileInfo.rootpath += \"/\";\n                }\n            }\n\n            var imports = new ImportManager(context, rootFileInfo);\n\n            new Parser(context, imports, rootFileInfo)\n                .parse(input, function (e, root) {\n                if (e) { return callback(e); }\n                callback(null, root, imports, options);\n            }, options);\n        }\n    };\n    return parse;\n};\n\n},{\"./contexts\":11,\"./parser/parser\":38,\"./plugin-manager\":39,\"promise\":undefined}],36:[function(require,module,exports){\n// Split the input into chunks.\nmodule.exports = function (input, fail) {\n    var len = input.length, level = 0, parenLevel = 0,\n        lastOpening, lastOpeningParen, lastMultiComment, lastMultiCommentEndBrace,\n        chunks = [], emitFrom = 0,\n        chunkerCurrentIndex, currentChunkStartIndex, cc, cc2, matched;\n\n    function emitChunk(force) {\n        var len = chunkerCurrentIndex - emitFrom;\n        if (((len < 512) && !force) || !len) {\n            return;\n        }\n        chunks.push(input.slice(emitFrom, chunkerCurrentIndex + 1));\n        emitFrom = chunkerCurrentIndex + 1;\n    }\n\n    for (chunkerCurrentIndex = 0; chunkerCurrentIndex < len; chunkerCurrentIndex++) {\n        cc = input.charCodeAt(chunkerCurrentIndex);\n        if (((cc >= 97) && (cc <= 122)) || (cc < 34)) {\n            // a-z or whitespace\n            continue;\n        }\n\n        switch (cc) {\n            case 40:                        // (\n                parenLevel++;\n                lastOpeningParen = chunkerCurrentIndex;\n                continue;\n            case 41:                        // )\n                if (--parenLevel < 0) {\n                    return fail(\"missing opening `(`\", chunkerCurrentIndex);\n                }\n                continue;\n            case 59:                        // ;\n                if (!parenLevel) { emitChunk(); }\n                continue;\n            case 123:                       // {\n                level++;\n                lastOpening = chunkerCurrentIndex;\n                continue;\n            case 125:                       // }\n                if (--level < 0) {\n                    return fail(\"missing opening `{`\", chunkerCurrentIndex);\n                }\n                if (!level && !parenLevel) { emitChunk(); }\n                continue;\n            case 92:                        // \\\n                if (chunkerCurrentIndex < len - 1) { chunkerCurrentIndex++; continue; }\n                return fail(\"unescaped `\\\\`\", chunkerCurrentIndex);\n            case 34:\n            case 39:\n            case 96:                        // \", ' and `\n                matched = 0;\n                currentChunkStartIndex = chunkerCurrentIndex;\n                for (chunkerCurrentIndex = chunkerCurrentIndex + 1; chunkerCurrentIndex < len; chunkerCurrentIndex++) {\n                    cc2 = input.charCodeAt(chunkerCurrentIndex);\n                    if (cc2 > 96) { continue; }\n                    if (cc2 == cc) { matched = 1; break; }\n                    if (cc2 == 92) {        // \\\n                        if (chunkerCurrentIndex == len - 1) {\n                            return fail(\"unescaped `\\\\`\", chunkerCurrentIndex);\n                        }\n                        chunkerCurrentIndex++;\n                    }\n                }\n                if (matched) { continue; }\n                return fail(\"unmatched `\" + String.fromCharCode(cc) + \"`\", currentChunkStartIndex);\n            case 47:                        // /, check for comment\n                if (parenLevel || (chunkerCurrentIndex == len - 1)) { continue; }\n                cc2 = input.charCodeAt(chunkerCurrentIndex + 1);\n                if (cc2 == 47) {\n                    // //, find lnfeed\n                    for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len; chunkerCurrentIndex++) {\n                        cc2 = input.charCodeAt(chunkerCurrentIndex);\n                        if ((cc2 <= 13) && ((cc2 == 10) || (cc2 == 13))) { break; }\n                    }\n                } else if (cc2 == 42) {\n                    // /*, find */\n                    lastMultiComment = currentChunkStartIndex = chunkerCurrentIndex;\n                    for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len - 1; chunkerCurrentIndex++) {\n                        cc2 = input.charCodeAt(chunkerCurrentIndex);\n                        if (cc2 == 125) { lastMultiCommentEndBrace = chunkerCurrentIndex; }\n                        if (cc2 != 42) { continue; }\n                        if (input.charCodeAt(chunkerCurrentIndex + 1) == 47) { break; }\n                    }\n                    if (chunkerCurrentIndex == len - 1) {\n                        return fail(\"missing closing `*/`\", currentChunkStartIndex);\n                    }\n                    chunkerCurrentIndex++;\n                }\n                continue;\n            case 42:                       // *, check for unmatched */\n                if ((chunkerCurrentIndex < len - 1) && (input.charCodeAt(chunkerCurrentIndex + 1) == 47)) {\n                    return fail(\"unmatched `/*`\", chunkerCurrentIndex);\n                }\n                continue;\n        }\n    }\n\n    if (level !== 0) {\n        if ((lastMultiComment > lastOpening) && (lastMultiCommentEndBrace > lastMultiComment)) {\n            return fail(\"missing closing `}` or `*/`\", lastOpening);\n        } else {\n            return fail(\"missing closing `}`\", lastOpening);\n        }\n    } else if (parenLevel !== 0) {\n        return fail(\"missing closing `)`\", lastOpeningParen);\n    }\n\n    emitChunk(true);\n    return chunks;\n};\n\n},{}],37:[function(require,module,exports){\nvar chunker = require('./chunker');\n\nmodule.exports = function() {\n    var input,       // LeSS input string\n        j,           // current chunk\n        saveStack = [],   // holds state for backtracking\n        furthest,    // furthest index the parser has gone to\n        furthestPossibleErrorMessage,// if this is furthest we got to, this is the probably cause\n        chunks,      // chunkified input\n        current,     // current chunk\n        currentPos,  // index of current chunk, in `input`\n        parserInput = {};\n\n    var CHARCODE_SPACE = 32,\n        CHARCODE_TAB = 9,\n        CHARCODE_LF = 10,\n        CHARCODE_CR = 13,\n        CHARCODE_PLUS = 43,\n        CHARCODE_COMMA = 44,\n        CHARCODE_FORWARD_SLASH = 47,\n        CHARCODE_9 = 57;\n\n    function skipWhitespace(length) {\n        var oldi = parserInput.i, oldj = j,\n            curr = parserInput.i - currentPos,\n            endIndex = parserInput.i + current.length - curr,\n            mem = (parserInput.i += length),\n            inp = input,\n            c, nextChar, comment;\n\n        for (; parserInput.i < endIndex; parserInput.i++) {\n            c = inp.charCodeAt(parserInput.i);\n\n            if (parserInput.autoCommentAbsorb && c === CHARCODE_FORWARD_SLASH) {\n                nextChar = inp.charAt(parserInput.i + 1);\n                if (nextChar === '/') {\n                    comment = {index: parserInput.i, isLineComment: true};\n                    var nextNewLine = inp.indexOf(\"\\n\", parserInput.i + 2);\n                    if (nextNewLine < 0) {\n                        nextNewLine = endIndex;\n                    }\n                    parserInput.i = nextNewLine;\n                    comment.text = inp.substr(comment.index, parserInput.i - comment.index);\n                    parserInput.commentStore.push(comment);\n                    continue;\n                } else if (nextChar === '*') {\n                    var nextStarSlash = inp.indexOf(\"*/\", parserInput.i + 2);\n                    if (nextStarSlash >= 0) {\n                        comment = {\n                            index: parserInput.i,\n                            text: inp.substr(parserInput.i, nextStarSlash + 2 - parserInput.i),\n                            isLineComment: false\n                        };\n                        parserInput.i += comment.text.length - 1;\n                        parserInput.commentStore.push(comment);\n                        continue;\n                    }\n                }\n                break;\n            }\n\n            if ((c !== CHARCODE_SPACE) && (c !== CHARCODE_LF) && (c !== CHARCODE_TAB) && (c !== CHARCODE_CR)) {\n                break;\n            }\n        }\n\n        current = current.slice(length + parserInput.i - mem + curr);\n        currentPos = parserInput.i;\n\n        if (!current.length) {\n            if (j < chunks.length - 1) {\n                current = chunks[++j];\n                skipWhitespace(0); // skip space at the beginning of a chunk\n                return true; // things changed\n            }\n            parserInput.finished = true;\n        }\n\n        return oldi !== parserInput.i || oldj !== j;\n    }\n\n    parserInput.save = function() {\n        currentPos = parserInput.i;\n        saveStack.push( { current: current, i: parserInput.i, j: j });\n    };\n    parserInput.restore = function(possibleErrorMessage) {\n\n        if (parserInput.i > furthest || (parserInput.i === furthest && possibleErrorMessage && !furthestPossibleErrorMessage)) {\n            furthest = parserInput.i;\n            furthestPossibleErrorMessage = possibleErrorMessage;\n        }\n        var state = saveStack.pop();\n        current = state.current;\n        currentPos = parserInput.i = state.i;\n        j = state.j;\n    };\n    parserInput.forget = function() {\n        saveStack.pop();\n    };\n    parserInput.isWhitespace = function (offset) {\n        var pos = parserInput.i + (offset || 0),\n            code = input.charCodeAt(pos);\n        return (code === CHARCODE_SPACE || code === CHARCODE_CR || code === CHARCODE_TAB || code === CHARCODE_LF);\n    };\n\n    // Specialization of $(tok)\n    parserInput.$re = function(tok) {\n        if (parserInput.i > currentPos) {\n            current = current.slice(parserInput.i - currentPos);\n            currentPos = parserInput.i;\n        }\n\n        var m = tok.exec(current);\n        if (!m) {\n            return null;\n        }\n\n        skipWhitespace(m[0].length);\n        if (typeof m === \"string\") {\n            return m;\n        }\n\n        return m.length === 1 ? m[0] : m;\n    };\n\n    parserInput.$char = function(tok) {\n        if (input.charAt(parserInput.i) !== tok) {\n            return null;\n        }\n        skipWhitespace(1);\n        return tok;\n    };\n\n    parserInput.$str = function(tok) {\n        var tokLength = tok.length;\n\n        // https://jsperf.com/string-startswith/21\n        for (var i = 0; i < tokLength; i++) {\n            if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n                return null;\n            }\n        }\n\n        skipWhitespace(tokLength);\n        return tok;\n    };\n\n    parserInput.$quoted = function() {\n\n        var startChar = input.charAt(parserInput.i);\n        if (startChar !== \"'\" && startChar !== '\"') {\n            return;\n        }\n        var length = input.length,\n            currentPosition = parserInput.i;\n\n        for (var i = 1; i + currentPosition < length; i++) {\n            var nextChar = input.charAt(i + currentPosition);\n            switch(nextChar) {\n                case \"\\\\\":\n                    i++;\n                    continue;\n                case \"\\r\":\n                case \"\\n\":\n                    break;\n                case startChar:\n                    var str = input.substr(currentPosition, i + 1);\n                    skipWhitespace(i + 1);\n                    return str;\n                default:\n            }\n        }\n        return null;\n    };\n\n    parserInput.autoCommentAbsorb = true;\n    parserInput.commentStore = [];\n    parserInput.finished = false;\n\n    // Same as $(), but don't change the state of the parser,\n    // just return the match.\n    parserInput.peek = function(tok) {\n        if (typeof tok === 'string') {\n            // https://jsperf.com/string-startswith/21\n            for (var i = 0; i < tok.length; i++) {\n                if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            return tok.test(current);\n        }\n    };\n\n    // Specialization of peek()\n    // TODO remove or change some currentChar calls to peekChar\n    parserInput.peekChar = function(tok) {\n        return input.charAt(parserInput.i) === tok;\n    };\n\n    parserInput.currentChar = function() {\n        return input.charAt(parserInput.i);\n    };\n\n    parserInput.getInput = function() {\n        return input;\n    };\n\n    parserInput.peekNotNumeric = function() {\n        var c = input.charCodeAt(parserInput.i);\n        //Is the first char of the dimension 0-9, '.', '+' or '-'\n        return (c > CHARCODE_9 || c < CHARCODE_PLUS) || c === CHARCODE_FORWARD_SLASH || c === CHARCODE_COMMA;\n    };\n\n    parserInput.start = function(str, chunkInput, failFunction) {\n        input = str;\n        parserInput.i = j = currentPos = furthest = 0;\n\n        // chunking apparently makes things quicker (but my tests indicate\n        // it might actually make things slower in node at least)\n        // and it is a non-perfect parse - it can't recognise\n        // unquoted urls, meaning it can't distinguish comments\n        // meaning comments with quotes or {}() in them get 'counted'\n        // and then lead to parse errors.\n        // In addition if the chunking chunks in the wrong place we might\n        // not be able to parse a parser statement in one go\n        // this is officially deprecated but can be switched on via an option\n        // in the case it causes too much performance issues.\n        if (chunkInput) {\n            chunks = chunker(str, failFunction);\n        } else {\n            chunks = [str];\n        }\n\n        current = chunks[0];\n\n        skipWhitespace(0);\n    };\n\n    parserInput.end = function() {\n        var message,\n            isFinished = parserInput.i >= input.length;\n\n        if (parserInput.i < furthest) {\n            message = furthestPossibleErrorMessage;\n            parserInput.i = furthest;\n        }\n        return {\n            isFinished: isFinished,\n            furthest: parserInput.i,\n            furthestPossibleErrorMessage: message,\n            furthestReachedEnd: parserInput.i >= input.length - 1,\n            furthestChar: input[parserInput.i]\n        };\n    };\n\n    return parserInput;\n};\n\n},{\"./chunker\":36}],38:[function(require,module,exports){\nvar LessError = require('../less-error'),\n    tree = require(\"../tree\"),\n    visitors = require(\"../visitors\"),\n    getParserInput = require(\"./parser-input\"),\n    utils = require(\"../utils\");\n\n//\n// less.js - parser\n//\n//    A relatively straight-forward predictive parser.\n//    There is no tokenization/lexing stage, the input is parsed\n//    in one sweep.\n//\n//    To make the parser fast enough to run in the browser, several\n//    optimization had to be made:\n//\n//    - Matching and slicing on a huge input is often cause of slowdowns.\n//      The solution is to chunkify the input into smaller strings.\n//      The chunks are stored in the `chunks` var,\n//      `j` holds the current chunk index, and `currentPos` holds\n//      the index of the current chunk in relation to `input`.\n//      This gives us an almost 4x speed-up.\n//\n//    - In many cases, we don't need to match individual tokens;\n//      for example, if a value doesn't hold any variables, operations\n//      or dynamic references, the parser can effectively 'skip' it,\n//      treating it as a literal.\n//      An example would be '1px solid #000' - which evaluates to itself,\n//      we don't need to know what the individual components are.\n//      The drawback, of course is that you don't get the benefits of\n//      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,\n//      and a smaller speed-up in the code-gen.\n//\n//\n//    Token matching is done with the `$` function, which either takes\n//    a terminal string or regexp, or a non-terminal function to call.\n//    It also takes care of moving all the indices forwards.\n//`\n//\nvar Parser = function Parser(context, imports, fileInfo) {\n    var parsers,\n        parserInput = getParserInput();\n\n    function error(msg, type) {\n        throw new LessError(\n            {\n                index: parserInput.i,\n                filename: fileInfo.filename,\n                type: type || 'Syntax',\n                message: msg\n            },\n            imports\n        );\n    }\n\n    function expect(arg, msg, index) {\n        // some older browsers return typeof 'function' for RegExp\n        var result = (arg instanceof Function) ? arg.call(parsers) : parserInput.$re(arg);\n        if (result) {\n            return result;\n        }\n        error(msg || (typeof arg === 'string' ? \"expected '\" + arg + \"' got '\" + parserInput.currentChar() + \"'\"\n                                               : \"unexpected token\"));\n    }\n\n    // Specialization of expect()\n    function expectChar(arg, msg) {\n        if (parserInput.$char(arg)) {\n            return arg;\n        }\n        error(msg || \"expected '\" + arg + \"' got '\" + parserInput.currentChar() + \"'\");\n    }\n\n    function getDebugInfo(index) {\n        var filename = fileInfo.filename;\n\n        return {\n            lineNumber: utils.getLocation(index, parserInput.getInput()).line + 1,\n            fileName: filename\n        };\n    }\n\n    //\n    // The Parser\n    //\n    return {\n\n        //\n        // Parse an input string into an abstract syntax tree,\n        // @param str A string containing 'less' markup\n        // @param callback call `callback` when done.\n        // @param [additionalData] An optional map which can contains vars - a map (key, value) of variables to apply\n        //\n        parse: function (str, callback, additionalData) {\n            var root, error = null, globalVars, modifyVars, ignored, preText = \"\";\n\n            globalVars = (additionalData && additionalData.globalVars) ? Parser.serializeVars(additionalData.globalVars) + '\\n' : '';\n            modifyVars = (additionalData && additionalData.modifyVars) ? '\\n' + Parser.serializeVars(additionalData.modifyVars) : '';\n\n            if (context.pluginManager) {\n                var preProcessors = context.pluginManager.getPreProcessors();\n                for (var i = 0; i < preProcessors.length; i++) {\n                    str = preProcessors[i].process(str, { context: context, imports: imports, fileInfo: fileInfo });\n                }\n            }\n\n            if (globalVars || (additionalData && additionalData.banner)) {\n                preText = ((additionalData && additionalData.banner) ? additionalData.banner : \"\") + globalVars;\n                ignored = imports.contentsIgnoredChars;\n                ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0;\n                ignored[fileInfo.filename] += preText.length;\n            }\n\n            str = str.replace(/\\r\\n?/g, '\\n');\n            // Remove potential UTF Byte Order Mark\n            str = preText + str.replace(/^\\uFEFF/, '') + modifyVars;\n            imports.contents[fileInfo.filename] = str;\n\n            // Start with the primary rule.\n            // The whole syntax tree is held under a Ruleset node,\n            // with the `root` property set to true, so no `{}` are\n            // output. The callback is called when the input is parsed.\n            try {\n                parserInput.start(str, context.chunkInput, function fail(msg, index) {\n                    throw new LessError({\n                        index: index,\n                        type: 'Parse',\n                        message: msg,\n                        filename: fileInfo.filename\n                    }, imports);\n                });\n\n                root = new(tree.Ruleset)(null, this.parsers.primary());\n                root.root = true;\n                root.firstRoot = true;\n            } catch (e) {\n                return callback(new LessError(e, imports, fileInfo.filename));\n            }\n\n            // If `i` is smaller than the `input.length - 1`,\n            // it means the parser wasn't able to parse the whole\n            // string, so we've got a parsing error.\n            //\n            // We try to extract a \\n delimited string,\n            // showing the line where the parse error occurred.\n            // We split it up into two parts (the part which parsed,\n            // and the part which didn't), so we can color them differently.\n            var endInfo = parserInput.end();\n            if (!endInfo.isFinished) {\n\n                var message = endInfo.furthestPossibleErrorMessage;\n\n                if (!message) {\n                    message = \"Unrecognised input\";\n                    if (endInfo.furthestChar === '}') {\n                        message += \". Possibly missing opening '{'\";\n                    } else if (endInfo.furthestChar === ')') {\n                        message += \". Possibly missing opening '('\";\n                    } else if (endInfo.furthestReachedEnd) {\n                        message += \". Possibly missing something\";\n                    }\n                }\n\n                error = new LessError({\n                    type: \"Parse\",\n                    message: message,\n                    index: endInfo.furthest,\n                    filename: fileInfo.filename\n                }, imports);\n            }\n\n            var finish = function (e) {\n                e = error || e || imports.error;\n\n                if (e) {\n                    if (!(e instanceof LessError)) {\n                        e = new LessError(e, imports, fileInfo.filename);\n                    }\n\n                    return callback(e);\n                }\n                else {\n                    return callback(null, root);\n                }\n            };\n\n            if (context.processImports !== false) {\n                new visitors.ImportVisitor(imports, finish)\n                    .run(root);\n            } else {\n                return finish();\n            }\n        },\n\n        //\n        // Here in, the parsing rules/functions\n        //\n        // The basic structure of the syntax tree generated is as follows:\n        //\n        //   Ruleset ->  Rule -> Value -> Expression -> Entity\n        //\n        // Here's some Less code:\n        //\n        //    .class {\n        //      color: #fff;\n        //      border: 1px solid #000;\n        //      width: @w + 4px;\n        //      > .child {...}\n        //    }\n        //\n        // And here's what the parse tree might look like:\n        //\n        //     Ruleset (Selector '.class', [\n        //         Rule (\"color\",  Value ([Expression [Color #fff]]))\n        //         Rule (\"border\", Value ([Expression [Dimension 1px][Keyword \"solid\"][Color #000]]))\n        //         Rule (\"width\",  Value ([Expression [Operation \" + \" [Variable \"@w\"][Dimension 4px]]]))\n        //         Ruleset (Selector [Element '>', '.child'], [...])\n        //     ])\n        //\n        //  In general, most rules will try to parse a token with the `$re()` function, and if the return\n        //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check\n        //  first, before parsing, that's when we use `peek()`.\n        //\n        parsers: parsers = {\n            //\n            // The `primary` rule is the *entry* and *exit* point of the parser.\n            // The rules here can appear at any level of the parse tree.\n            //\n            // The recursive nature of the grammar is an interplay between the `block`\n            // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,\n            // as represented by this simplified grammar:\n            //\n            //     primary  →  (ruleset | rule)+\n            //     ruleset  →  selector+ block\n            //     block    →  '{' primary '}'\n            //\n            // Only at one point is the primary rule not called from the\n            // block rule: at the root level.\n            //\n            primary: function () {\n                var mixin = this.mixin, root = [], node;\n\n                while (true) {\n                    while (true) {\n                        node = this.comment();\n                        if (!node) { break; }\n                        root.push(node);\n                    }\n                    // always process comments before deciding if finished\n                    if (parserInput.finished) {\n                        break;\n                    }\n                    if (parserInput.peek('}')) {\n                        break;\n                    }\n\n                    node = this.extendRule();\n                    if (node) {\n                        root = root.concat(node);\n                        continue;\n                    }\n\n                    node = mixin.definition() || this.rule() || this.ruleset() ||\n                        mixin.call() || this.rulesetCall() || this.entities.call() || this.directive();\n                    if (node) {\n                        root.push(node);\n                    } else {\n                        var foundSemiColon = false;\n                        while (parserInput.$char(\";\")) {\n                            foundSemiColon = true;\n                        }\n                        if (!foundSemiColon) {\n                            break;\n                        }\n                    }\n                }\n\n                return root;\n            },\n\n            // comments are collected by the main parsing mechanism and then assigned to nodes\n            // where the current structure allows it\n            comment: function () {\n                if (parserInput.commentStore.length) {\n                    var comment = parserInput.commentStore.shift();\n                    return new(tree.Comment)(comment.text, comment.isLineComment, comment.index, fileInfo);\n                }\n            },\n\n            //\n            // Entities are tokens which can be found inside an Expression\n            //\n            entities: {\n                //\n                // A string, which supports escaping \" and '\n                //\n                //     \"milky way\" 'he\\'s the one!'\n                //\n                quoted: function () {\n                    var str, index = parserInput.i, isEscaped = false;\n\n                    parserInput.save();\n                    if (parserInput.$char(\"~\")) {\n                        isEscaped = true;\n                    }\n                    str = parserInput.$quoted();\n                    if (!str) {\n                        parserInput.restore();\n                        return;\n                    }\n                    parserInput.forget();\n\n                    return new(tree.Quoted)(str.charAt(0), str.substr(1, str.length - 2), isEscaped, index, fileInfo);\n                },\n\n                //\n                // A catch-all word, such as:\n                //\n                //     black border-collapse\n                //\n                keyword: function () {\n                    var k = parserInput.$char(\"%\") || parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]*/);\n                    if (k) {\n                        return tree.Color.fromKeyword(k) || new(tree.Keyword)(k);\n                    }\n                },\n\n                //\n                // A function call\n                //\n                //     rgb(255, 0, 255)\n                //\n                // We also try to catch IE's `alpha()`, but let the `alpha` parser\n                // deal with the details.\n                //\n                // The arguments are parsed with the `entities.arguments` parser.\n                //\n                call: function () {\n                    var name, nameLC, args, alpha, index = parserInput.i;\n\n                    // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\n                    if (parserInput.peek(/^url\\(/i)) {\n                        return;\n                    }\n\n                    parserInput.save();\n\n                    name = parserInput.$re(/^([\\w-]+|%|progid:[\\w\\.]+)\\(/);\n                    if (!name) { parserInput.forget(); return; }\n\n                    name = name[1];\n                    nameLC = name.toLowerCase();\n\n                    if (nameLC === 'alpha') {\n                        alpha = parsers.alpha();\n                        if (alpha) {\n                            parserInput.forget();\n                            return alpha;\n                        }\n                    }\n\n                    args = this.arguments();\n\n                    if (! parserInput.$char(')')) {\n                        parserInput.restore(\"Could not parse call arguments or missing ')'\");\n                        return;\n                    }\n\n                    parserInput.forget();\n                    return new(tree.Call)(name, args, index, fileInfo);\n                },\n                arguments: function () {\n                    var argsSemiColon = [], argsComma = [],\n                        expressions = [],\n                        isSemiColonSeparated, value, arg;\n\n                    parserInput.save();\n\n                    while (true) {\n\n                        arg = parsers.detachedRuleset() || this.assignment() || parsers.expression();\n\n                        if (!arg) {\n                            break;\n                        }\n\n                        value = arg;\n\n                        if (arg.value && arg.value.length == 1) {\n                            value = arg.value[0];\n                        }\n\n                        if (value) {\n                            expressions.push(value);\n                        }\n\n                        argsComma.push(value);\n\n                        if (parserInput.$char(',')) {\n                            continue;\n                        }\n\n                        if (parserInput.$char(';') || isSemiColonSeparated) {\n\n                            isSemiColonSeparated = true;\n\n                            if (expressions.length > 1) {\n                                value = new(tree.Value)(expressions);\n                            }\n                            argsSemiColon.push(value);\n\n                            expressions = [];\n                        }\n                    }\n\n                    parserInput.forget();\n                    return isSemiColonSeparated ? argsSemiColon : argsComma;\n                },\n                literal: function () {\n                    return this.dimension() ||\n                           this.color() ||\n                           this.quoted() ||\n                           this.unicodeDescriptor();\n                },\n\n                // Assignments are argument entities for calls.\n                // They are present in ie filter properties as shown below.\n                //\n                //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )\n                //\n\n                assignment: function () {\n                    var key, value;\n                    parserInput.save();\n                    key = parserInput.$re(/^\\w+(?=\\s?=)/i);\n                    if (!key) {\n                        parserInput.restore();\n                        return;\n                    }\n                    if (!parserInput.$char('=')) {\n                        parserInput.restore();\n                        return;\n                    }\n                    value = parsers.entity();\n                    if (value) {\n                        parserInput.forget();\n                        return new(tree.Assignment)(key, value);\n                    } else {\n                        parserInput.restore();\n                    }\n                },\n\n                //\n                // Parse url() tokens\n                //\n                // We use a specific rule for urls, because they don't really behave like\n                // standard function calls. The difference is that the argument doesn't have\n                // to be enclosed within a string, so it can't be parsed as an Expression.\n                //\n                url: function () {\n                    var value, index = parserInput.i;\n\n                    parserInput.autoCommentAbsorb = false;\n\n                    if (!parserInput.$str(\"url(\")) {\n                        parserInput.autoCommentAbsorb = true;\n                        return;\n                    }\n\n                    value = this.quoted() || this.variable() ||\n                            parserInput.$re(/^(?:(?:\\\\[\\(\\)'\"])|[^\\(\\)'\"])+/) || \"\";\n\n                    parserInput.autoCommentAbsorb = true;\n\n                    expectChar(')');\n\n                    return new(tree.URL)((value.value != null || value instanceof tree.Variable) ?\n                                        value : new(tree.Anonymous)(value), index, fileInfo);\n                },\n\n                //\n                // A Variable entity, such as `@fink`, in\n                //\n                //     width: @fink + 2px\n                //\n                // We use a different parser for variable definitions,\n                // see `parsers.variable`.\n                //\n                variable: function () {\n                    var name, index = parserInput.i;\n\n                    if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^@@?[\\w-]+/))) {\n                        return new(tree.Variable)(name, index, fileInfo);\n                    }\n                },\n\n                // A variable entity using the protective {} e.g. @{var}\n                variableCurly: function () {\n                    var curly, index = parserInput.i;\n\n                    if (parserInput.currentChar() === '@' && (curly = parserInput.$re(/^@\\{([\\w-]+)\\}/))) {\n                        return new(tree.Variable)(\"@\" + curly[1], index, fileInfo);\n                    }\n                },\n\n                //\n                // A Hexadecimal color\n                //\n                //     #4F3C2F\n                //\n                // `rgb` and `hsl` colors are parsed through the `entities.call` parser.\n                //\n                color: function () {\n                    var rgb;\n\n                    if (parserInput.currentChar() === '#' && (rgb = parserInput.$re(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})/))) {\n                        // strip colons, brackets, whitespaces and other characters that should not\n                        // definitely be part of color string\n                        var colorCandidateString = rgb.input.match(/^#([\\w]+).*/);\n                        colorCandidateString = colorCandidateString[1];\n                        if (!colorCandidateString.match(/^[A-Fa-f0-9]+$/)) { // verify if candidate consists only of allowed HEX characters\n                            error(\"Invalid HEX color code\");\n                        }\n                        return new(tree.Color)(rgb[1], undefined, '#' + colorCandidateString);\n                    }\n                },\n\n                colorKeyword: function () {\n                    parserInput.save();\n                    var autoCommentAbsorb = parserInput.autoCommentAbsorb;\n                    parserInput.autoCommentAbsorb = false;\n                    var k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/);\n                    parserInput.autoCommentAbsorb = autoCommentAbsorb;\n                    if (!k) {\n                        parserInput.forget();\n                        return;\n                    }\n                    parserInput.restore();\n                    var color = tree.Color.fromKeyword(k);\n                    if (color) {\n                        parserInput.$str(k);\n                        return color;\n                    }\n                },\n\n                //\n                // A Dimension, that is, a number and a unit\n                //\n                //     0.5em 95%\n                //\n                dimension: function () {\n                    if (parserInput.peekNotNumeric()) {\n                        return;\n                    }\n\n                    var value = parserInput.$re(/^([+-]?\\d*\\.?\\d+)(%|[a-z_]+)?/i);\n                    if (value) {\n                        return new(tree.Dimension)(value[1], value[2]);\n                    }\n                },\n\n                //\n                // A unicode descriptor, as is used in unicode-range\n                //\n                // U+0??  or U+00A1-00A9\n                //\n                unicodeDescriptor: function () {\n                    var ud;\n\n                    ud = parserInput.$re(/^U\\+[0-9a-fA-F?]+(\\-[0-9a-fA-F?]+)?/);\n                    if (ud) {\n                        return new(tree.UnicodeDescriptor)(ud[0]);\n                    }\n                },\n\n                //\n                // JavaScript code to be evaluated\n                //\n                //     `window.location.href`\n                //\n                javascript: function () {\n                    var js, index = parserInput.i;\n\n                    parserInput.save();\n\n                    var escape = parserInput.$char(\"~\");\n                    var jsQuote = parserInput.$char(\"`\");\n\n                    if (!jsQuote) {\n                        parserInput.restore();\n                        return;\n                    }\n\n                    js = parserInput.$re(/^[^`]*`/);\n                    if (js) {\n                        parserInput.forget();\n                        return new(tree.JavaScript)(js.substr(0, js.length - 1), Boolean(escape), index, fileInfo);\n                    }\n                    parserInput.restore(\"invalid javascript definition\");\n                }\n            },\n\n            //\n            // The variable part of a variable definition. Used in the `rule` parser\n            //\n            //     @fink:\n            //\n            variable: function () {\n                var name;\n\n                if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\\w-]+)\\s*:/))) { return name[1]; }\n            },\n\n            //\n            // The variable part of a variable definition. Used in the `rule` parser\n            //\n            //     @fink();\n            //\n            rulesetCall: function () {\n                var name;\n\n                if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\\w-]+)\\(\\s*\\)\\s*;/))) {\n                    return new tree.RulesetCall(name[1]);\n                }\n            },\n\n            //\n            // extend syntax - used to extend selectors\n            //\n            extend: function(isRule) {\n                var elements, e, index = parserInput.i, option, extendList, extend;\n\n                if (!parserInput.$str(isRule ? \"&:extend(\" : \":extend(\")) {\n                    return;\n                }\n\n                do {\n                    option = null;\n                    elements = null;\n                    while (! (option = parserInput.$re(/^(all)(?=\\s*(\\)|,))/))) {\n                        e = this.element();\n                        if (!e) {\n                            break;\n                        }\n                        if (elements) {\n                            elements.push(e);\n                        } else {\n                            elements = [ e ];\n                        }\n                    }\n\n                    option = option && option[1];\n                    if (!elements) {\n                        error(\"Missing target selector for :extend().\");\n                    }\n                    extend = new(tree.Extend)(new(tree.Selector)(elements), option, index, fileInfo);\n                    if (extendList) {\n                        extendList.push(extend);\n                    } else {\n                        extendList = [ extend ];\n                    }\n                } while (parserInput.$char(\",\"));\n\n                expect(/^\\)/);\n\n                if (isRule) {\n                    expect(/^;/);\n                }\n\n                return extendList;\n            },\n\n            //\n            // extendRule - used in a rule to extend all the parent selectors\n            //\n            extendRule: function() {\n                return this.extend(true);\n            },\n\n            //\n            // Mixins\n            //\n            mixin: {\n                //\n                // A Mixin call, with an optional argument list\n                //\n                //     #mixins > .square(#fff);\n                //     .rounded(4px, black);\n                //     .button;\n                //\n                // The `while` loop is there because mixins can be\n                // namespaced, but we only support the child and descendant\n                // selector for now.\n                //\n                call: function () {\n                    var s = parserInput.currentChar(), important = false, index = parserInput.i, elemIndex,\n                        elements, elem, e, c, args;\n\n                    if (s !== '.' && s !== '#') { return; }\n\n                    parserInput.save(); // stop us absorbing part of an invalid selector\n\n                    while (true) {\n                        elemIndex = parserInput.i;\n                        e = parserInput.$re(/^[#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/);\n                        if (!e) {\n                            break;\n                        }\n                        elem = new(tree.Element)(c, e, elemIndex, fileInfo);\n                        if (elements) {\n                            elements.push(elem);\n                        } else {\n                            elements = [ elem ];\n                        }\n                        c = parserInput.$char('>');\n                    }\n\n                    if (elements) {\n                        if (parserInput.$char('(')) {\n                            args = this.args(true).args;\n                            expectChar(')');\n                        }\n\n                        if (parsers.important()) {\n                            important = true;\n                        }\n\n                        if (parsers.end()) {\n                            parserInput.forget();\n                            return new(tree.mixin.Call)(elements, args, index, fileInfo, important);\n                        }\n                    }\n\n                    parserInput.restore();\n                },\n                args: function (isCall) {\n                    var entities = parsers.entities,\n                        returner = { args:null, variadic: false },\n                        expressions = [], argsSemiColon = [], argsComma = [],\n                        isSemiColonSeparated, expressionContainsNamed, name, nameLoop,\n                        value, arg, expand;\n\n                    parserInput.save();\n\n                    while (true) {\n                        if (isCall) {\n                            arg = parsers.detachedRuleset() || parsers.expression();\n                        } else {\n                            parserInput.commentStore.length = 0;\n                            if (parserInput.$str(\"...\")) {\n                                returner.variadic = true;\n                                if (parserInput.$char(\";\") && !isSemiColonSeparated) {\n                                    isSemiColonSeparated = true;\n                                }\n                                (isSemiColonSeparated ? argsSemiColon : argsComma)\n                                    .push({ variadic: true });\n                                break;\n                            }\n                            arg = entities.variable() || entities.literal() || entities.keyword();\n                        }\n\n                        if (!arg) {\n                            break;\n                        }\n\n                        nameLoop = null;\n                        if (arg.throwAwayComments) {\n                            arg.throwAwayComments();\n                        }\n                        value = arg;\n                        var val = null;\n\n                        if (isCall) {\n                            // Variable\n                            if (arg.value && arg.value.length == 1) {\n                                val = arg.value[0];\n                            }\n                        } else {\n                            val = arg;\n                        }\n\n                        if (val && val instanceof tree.Variable) {\n                            if (parserInput.$char(':')) {\n                                if (expressions.length > 0) {\n                                    if (isSemiColonSeparated) {\n                                        error(\"Cannot mix ; and , as delimiter types\");\n                                    }\n                                    expressionContainsNamed = true;\n                                }\n\n                                value = parsers.detachedRuleset() || parsers.expression();\n\n                                if (!value) {\n                                    if (isCall) {\n                                        error(\"could not understand value for named argument\");\n                                    } else {\n                                        parserInput.restore();\n                                        returner.args = [];\n                                        return returner;\n                                    }\n                                }\n                                nameLoop = (name = val.name);\n                            } else if (parserInput.$str(\"...\")) {\n                                if (!isCall) {\n                                    returner.variadic = true;\n                                    if (parserInput.$char(\";\") && !isSemiColonSeparated) {\n                                        isSemiColonSeparated = true;\n                                    }\n                                    (isSemiColonSeparated ? argsSemiColon : argsComma)\n                                        .push({ name: arg.name, variadic: true });\n                                    break;\n                                } else {\n                                    expand = true;\n                                }\n                            } else if (!isCall) {\n                                name = nameLoop = val.name;\n                                value = null;\n                            }\n                        }\n\n                        if (value) {\n                            expressions.push(value);\n                        }\n\n                        argsComma.push({ name:nameLoop, value:value, expand:expand });\n\n                        if (parserInput.$char(',')) {\n                            continue;\n                        }\n\n                        if (parserInput.$char(';') || isSemiColonSeparated) {\n\n                            if (expressionContainsNamed) {\n                                error(\"Cannot mix ; and , as delimiter types\");\n                            }\n\n                            isSemiColonSeparated = true;\n\n                            if (expressions.length > 1) {\n                                value = new(tree.Value)(expressions);\n                            }\n                            argsSemiColon.push({ name:name, value:value, expand:expand });\n\n                            name = null;\n                            expressions = [];\n                            expressionContainsNamed = false;\n                        }\n                    }\n\n                    parserInput.forget();\n                    returner.args = isSemiColonSeparated ? argsSemiColon : argsComma;\n                    return returner;\n                },\n                //\n                // A Mixin definition, with a list of parameters\n                //\n                //     .rounded (@radius: 2px, @color) {\n                //        ...\n                //     }\n                //\n                // Until we have a finer grained state-machine, we have to\n                // do a look-ahead, to make sure we don't have a mixin call.\n                // See the `rule` function for more information.\n                //\n                // We start by matching `.rounded (`, and then proceed on to\n                // the argument list, which has optional default values.\n                // We store the parameters in `params`, with a `value` key,\n                // if there is a value, such as in the case of `@radius`.\n                //\n                // Once we've got our params list, and a closing `)`, we parse\n                // the `{...}` block.\n                //\n                definition: function () {\n                    var name, params = [], match, ruleset, cond, variadic = false;\n                    if ((parserInput.currentChar() !== '.' && parserInput.currentChar() !== '#') ||\n                        parserInput.peek(/^[^{]*\\}/)) {\n                        return;\n                    }\n\n                    parserInput.save();\n\n                    match = parserInput.$re(/^([#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\\s*\\(/);\n                    if (match) {\n                        name = match[1];\n\n                        var argInfo = this.args(false);\n                        params = argInfo.args;\n                        variadic = argInfo.variadic;\n\n                        // .mixincall(\"@{a}\");\n                        // looks a bit like a mixin definition..\n                        // also\n                        // .mixincall(@a: {rule: set;});\n                        // so we have to be nice and restore\n                        if (!parserInput.$char(')')) {\n                            parserInput.restore(\"Missing closing ')'\");\n                            return;\n                        }\n\n                        parserInput.commentStore.length = 0;\n\n                        if (parserInput.$str(\"when\")) { // Guard\n                            cond = expect(parsers.conditions, 'expected condition');\n                        }\n\n                        ruleset = parsers.block();\n\n                        if (ruleset) {\n                            parserInput.forget();\n                            return new(tree.mixin.Definition)(name, params, ruleset, cond, variadic);\n                        } else {\n                            parserInput.restore();\n                        }\n                    } else {\n                        parserInput.forget();\n                    }\n                }\n            },\n\n            //\n            // Entities are the smallest recognized token,\n            // and can be found inside a rule's value.\n            //\n            entity: function () {\n                var entities = this.entities;\n\n                return this.comment() || entities.literal() || entities.variable() || entities.url() ||\n                       entities.call()    || entities.keyword()  || entities.javascript();\n            },\n\n            //\n            // A Rule terminator. Note that we use `peek()` to check for '}',\n            // because the `block` rule will be expecting it, but we still need to make sure\n            // it's there, if ';' was omitted.\n            //\n            end: function () {\n                return parserInput.$char(';') || parserInput.peek('}');\n            },\n\n            //\n            // IE's alpha function\n            //\n            //     alpha(opacity=88)\n            //\n            alpha: function () {\n                var value;\n\n                // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\n                if (! parserInput.$re(/^opacity=/i)) { return; }\n                value = parserInput.$re(/^\\d+/);\n                if (!value) {\n                    value = expect(this.entities.variable, \"Could not parse alpha\");\n                }\n                expectChar(')');\n                return new(tree.Alpha)(value);\n            },\n\n            //\n            // A Selector Element\n            //\n            //     div\n            //     + h1\n            //     #socks\n            //     input[type=\"text\"]\n            //\n            // Elements are the building blocks for Selectors,\n            // they are made out of a `Combinator` (see combinator rule),\n            // and an element name, such as a tag a class, or `*`.\n            //\n            element: function () {\n                var e, c, v, index = parserInput.i;\n\n                c = this.combinator();\n\n                e = parserInput.$re(/^(?:\\d+\\.\\d+|\\d+)%/) ||\n                    parserInput.$re(/^(?:[.#]?|:*)(?:[\\w-]|[^\\x00-\\x9f]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) ||\n                    parserInput.$char('*') || parserInput.$char('&') || this.attribute() ||\n                    parserInput.$re(/^\\([^&()@]+\\)/) ||  parserInput.$re(/^[\\.#:](?=@)/) ||\n                    this.entities.variableCurly();\n\n                if (! e) {\n                    parserInput.save();\n                    if (parserInput.$char('(')) {\n                        if ((v = this.selector()) && parserInput.$char(')')) {\n                            e = new(tree.Paren)(v);\n                            parserInput.forget();\n                        } else {\n                            parserInput.restore(\"Missing closing ')'\");\n                        }\n                    } else {\n                        parserInput.forget();\n                    }\n                }\n\n                if (e) { return new(tree.Element)(c, e, index, fileInfo); }\n            },\n\n            //\n            // Combinators combine elements together, in a Selector.\n            //\n            // Because our parser isn't white-space sensitive, special care\n            // has to be taken, when parsing the descendant combinator, ` `,\n            // as it's an empty space. We have to check the previous character\n            // in the input, to see if it's a ` ` character. More info on how\n            // we deal with this in *combinator.js*.\n            //\n            combinator: function () {\n                var c = parserInput.currentChar();\n\n                if (c === '/') {\n                    parserInput.save();\n                    var slashedCombinator = parserInput.$re(/^\\/[a-z]+\\//i);\n                    if (slashedCombinator) {\n                        parserInput.forget();\n                        return new(tree.Combinator)(slashedCombinator);\n                    }\n                    parserInput.restore();\n                }\n\n                if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {\n                    parserInput.i++;\n                    if (c === '^' && parserInput.currentChar() === '^') {\n                        c = '^^';\n                        parserInput.i++;\n                    }\n                    while (parserInput.isWhitespace()) { parserInput.i++; }\n                    return new(tree.Combinator)(c);\n                } else if (parserInput.isWhitespace(-1)) {\n                    return new(tree.Combinator)(\" \");\n                } else {\n                    return new(tree.Combinator)(null);\n                }\n            },\n            //\n            // A CSS selector (see selector below)\n            // with less extensions e.g. the ability to extend and guard\n            //\n            lessSelector: function () {\n                return this.selector(true);\n            },\n            //\n            // A CSS Selector\n            //\n            //     .class > div + h1\n            //     li a:hover\n            //\n            // Selectors are made out of one or more Elements, see above.\n            //\n            selector: function (isLess) {\n                var index = parserInput.i, elements, extendList, c, e, allExtends, when, condition;\n\n                while ((isLess && (extendList = this.extend())) || (isLess && (when = parserInput.$str(\"when\"))) || (e = this.element())) {\n                    if (when) {\n                        condition = expect(this.conditions, 'expected condition');\n                    } else if (condition) {\n                        error(\"CSS guard can only be used at the end of selector\");\n                    } else if (extendList) {\n                        if (allExtends) {\n                            allExtends = allExtends.concat(extendList);\n                        } else {\n                            allExtends = extendList;\n                        }\n                    } else {\n                        if (allExtends) { error(\"Extend can only be used at the end of selector\"); }\n                        c = parserInput.currentChar();\n                        if (elements) {\n                            elements.push(e);\n                        } else {\n                            elements = [ e ];\n                        }\n                        e = null;\n                    }\n                    if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {\n                        break;\n                    }\n                }\n\n                if (elements) { return new(tree.Selector)(elements, allExtends, condition, index, fileInfo); }\n                if (allExtends) { error(\"Extend must be used to extend a selector, it cannot be used on its own\"); }\n            },\n            attribute: function () {\n                if (! parserInput.$char('[')) { return; }\n\n                var entities = this.entities,\n                    key, val, op;\n\n                if (!(key = entities.variableCurly())) {\n                    key = expect(/^(?:[_A-Za-z0-9-\\*]*\\|)?(?:[_A-Za-z0-9-]|\\\\.)+/);\n                }\n\n                op = parserInput.$re(/^[|~*$^]?=/);\n                if (op) {\n                    val = entities.quoted() || parserInput.$re(/^[0-9]+%/) || parserInput.$re(/^[\\w-]+/) || entities.variableCurly();\n                }\n\n                expectChar(']');\n\n                return new(tree.Attribute)(key, op, val);\n            },\n\n            //\n            // The `block` rule is used by `ruleset` and `mixin.definition`.\n            // It's a wrapper around the `primary` rule, with added `{}`.\n            //\n            block: function () {\n                var content;\n                if (parserInput.$char('{') && (content = this.primary()) && parserInput.$char('}')) {\n                    return content;\n                }\n            },\n\n            blockRuleset: function() {\n                var block = this.block();\n\n                if (block) {\n                    block = new tree.Ruleset(null, block);\n                }\n                return block;\n            },\n\n            detachedRuleset: function() {\n                var blockRuleset = this.blockRuleset();\n                if (blockRuleset) {\n                    return new tree.DetachedRuleset(blockRuleset);\n                }\n            },\n\n            //\n            // div, .class, body > p {...}\n            //\n            ruleset: function () {\n                var selectors, s, rules, debugInfo;\n\n                parserInput.save();\n\n                if (context.dumpLineNumbers) {\n                    debugInfo = getDebugInfo(parserInput.i);\n                }\n\n                while (true) {\n                    s = this.lessSelector();\n                    if (!s) {\n                        break;\n                    }\n                    if (selectors) {\n                        selectors.push(s);\n                    } else {\n                        selectors = [ s ];\n                    }\n                    parserInput.commentStore.length = 0;\n                    if (s.condition && selectors.length > 1) {\n                        error(\"Guards are only currently allowed on a single selector.\");\n                    }\n                    if (! parserInput.$char(',')) { break; }\n                    if (s.condition) {\n                        error(\"Guards are only currently allowed on a single selector.\");\n                    }\n                    parserInput.commentStore.length = 0;\n                }\n\n                if (selectors && (rules = this.block())) {\n                    parserInput.forget();\n                    var ruleset = new(tree.Ruleset)(selectors, rules, context.strictImports);\n                    if (context.dumpLineNumbers) {\n                        ruleset.debugInfo = debugInfo;\n                    }\n                    return ruleset;\n                } else {\n                    parserInput.restore();\n                }\n            },\n            rule: function (tryAnonymous) {\n                var name, value, startOfRule = parserInput.i, c = parserInput.currentChar(), important, merge, isVariable;\n\n                if (c === '.' || c === '#' || c === '&' || c === ':') { return; }\n\n                parserInput.save();\n\n                name = this.variable() || this.ruleProperty();\n                if (name) {\n                    isVariable = typeof name === \"string\";\n\n                    if (isVariable) {\n                        value = this.detachedRuleset();\n                    }\n\n                    parserInput.commentStore.length = 0;\n                    if (!value) {\n                        // a name returned by this.ruleProperty() is always an array of the form:\n                        // [string-1, ..., string-n, \"\"] or [string-1, ..., string-n, \"+\"]\n                        // where each item is a tree.Keyword or tree.Variable\n                        merge = !isVariable && name.length > 1 && name.pop().value;\n\n                        // prefer to try to parse first if its a variable or we are compressing\n                        // but always fallback on the other one\n                        var tryValueFirst = !tryAnonymous && (context.compress || isVariable);\n\n                        if (tryValueFirst) {\n                            value = this.value();\n                        }\n                        if (!value) {\n                            value = this.anonymousValue();\n                            if (value) {\n                                parserInput.forget();\n                                // anonymous values absorb the end ';' which is required for them to work\n                                return new (tree.Rule)(name, value, false, merge, startOfRule, fileInfo);\n                            }\n                        }\n                        if (!tryValueFirst && !value) {\n                            value = this.value();\n                        }\n\n                        important = this.important();\n                    }\n\n                    if (value && this.end()) {\n                        parserInput.forget();\n                        return new (tree.Rule)(name, value, important, merge, startOfRule, fileInfo);\n                    } else {\n                        parserInput.restore();\n                        if (value && !tryAnonymous) {\n                            return this.rule(true);\n                        }\n                    }\n                } else {\n                    parserInput.forget();\n                }\n            },\n            anonymousValue: function () {\n                var match = parserInput.$re(/^([^@+\\/'\"*`(;{}-]*);/);\n                if (match) {\n                    return new(tree.Anonymous)(match[1]);\n                }\n            },\n\n            //\n            // An @import directive\n            //\n            //     @import \"lib\";\n            //\n            // Depending on our environment, importing is done differently:\n            // In the browser, it's an XHR request, in Node, it would be a\n            // file-system operation. The function used for importing is\n            // stored in `import`, which we pass to the Import constructor.\n            //\n            \"import\": function () {\n                var path, features, index = parserInput.i;\n\n                var dir = parserInput.$re(/^@import?\\s+/);\n\n                if (dir) {\n                    var options = (dir ? this.importOptions() : null) || {};\n\n                    if ((path = this.entities.quoted() || this.entities.url())) {\n                        features = this.mediaFeatures();\n\n                        if (!parserInput.$char(';')) {\n                            parserInput.i = index;\n                            error(\"missing semi-colon or unrecognised media features on import\");\n                        }\n                        features = features && new(tree.Value)(features);\n                        return new(tree.Import)(path, features, options, index, fileInfo);\n                    }\n                    else {\n                        parserInput.i = index;\n                        error(\"malformed import statement\");\n                    }\n                }\n            },\n\n            importOptions: function() {\n                var o, options = {}, optionName, value;\n\n                // list of options, surrounded by parens\n                if (! parserInput.$char('(')) { return null; }\n                do {\n                    o = this.importOption();\n                    if (o) {\n                        optionName = o;\n                        value = true;\n                        switch(optionName) {\n                            case \"css\":\n                                optionName = \"less\";\n                                value = false;\n                                break;\n                            case \"once\":\n                                optionName = \"multiple\";\n                                value = false;\n                                break;\n                        }\n                        options[optionName] = value;\n                        if (! parserInput.$char(',')) { break; }\n                    }\n                } while (o);\n                expectChar(')');\n                return options;\n            },\n\n            importOption: function() {\n                var opt = parserInput.$re(/^(less|css|multiple|once|inline|reference|optional)/);\n                if (opt) {\n                    return opt[1];\n                }\n            },\n\n            mediaFeature: function () {\n                var entities = this.entities, nodes = [], e, p;\n                parserInput.save();\n                do {\n                    e = entities.keyword() || entities.variable();\n                    if (e) {\n                        nodes.push(e);\n                    } else if (parserInput.$char('(')) {\n                        p = this.property();\n                        e = this.value();\n                        if (parserInput.$char(')')) {\n                            if (p && e) {\n                                nodes.push(new(tree.Paren)(new(tree.Rule)(p, e, null, null, parserInput.i, fileInfo, true)));\n                            } else if (e) {\n                                nodes.push(new(tree.Paren)(e));\n                            } else {\n                                error(\"badly formed media feature definition\");\n                            }\n                        } else {\n                            error(\"Missing closing ')'\", \"Parse\");\n                        }\n                    }\n                } while (e);\n\n                parserInput.forget();\n                if (nodes.length > 0) {\n                    return new(tree.Expression)(nodes);\n                }\n            },\n\n            mediaFeatures: function () {\n                var entities = this.entities, features = [], e;\n                do {\n                    e = this.mediaFeature();\n                    if (e) {\n                        features.push(e);\n                        if (! parserInput.$char(',')) { break; }\n                    } else {\n                        e = entities.variable();\n                        if (e) {\n                            features.push(e);\n                            if (! parserInput.$char(',')) { break; }\n                        }\n                    }\n                } while (e);\n\n                return features.length > 0 ? features : null;\n            },\n\n            media: function () {\n                var features, rules, media, debugInfo, index = parserInput.i;\n\n                if (context.dumpLineNumbers) {\n                    debugInfo = getDebugInfo(index);\n                }\n\n                parserInput.save();\n\n                if (parserInput.$str(\"@media\")) {\n                    features = this.mediaFeatures();\n\n                    rules = this.block();\n\n                    if (!rules) {\n                        error(\"media definitions require block statements after any features\");\n                    }\n\n                    parserInput.forget();\n\n                    media = new(tree.Media)(rules, features, index, fileInfo);\n                    if (context.dumpLineNumbers) {\n                        media.debugInfo = debugInfo;\n                    }\n\n                    return media;\n                }\n\n                parserInput.restore();\n            },\n\n            //\n            // A @plugin directive, used to import compiler extensions dynamically.\n            //\n            //     @plugin \"lib\";\n            //\n            // Depending on our environment, importing is done differently:\n            // In the browser, it's an XHR request, in Node, it would be a\n            // file-system operation. The function used for importing is\n            // stored in `import`, which we pass to the Import constructor.\n            //\n            plugin: function () {\n                var path,\n                    index = parserInput.i,\n                    dir   = parserInput.$re(/^@plugin?\\s+/);\n\n                if (dir) {\n                    var options = { plugin : true };\n\n                    if ((path = this.entities.quoted() || this.entities.url())) {\n\n                        if (!parserInput.$char(';')) {\n                            parserInput.i = index;\n                            error(\"missing semi-colon on plugin\");\n                        }\n\n                        return new(tree.Import)(path, null, options, index, fileInfo);\n                    }\n                    else {\n                        parserInput.i = index;\n                        error(\"malformed plugin statement\");\n                    }\n                }\n            },\n\n            //\n            // A CSS Directive\n            //\n            //     @charset \"utf-8\";\n            //\n            directive: function () {\n                var index = parserInput.i, name, value, rules, nonVendorSpecificName,\n                    hasIdentifier, hasExpression, hasUnknown, hasBlock = true, isRooted = true;\n\n                if (parserInput.currentChar() !== '@') { return; }\n\n                value = this['import']() || this.plugin() || this.media();\n                if (value) {\n                    return value;\n                }\n\n                parserInput.save();\n\n                name = parserInput.$re(/^@[a-z-]+/);\n\n                if (!name) { return; }\n\n                nonVendorSpecificName = name;\n                if (name.charAt(1) == '-' && name.indexOf('-', 2) > 0) {\n                    nonVendorSpecificName = \"@\" + name.slice(name.indexOf('-', 2) + 1);\n                }\n\n                switch(nonVendorSpecificName) {\n                    case \"@charset\":\n                        hasIdentifier = true;\n                        hasBlock = false;\n                        break;\n                    case \"@namespace\":\n                        hasExpression = true;\n                        hasBlock = false;\n                        break;\n                    case \"@keyframes\":\n                    case \"@counter-style\":\n                        hasIdentifier = true;\n                        break;\n                    case \"@document\":\n                    case \"@supports\":\n                        hasUnknown = true;\n                        isRooted = false;\n                        break;\n                    default:\n                        hasUnknown = true;\n                        break;\n                }\n\n                parserInput.commentStore.length = 0;\n\n                if (hasIdentifier) {\n                    value = this.entity();\n                    if (!value) {\n                        error(\"expected \" + name + \" identifier\");\n                    }\n                } else if (hasExpression) {\n                    value = this.expression();\n                    if (!value) {\n                        error(\"expected \" + name + \" expression\");\n                    }\n                } else if (hasUnknown) {\n                    value = (parserInput.$re(/^[^{;]+/) || '').trim();\n                    hasBlock = (parserInput.currentChar() == '{');\n                    if (value) {\n                        value = new(tree.Anonymous)(value);\n                    }\n                }\n\n                if (hasBlock) {\n                    rules = this.blockRuleset();\n                }\n\n                if (rules || (!hasBlock && value && parserInput.$char(';'))) {\n                    parserInput.forget();\n                    return new (tree.Directive)(name, value, rules, index, fileInfo,\n                        context.dumpLineNumbers ? getDebugInfo(index) : null,\n                        isRooted\n                    );\n                }\n\n                parserInput.restore(\"directive options not recognised\");\n            },\n\n            //\n            // A Value is a comma-delimited list of Expressions\n            //\n            //     font-family: Baskerville, Georgia, serif;\n            //\n            // In a Rule, a Value represents everything after the `:`,\n            // and before the `;`.\n            //\n            value: function () {\n                var e, expressions = [];\n\n                do {\n                    e = this.expression();\n                    if (e) {\n                        expressions.push(e);\n                        if (! parserInput.$char(',')) { break; }\n                    }\n                } while (e);\n\n                if (expressions.length > 0) {\n                    return new(tree.Value)(expressions);\n                }\n            },\n            important: function () {\n                if (parserInput.currentChar() === '!') {\n                    return parserInput.$re(/^! *important/);\n                }\n            },\n            sub: function () {\n                var a, e;\n\n                parserInput.save();\n                if (parserInput.$char('(')) {\n                    a = this.addition();\n                    if (a && parserInput.$char(')')) {\n                        parserInput.forget();\n                        e = new(tree.Expression)([a]);\n                        e.parens = true;\n                        return e;\n                    }\n                    parserInput.restore(\"Expected ')'\");\n                    return;\n                }\n                parserInput.restore();\n            },\n            multiplication: function () {\n                var m, a, op, operation, isSpaced;\n                m = this.operand();\n                if (m) {\n                    isSpaced = parserInput.isWhitespace(-1);\n                    while (true) {\n                        if (parserInput.peek(/^\\/[*\\/]/)) {\n                            break;\n                        }\n\n                        parserInput.save();\n\n                        op = parserInput.$char('/') || parserInput.$char('*');\n\n                        if (!op) { parserInput.forget(); break; }\n\n                        a = this.operand();\n\n                        if (!a) { parserInput.restore(); break; }\n                        parserInput.forget();\n\n                        m.parensInOp = true;\n                        a.parensInOp = true;\n                        operation = new(tree.Operation)(op, [operation || m, a], isSpaced);\n                        isSpaced = parserInput.isWhitespace(-1);\n                    }\n                    return operation || m;\n                }\n            },\n            addition: function () {\n                var m, a, op, operation, isSpaced;\n                m = this.multiplication();\n                if (m) {\n                    isSpaced = parserInput.isWhitespace(-1);\n                    while (true) {\n                        op = parserInput.$re(/^[-+]\\s+/) || (!isSpaced && (parserInput.$char('+') || parserInput.$char('-')));\n                        if (!op) {\n                            break;\n                        }\n                        a = this.multiplication();\n                        if (!a) {\n                            break;\n                        }\n\n                        m.parensInOp = true;\n                        a.parensInOp = true;\n                        operation = new(tree.Operation)(op, [operation || m, a], isSpaced);\n                        isSpaced = parserInput.isWhitespace(-1);\n                    }\n                    return operation || m;\n                }\n            },\n            conditions: function () {\n                var a, b, index = parserInput.i, condition;\n\n                a = this.condition();\n                if (a) {\n                    while (true) {\n                        if (!parserInput.peek(/^,\\s*(not\\s*)?\\(/) || !parserInput.$char(',')) {\n                            break;\n                        }\n                        b = this.condition();\n                        if (!b) {\n                            break;\n                        }\n                        condition = new(tree.Condition)('or', condition || a, b, index);\n                    }\n                    return condition || a;\n                }\n            },\n            condition: function () {\n                var result, logical, next;\n                function or() {\n                    return parserInput.$str(\"or\");\n                }\n\n                result = this.conditionAnd(this);\n                if (!result) {\n                    return ;\n                }\n                logical = or();\n                if (logical) {\n                    next = this.condition();\n                    if (next) {\n                        result = new(tree.Condition)(logical, result, next);\n                    } else {\n                        return ;\n                    }\n                }\n                return result;\n            },\n            conditionAnd: function () {\n                var result, logical, next;\n                function insideCondition(me) {\n                    return me.negatedCondition() || me.parenthesisCondition();\n                }\n                function and() {\n                    return parserInput.$str(\"and\");\n                }\n\n                result = insideCondition(this);\n                if (!result) {\n                    return ;\n                }\n                logical = and();\n                if (logical) {\n                    next = this.conditionAnd();\n                    if (next) {\n                        result = new(tree.Condition)(logical, result, next);\n                    } else {\n                        return ;\n                    }\n                }\n                return result;\n            },\n            negatedCondition: function () {\n                if (parserInput.$str(\"not\")) {\n                    var result = this.parenthesisCondition();\n                    if (result) {\n                        result.negate = !result.negate;\n                    }\n                    return result;\n                }\n            },\n            parenthesisCondition: function () {\n                function tryConditionFollowedByParenthesis(me) {\n                    var body;\n                    parserInput.save();\n                    body = me.condition();\n                    if (!body) {\n                        parserInput.restore();\n                        return ;\n                    }\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore();\n                        return ;\n                    }\n                    parserInput.forget();\n                    return body;\n                }\n\n                var body;\n                parserInput.save();\n                if (!parserInput.$str(\"(\")) {\n                    parserInput.restore();\n                    return ;\n                }\n                body = tryConditionFollowedByParenthesis(this);\n                if (body) {\n                    parserInput.forget();\n                    return body;\n                }\n\n                body = this.atomicCondition();\n                if (!body) {\n                    parserInput.restore();\n                    return ;\n                }\n                if (!parserInput.$char(')')) {\n                    parserInput.restore(\"expected ')' got '\" + parserInput.currentChar() + \"'\");\n                    return ;\n                }\n                parserInput.forget();\n                return body;\n            },\n            atomicCondition: function () {\n                var entities = this.entities, index = parserInput.i, a, b, c, op;\n\n                a = this.addition() || entities.keyword() || entities.quoted();\n                if (a) {\n                    if (parserInput.$char('>')) {\n                        if (parserInput.$char('=')) {\n                            op = \">=\";\n                        } else {\n                            op = '>';\n                        }\n                    } else\n                    if (parserInput.$char('<')) {\n                        if (parserInput.$char('=')) {\n                            op = \"<=\";\n                        } else {\n                            op = '<';\n                        }\n                    } else\n                    if (parserInput.$char('=')) {\n                        if (parserInput.$char('>')) {\n                            op = \"=>\";\n                        } else if (parserInput.$char('<')) {\n                            op = '=<';\n                        } else {\n                            op = '=';\n                        }\n                    }\n                    if (op) {\n                        b = this.addition() || entities.keyword() || entities.quoted();\n                        if (b) {\n                            c = new(tree.Condition)(op, a, b, index, false);\n                        } else {\n                            error('expected expression');\n                        }\n                    } else {\n                        c = new(tree.Condition)('=', a, new(tree.Keyword)('true'), index, false);\n                    }\n                    return c;\n                }\n            },\n\n            //\n            // An operand is anything that can be part of an operation,\n            // such as a Color, or a Variable\n            //\n            operand: function () {\n                var entities = this.entities, negate;\n\n                if (parserInput.peek(/^-[@\\(]/)) {\n                    negate = parserInput.$char('-');\n                }\n\n                var o = this.sub() || entities.dimension() ||\n                        entities.color() || entities.variable() ||\n                        entities.call() || entities.colorKeyword();\n\n                if (negate) {\n                    o.parensInOp = true;\n                    o = new(tree.Negative)(o);\n                }\n\n                return o;\n            },\n\n            //\n            // Expressions either represent mathematical operations,\n            // or white-space delimited Entities.\n            //\n            //     1px solid black\n            //     @var * 2\n            //\n            expression: function () {\n                var entities = [], e, delim;\n\n                do {\n                    e = this.comment();\n                    if (e) {\n                        entities.push(e);\n                        continue;\n                    }\n                    e = this.addition() || this.entity();\n                    if (e) {\n                        entities.push(e);\n                        // operations do not allow keyword \"/\" dimension (e.g. small/20px) so we support that here\n                        if (!parserInput.peek(/^\\/[\\/*]/)) {\n                            delim = parserInput.$char('/');\n                            if (delim) {\n                                entities.push(new(tree.Anonymous)(delim));\n                            }\n                        }\n                    }\n                } while (e);\n                if (entities.length > 0) {\n                    return new(tree.Expression)(entities);\n                }\n            },\n            property: function () {\n                var name = parserInput.$re(/^(\\*?-?[_a-zA-Z0-9-]+)\\s*:/);\n                if (name) {\n                    return name[1];\n                }\n            },\n            ruleProperty: function () {\n                var name = [], index = [], s, k;\n\n                parserInput.save();\n\n                var simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\\s*:/);\n                if (simpleProperty) {\n                    name = [new(tree.Keyword)(simpleProperty[1])];\n                    parserInput.forget();\n                    return name;\n                }\n\n                function match(re) {\n                    var i = parserInput.i,\n                        chunk = parserInput.$re(re);\n                    if (chunk) {\n                        index.push(i);\n                        return name.push(chunk[1]);\n                    }\n                }\n\n                match(/^(\\*?)/);\n                while (true) {\n                    if (!match(/^((?:[\\w-]+)|(?:@\\{[\\w-]+\\}))/)) {\n                        break;\n                    }\n                }\n\n                if ((name.length > 1) && match(/^((?:\\+_|\\+)?)\\s*:/)) {\n                    parserInput.forget();\n\n                    // at last, we have the complete match now. move forward,\n                    // convert name particles to tree objects and return:\n                    if (name[0] === '') {\n                        name.shift();\n                        index.shift();\n                    }\n                    for (k = 0; k < name.length; k++) {\n                        s = name[k];\n                        name[k] = (s.charAt(0) !== '@') ?\n                            new(tree.Keyword)(s) :\n                            new(tree.Variable)('@' + s.slice(2, -1),\n                                index[k], fileInfo);\n                    }\n                    return name;\n                }\n                parserInput.restore();\n            }\n        }\n    };\n};\nParser.serializeVars = function(vars) {\n    var s = '';\n\n    for (var name in vars) {\n        if (Object.hasOwnProperty.call(vars, name)) {\n            var value = vars[name];\n            s += ((name[0] === '@') ? '' : '@') + name + ': ' + value +\n                ((String(value).slice(-1) === ';') ? '' : ';');\n        }\n    }\n\n    return s;\n};\n\nmodule.exports = Parser;\n\n},{\"../less-error\":32,\"../tree\":62,\"../utils\":83,\"../visitors\":87,\"./parser-input\":37}],39:[function(require,module,exports){\n/**\n * Plugin Manager\n */\nvar PluginManager = function(less) {\n    this.less = less;\n    this.visitors = [];\n    this.preProcessors = [];\n    this.postProcessors = [];\n    this.installedPlugins = [];\n    this.fileManagers = [];\n};\n/**\n * Adds all the plugins in the array\n * @param {Array} plugins\n */\nPluginManager.prototype.addPlugins = function(plugins) {\n    if (plugins) {\n        for (var i = 0; i < plugins.length; i++) {\n            this.addPlugin(plugins[i]);\n        }\n    }\n};\n/**\n *\n * @param plugin\n */\nPluginManager.prototype.addPlugin = function(plugin) {\n    this.installedPlugins.push(plugin);\n    plugin.install(this.less, this);\n};\n/**\n * Adds a visitor. The visitor object has options on itself to determine\n * when it should run.\n * @param visitor\n */\nPluginManager.prototype.addVisitor = function(visitor) {\n    this.visitors.push(visitor);\n};\n/**\n * Adds a pre processor object\n * @param {object} preProcessor\n * @param {number} priority - guidelines 1 = before import, 1000 = import, 2000 = after import\n */\nPluginManager.prototype.addPreProcessor = function(preProcessor, priority) {\n    var indexToInsertAt;\n    for (indexToInsertAt = 0; indexToInsertAt < this.preProcessors.length; indexToInsertAt++) {\n        if (this.preProcessors[indexToInsertAt].priority >= priority) {\n            break;\n        }\n    }\n    this.preProcessors.splice(indexToInsertAt, 0, {preProcessor: preProcessor, priority: priority});\n};\n/**\n * Adds a post processor object\n * @param {object} postProcessor\n * @param {number} priority - guidelines 1 = before compression, 1000 = compression, 2000 = after compression\n */\nPluginManager.prototype.addPostProcessor = function(postProcessor, priority) {\n    var indexToInsertAt;\n    for (indexToInsertAt = 0; indexToInsertAt < this.postProcessors.length; indexToInsertAt++) {\n        if (this.postProcessors[indexToInsertAt].priority >= priority) {\n            break;\n        }\n    }\n    this.postProcessors.splice(indexToInsertAt, 0, {postProcessor: postProcessor, priority: priority});\n};\n/**\n *\n * @param manager\n */\nPluginManager.prototype.addFileManager = function(manager) {\n    this.fileManagers.push(manager);\n};\n/**\n *\n * @returns {Array}\n * @private\n */\nPluginManager.prototype.getPreProcessors = function() {\n    var preProcessors = [];\n    for (var i = 0; i < this.preProcessors.length; i++) {\n        preProcessors.push(this.preProcessors[i].preProcessor);\n    }\n    return preProcessors;\n};\n/**\n *\n * @returns {Array}\n * @private\n */\nPluginManager.prototype.getPostProcessors = function() {\n    var postProcessors = [];\n    for (var i = 0; i < this.postProcessors.length; i++) {\n        postProcessors.push(this.postProcessors[i].postProcessor);\n    }\n    return postProcessors;\n};\n/**\n *\n * @returns {Array}\n * @private\n */\nPluginManager.prototype.getVisitors = function() {\n    return this.visitors;\n};\n/**\n *\n * @returns {Array}\n * @private\n */\nPluginManager.prototype.getFileManagers = function() {\n    return this.fileManagers;\n};\nmodule.exports = PluginManager;\n\n},{}],40:[function(require,module,exports){\nvar LessError = require('../less-error'),\n    tree = require(\"../tree\");\n\nvar FunctionImporter = module.exports = function FunctionImporter(context, fileInfo) {\n    this.fileInfo = fileInfo;\n};\n\nFunctionImporter.prototype.eval = function(contents, callback) {\n    var loaded = {},\n        loader,\n        registry;\n\n    registry = {\n        add: function(name, func) {\n            loaded[name] = func;\n        },\n        addMultiple: function(functions) {\n            Object.keys(functions).forEach(function(name) {\n                loaded[name] = functions[name];\n            });\n        }\n    };\n\n    try {\n        loader = new Function(\"functions\", \"tree\", \"fileInfo\", contents);\n        loader(registry, tree, this.fileInfo);\n    } catch(e) {\n        callback(new LessError({\n            message: \"Plugin evaluation error: '\" + e.name + ': ' + e.message.replace(/[\"]/g, \"'\") + \"'\" ,\n            filename: this.fileInfo.filename\n        }), null );\n    }\n\n    callback(null, { functions: loaded });\n};\n\n},{\"../less-error\":32,\"../tree\":62}],41:[function(require,module,exports){\nvar PromiseConstructor;\n\nmodule.exports = function(environment, ParseTree, ImportManager) {\n    var render = function (input, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n\n        if (!callback) {\n            if (!PromiseConstructor) {\n                PromiseConstructor = typeof Promise === 'undefined' ? require('promise') : Promise;\n            }\n            var self = this;\n            return new PromiseConstructor(function (resolve, reject) {\n                render.call(self, input, options, function(err, output) {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(output);\n                    }\n                });\n            });\n        } else {\n            this.parse(input, options, function(err, root, imports, options) {\n                if (err) { return callback(err); }\n\n                var result;\n                try {\n                    var parseTree = new ParseTree(root, imports);\n                    result = parseTree.toCSS(options);\n                }\n                catch (err) { return callback(err); }\n\n                callback(null, result);\n            });\n        }\n    };\n\n    return render;\n};\n\n},{\"promise\":undefined}],42:[function(require,module,exports){\nmodule.exports = function (SourceMapOutput, environment) {\n\n    var SourceMapBuilder = function (options) {\n        this.options = options;\n    };\n\n    SourceMapBuilder.prototype.toCSS = function(rootNode, options, imports) {\n        var sourceMapOutput = new SourceMapOutput(\n            {\n                contentsIgnoredCharsMap: imports.contentsIgnoredChars,\n                rootNode: rootNode,\n                contentsMap: imports.contents,\n                sourceMapFilename: this.options.sourceMapFilename,\n                sourceMapURL: this.options.sourceMapURL,\n                outputFilename: this.options.sourceMapOutputFilename,\n                sourceMapBasepath: this.options.sourceMapBasepath,\n                sourceMapRootpath: this.options.sourceMapRootpath,\n                outputSourceFiles: this.options.outputSourceFiles,\n                sourceMapGenerator: this.options.sourceMapGenerator,\n                sourceMapFileInline: this.options.sourceMapFileInline\n            });\n\n        var css = sourceMapOutput.toCSS(options);\n        this.sourceMap = sourceMapOutput.sourceMap;\n        this.sourceMapURL = sourceMapOutput.sourceMapURL;\n        if (this.options.sourceMapInputFilename) {\n            this.sourceMapInputFilename = sourceMapOutput.normalizeFilename(this.options.sourceMapInputFilename);\n        }\n        return css + this.getCSSAppendage();\n    };\n\n    SourceMapBuilder.prototype.getCSSAppendage = function() {\n\n        var sourceMapURL = this.sourceMapURL;\n        if (this.options.sourceMapFileInline) {\n            if (this.sourceMap === undefined) {\n                return \"\";\n            }\n            sourceMapURL = \"data:application/json;base64,\" + environment.encodeBase64(this.sourceMap);\n        }\n\n        if (sourceMapURL) {\n            return \"/*# sourceMappingURL=\" + sourceMapURL + \" */\";\n        }\n        return \"\";\n    };\n\n    SourceMapBuilder.prototype.getExternalSourceMap = function() {\n        return this.sourceMap;\n    };\n    SourceMapBuilder.prototype.setExternalSourceMap = function(sourceMap) {\n        this.sourceMap = sourceMap;\n    };\n\n    SourceMapBuilder.prototype.isInline = function() {\n        return this.options.sourceMapFileInline;\n    };\n    SourceMapBuilder.prototype.getSourceMapURL = function() {\n        return this.sourceMapURL;\n    };\n    SourceMapBuilder.prototype.getOutputFilename = function() {\n        return this.options.sourceMapOutputFilename;\n    };\n    SourceMapBuilder.prototype.getInputFilename = function() {\n        return this.sourceMapInputFilename;\n    };\n\n    return SourceMapBuilder;\n};\n\n},{}],43:[function(require,module,exports){\nmodule.exports = function (environment) {\n\n    var SourceMapOutput = function (options) {\n        this._css = [];\n        this._rootNode = options.rootNode;\n        this._contentsMap = options.contentsMap;\n        this._contentsIgnoredCharsMap = options.contentsIgnoredCharsMap;\n        if (options.sourceMapFilename) {\n            this._sourceMapFilename = options.sourceMapFilename.replace(/\\\\/g, '/');\n        }\n        this._outputFilename = options.outputFilename;\n        this.sourceMapURL = options.sourceMapURL;\n        if (options.sourceMapBasepath) {\n            this._sourceMapBasepath = options.sourceMapBasepath.replace(/\\\\/g, '/');\n        }\n        if (options.sourceMapRootpath) {\n            this._sourceMapRootpath = options.sourceMapRootpath.replace(/\\\\/g, '/');\n            if (this._sourceMapRootpath.charAt(this._sourceMapRootpath.length - 1) !== '/') {\n                this._sourceMapRootpath += '/';\n            }\n        } else {\n            this._sourceMapRootpath = \"\";\n        }\n        this._outputSourceFiles = options.outputSourceFiles;\n        this._sourceMapGeneratorConstructor = environment.getSourceMapGenerator();\n\n        this._lineNumber = 0;\n        this._column = 0;\n    };\n\n    SourceMapOutput.prototype.normalizeFilename = function(filename) {\n        filename = filename.replace(/\\\\/g, '/');\n\n        if (this._sourceMapBasepath && filename.indexOf(this._sourceMapBasepath) === 0) {\n            filename = filename.substring(this._sourceMapBasepath.length);\n            if (filename.charAt(0) === '\\\\' || filename.charAt(0) === '/') {\n                filename = filename.substring(1);\n            }\n        }\n        return (this._sourceMapRootpath || \"\") + filename;\n    };\n\n    SourceMapOutput.prototype.add = function(chunk, fileInfo, index, mapLines) {\n\n        //ignore adding empty strings\n        if (!chunk) {\n            return;\n        }\n\n        var lines,\n            sourceLines,\n            columns,\n            sourceColumns,\n            i;\n\n        if (fileInfo) {\n            var inputSource = this._contentsMap[fileInfo.filename];\n\n            // remove vars/banner added to the top of the file\n            if (this._contentsIgnoredCharsMap[fileInfo.filename]) {\n                // adjust the index\n                index -= this._contentsIgnoredCharsMap[fileInfo.filename];\n                if (index < 0) { index = 0; }\n                // adjust the source\n                inputSource = inputSource.slice(this._contentsIgnoredCharsMap[fileInfo.filename]);\n            }\n            inputSource = inputSource.substring(0, index);\n            sourceLines = inputSource.split(\"\\n\");\n            sourceColumns = sourceLines[sourceLines.length - 1];\n        }\n\n        lines = chunk.split(\"\\n\");\n        columns = lines[lines.length - 1];\n\n        if (fileInfo) {\n            if (!mapLines) {\n                this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + 1, column: this._column},\n                    original: { line: sourceLines.length, column: sourceColumns.length},\n                    source: this.normalizeFilename(fileInfo.filename)});\n            } else {\n                for (i = 0; i < lines.length; i++) {\n                    this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + i + 1, column: i === 0 ? this._column : 0},\n                        original: { line: sourceLines.length + i, column: i === 0 ? sourceColumns.length : 0},\n                        source: this.normalizeFilename(fileInfo.filename)});\n                }\n            }\n        }\n\n        if (lines.length === 1) {\n            this._column += columns.length;\n        } else {\n            this._lineNumber += lines.length - 1;\n            this._column = columns.length;\n        }\n\n        this._css.push(chunk);\n    };\n\n    SourceMapOutput.prototype.isEmpty = function() {\n        return this._css.length === 0;\n    };\n\n    SourceMapOutput.prototype.toCSS = function(context) {\n        this._sourceMapGenerator = new this._sourceMapGeneratorConstructor({ file: this._outputFilename, sourceRoot: null });\n\n        if (this._outputSourceFiles) {\n            for (var filename in this._contentsMap) {\n                if (this._contentsMap.hasOwnProperty(filename)) {\n                    var source = this._contentsMap[filename];\n                    if (this._contentsIgnoredCharsMap[filename]) {\n                        source = source.slice(this._contentsIgnoredCharsMap[filename]);\n                    }\n                    this._sourceMapGenerator.setSourceContent(this.normalizeFilename(filename), source);\n                }\n            }\n        }\n\n        this._rootNode.genCSS(context, this);\n\n        if (this._css.length > 0) {\n            var sourceMapURL,\n                sourceMapContent = JSON.stringify(this._sourceMapGenerator.toJSON());\n\n            if (this.sourceMapURL) {\n                sourceMapURL = this.sourceMapURL;\n            } else if (this._sourceMapFilename) {\n                sourceMapURL = this._sourceMapFilename;\n            }\n            this.sourceMapURL = sourceMapURL;\n\n            this.sourceMap = sourceMapContent;\n        }\n\n        return this._css.join('');\n    };\n\n    return SourceMapOutput;\n};\n\n},{}],44:[function(require,module,exports){\nvar contexts = require(\"./contexts\"),\n    visitor = require(\"./visitors\"),\n    tree = require(\"./tree\");\n\nmodule.exports = function(root, options) {\n    options = options || {};\n    var evaldRoot,\n        variables = options.variables,\n        evalEnv = new contexts.Eval(options);\n\n    //\n    // Allows setting variables with a hash, so:\n    //\n    //   `{ color: new tree.Color('#f01') }` will become:\n    //\n    //   new tree.Rule('@color',\n    //     new tree.Value([\n    //       new tree.Expression([\n    //         new tree.Color('#f01')\n    //       ])\n    //     ])\n    //   )\n    //\n    if (typeof variables === 'object' && !Array.isArray(variables)) {\n        variables = Object.keys(variables).map(function (k) {\n            var value = variables[k];\n\n            if (! (value instanceof tree.Value)) {\n                if (! (value instanceof tree.Expression)) {\n                    value = new tree.Expression([value]);\n                }\n                value = new tree.Value([value]);\n            }\n            return new tree.Rule('@' + k, value, false, null, 0);\n        });\n        evalEnv.frames = [new tree.Ruleset(null, variables)];\n    }\n\n    var preEvalVisitors = [],\n        visitors = [\n            new visitor.JoinSelectorVisitor(),\n            new visitor.MarkVisibleSelectorsVisitor(true),\n            new visitor.ExtendVisitor(),\n            new visitor.ToCSSVisitor({compress: Boolean(options.compress)})\n        ], i;\n\n    if (options.pluginManager) {\n        var pluginVisitors = options.pluginManager.getVisitors();\n        for (i = 0; i < pluginVisitors.length; i++) {\n            var pluginVisitor = pluginVisitors[i];\n            if (pluginVisitor.isPreEvalVisitor) {\n                preEvalVisitors.push(pluginVisitor);\n            } else {\n                if (pluginVisitor.isPreVisitor) {\n                    visitors.splice(0, 0, pluginVisitor);\n                } else {\n                    visitors.push(pluginVisitor);\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < preEvalVisitors.length; i++) {\n        preEvalVisitors[i].run(root);\n    }\n\n    evaldRoot = root.eval(evalEnv);\n\n    for (i = 0; i < visitors.length; i++) {\n        visitors[i].run(evaldRoot);\n    }\n\n    return evaldRoot;\n};\n\n},{\"./contexts\":11,\"./tree\":62,\"./visitors\":87}],45:[function(require,module,exports){\nvar Node = require(\"./node\");\n\nvar Alpha = function (val) {\n    this.value = val;\n};\nAlpha.prototype = new Node();\nAlpha.prototype.type = \"Alpha\";\n\nAlpha.prototype.accept = function (visitor) {\n    this.value = visitor.visit(this.value);\n};\nAlpha.prototype.eval = function (context) {\n    if (this.value.eval) { return new Alpha(this.value.eval(context)); }\n    return this;\n};\nAlpha.prototype.genCSS = function (context, output) {\n    output.add(\"alpha(opacity=\");\n\n    if (this.value.genCSS) {\n        this.value.genCSS(context, output);\n    } else {\n        output.add(this.value);\n    }\n\n    output.add(\")\");\n};\n\nmodule.exports = Alpha;\n\n},{\"./node\":70}],46:[function(require,module,exports){\nvar Node = require(\"./node\");\n\nvar Anonymous = function (value, index, currentFileInfo, mapLines, rulesetLike, visibilityInfo) {\n    this.value = value;\n    this.index = index;\n    this.mapLines = mapLines;\n    this.currentFileInfo = currentFileInfo;\n    this.rulesetLike = (typeof rulesetLike === 'undefined') ? false : rulesetLike;\n    this.allowRoot = true;\n    this.copyVisibilityInfo(visibilityInfo);\n};\nAnonymous.prototype = new Node();\nAnonymous.prototype.type = \"Anonymous\";\nAnonymous.prototype.eval = function () {\n    return new Anonymous(this.value, this.index, this.currentFileInfo, this.mapLines, this.rulesetLike, this.visibilityInfo());\n};\nAnonymous.prototype.compare = function (other) {\n    return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;\n};\nAnonymous.prototype.isRulesetLike = function() {\n    return this.rulesetLike;\n};\nAnonymous.prototype.genCSS = function (context, output) {\n    output.add(this.value, this.currentFileInfo, this.index, this.mapLines);\n};\nmodule.exports = Anonymous;\n\n},{\"./node\":70}],47:[function(require,module,exports){\nvar Node = require(\"./node\");\n\nvar Assignment = function (key, val) {\n    this.key = key;\n    this.value = val;\n};\n\nAssignment.prototype = new Node();\nAssignment.prototype.type = \"Assignment\";\nAssignment.prototype.accept = function (visitor) {\n    this.value = visitor.visit(this.value);\n};\nAssignment.prototype.eval = function (context) {\n    if (this.value.eval) {\n        return new Assignment(this.key, this.value.eval(context));\n    }\n    return this;\n};\nAssignment.prototype.genCSS = function (context, output) {\n    output.add(this.key + '=');\n    if (this.value.genCSS) {\n        this.value.genCSS(context, output);\n    } else {\n        output.add(this.value);\n    }\n};\nmodule.exports = Assignment;\n\n},{\"./node\":70}],48:[function(require,module,exports){\nvar Node = require(\"./node\");\n\nvar Attribute = function (key, op, value) {\n    this.key = key;\n    this.op = op;\n    this.value = value;\n};\nAttribute.prototype = new Node();\nAttribute.prototype.type = \"Attribute\";\nAttribute.prototype.eval = function (context) {\n    return new Attribute(this.key.eval ? this.key.eval(context) : this.key,\n        this.op, (this.value && this.value.eval) ? this.value.eval(context) : this.value);\n};\nAttribute.prototype.genCSS = function (context, output) {\n    output.add(this.toCSS(context));\n};\nAttribute.prototype.toCSS = function (context) {\n    var value = this.key.toCSS ? this.key.toCSS(context) : this.key;\n\n    if (this.op) {\n        value += this.op;\n        value += (this.value.toCSS ? this.value.toCSS(context) : this.value);\n    }\n\n    return '[' + value + ']';\n};\nmodule.exports = Attribute;\n\n},{\"./node\":70}],49:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    FunctionCaller = require(\"../functions/function-caller\");\n//\n// A function call node.\n//\nvar Call = function (name, args, index, currentFileInfo) {\n    this.name = name;\n    this.args = args;\n    this.index = index;\n    this.currentFileInfo = currentFileInfo;\n};\nCall.prototype = new Node();\nCall.prototype.type = \"Call\";\nCall.prototype.accept = function (visitor) {\n    if (this.args) {\n        this.args = visitor.visitArray(this.args);\n    }\n};\n//\n// When evaluating a function call,\n// we either find the function in the functionRegistry,\n// in which case we call it, passing the  evaluated arguments,\n// if this returns null or we cannot find the function, we\n// simply print it out as it appeared originally [2].\n//\n// The reason why we evaluate the arguments, is in the case where\n// we try to pass a variable to a function, like: `saturate(@color)`.\n// The function should receive the value, not the variable.\n//\nCall.prototype.eval = function (context) {\n    var args = this.args.map(function (a) { return a.eval(context); }),\n        result, funcCaller = new FunctionCaller(this.name, context, this.index, this.currentFileInfo);\n\n    if (funcCaller.isValid()) {\n        try {\n            result = funcCaller.call(args);\n        } catch (e) {\n            throw { type: e.type || \"Runtime\",\n                    message: \"error evaluating function `\" + this.name + \"`\" +\n                             (e.message ? ': ' + e.message : ''),\n                    index: this.index, filename: this.currentFileInfo.filename };\n        }\n\n        if (result != null) {\n            result.index = this.index;\n            result.currentFileInfo = this.currentFileInfo;\n            return result;\n        }\n    }\n\n    return new Call(this.name, args, this.index, this.currentFileInfo);\n};\nCall.prototype.genCSS = function (context, output) {\n    output.add(this.name + \"(\", this.currentFileInfo, this.index);\n\n    for (var i = 0; i < this.args.length; i++) {\n        this.args[i].genCSS(context, output);\n        if (i + 1 < this.args.length) {\n            output.add(\", \");\n        }\n    }\n\n    output.add(\")\");\n};\nmodule.exports = Call;\n\n},{\"../functions/function-caller\":21,\"./node\":70}],50:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    colors = require(\"../data/colors\");\n\n//\n// RGB Colors - #ff0014, #eee\n//\nvar Color = function (rgb, a, originalForm) {\n    //\n    // The end goal here, is to parse the arguments\n    // into an integer triplet, such as `128, 255, 0`\n    //\n    // This facilitates operations and conversions.\n    //\n    if (Array.isArray(rgb)) {\n        this.rgb = rgb;\n    } else if (rgb.length == 6) {\n        this.rgb = rgb.match(/.{2}/g).map(function (c) {\n            return parseInt(c, 16);\n        });\n    } else {\n        this.rgb = rgb.split('').map(function (c) {\n            return parseInt(c + c, 16);\n        });\n    }\n    this.alpha = typeof a === 'number' ? a : 1;\n    if (typeof originalForm !== 'undefined') {\n        this.value = originalForm;\n    }\n};\n\nColor.prototype = new Node();\nColor.prototype.type = \"Color\";\n\nfunction clamp(v, max) {\n    return Math.min(Math.max(v, 0), max);\n}\n\nfunction toHex(v) {\n    return '#' + v.map(function (c) {\n        c = clamp(Math.round(c), 255);\n        return (c < 16 ? '0' : '') + c.toString(16);\n    }).join('');\n}\n\nColor.prototype.luma = function () {\n    var r = this.rgb[0] / 255,\n        g = this.rgb[1] / 255,\n        b = this.rgb[2] / 255;\n\n    r = (r <= 0.03928) ? r / 12.92 : Math.pow(((r + 0.055) / 1.055), 2.4);\n    g = (g <= 0.03928) ? g / 12.92 : Math.pow(((g + 0.055) / 1.055), 2.4);\n    b = (b <= 0.03928) ? b / 12.92 : Math.pow(((b + 0.055) / 1.055), 2.4);\n\n    return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n};\nColor.prototype.genCSS = function (context, output) {\n    output.add(this.toCSS(context));\n};\nColor.prototype.toCSS = function (context, doNotCompress) {\n    var compress = context && context.compress && !doNotCompress, color, alpha;\n\n    // `value` is set if this color was originally\n    // converted from a named color string so we need\n    // to respect this and try to output named color too.\n    if (this.value) {\n        return this.value;\n    }\n\n    // If we have some transparency, the only way to represent it\n    // is via `rgba`. Otherwise, we use the hex representation,\n    // which has better compatibility with older browsers.\n    // Values are capped between `0` and `255`, rounded and zero-padded.\n    alpha = this.fround(context, this.alpha);\n    if (alpha < 1) {\n        return \"rgba(\" + this.rgb.map(function (c) {\n            return clamp(Math.round(c), 255);\n        }).concat(clamp(alpha, 1))\n            .join(',' + (compress ? '' : ' ')) + \")\";\n    }\n\n    color = this.toRGB();\n\n    if (compress) {\n        var splitcolor = color.split('');\n\n        // Convert color to short format\n        if (splitcolor[1] === splitcolor[2] && splitcolor[3] === splitcolor[4] && splitcolor[5] === splitcolor[6]) {\n            color = '#' + splitcolor[1] + splitcolor[3] + splitcolor[5];\n        }\n    }\n\n    return color;\n};\n\n//\n// Operations have to be done per-channel, if not,\n// channels will spill onto each other. Once we have\n// our result, in the form of an integer triplet,\n// we create a new Color node to hold the result.\n//\nColor.prototype.operate = function (context, op, other) {\n    var rgb = [];\n    var alpha = this.alpha * (1 - other.alpha) + other.alpha;\n    for (var c = 0; c < 3; c++) {\n        rgb[c] = this._operate(context, op, this.rgb[c], other.rgb[c]);\n    }\n    return new Color(rgb, alpha);\n};\nColor.prototype.toRGB = function () {\n    return toHex(this.rgb);\n};\nColor.prototype.toHSL = function () {\n    var r = this.rgb[0] / 255,\n        g = this.rgb[1] / 255,\n        b = this.rgb[2] / 255,\n        a = this.alpha;\n\n    var max = Math.max(r, g, b), min = Math.min(r, g, b);\n    var h, s, l = (max + min) / 2, d = max - min;\n\n    if (max === min) {\n        h = s = 0;\n    } else {\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n        switch (max) {\n            case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n            case g: h = (b - r) / d + 2;               break;\n            case b: h = (r - g) / d + 4;               break;\n        }\n        h /= 6;\n    }\n    return { h: h * 360, s: s, l: l, a: a };\n};\n//Adapted from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\nColor.prototype.toHSV = function () {\n    var r = this.rgb[0] / 255,\n        g = this.rgb[1] / 255,\n        b = this.rgb[2] / 255,\n        a = this.alpha;\n\n    var max = Math.max(r, g, b), min = Math.min(r, g, b);\n    var h, s, v = max;\n\n    var d = max - min;\n    if (max === 0) {\n        s = 0;\n    } else {\n        s = d / max;\n    }\n\n    if (max === min) {\n        h = 0;\n    } else {\n        switch(max) {\n            case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n            case g: h = (b - r) / d + 2; break;\n            case b: h = (r - g) / d + 4; break;\n        }\n        h /= 6;\n    }\n    return { h: h * 360, s: s, v: v, a: a };\n};\nColor.prototype.toARGB = function () {\n    return toHex([this.alpha * 255].concat(this.rgb));\n};\nColor.prototype.compare = function (x) {\n    return (x.rgb &&\n        x.rgb[0] === this.rgb[0] &&\n        x.rgb[1] === this.rgb[1] &&\n        x.rgb[2] === this.rgb[2] &&\n        x.alpha  === this.alpha) ? 0 : undefined;\n};\n\nColor.fromKeyword = function(keyword) {\n    var c, key = keyword.toLowerCase();\n    if (colors.hasOwnProperty(key)) {\n        c = new Color(colors[key].slice(1));\n    }\n    else if (key === \"transparent\") {\n        c = new Color([0, 0, 0], 0);\n    }\n\n    if (c) {\n        c.value = keyword;\n        return c;\n    }\n};\nmodule.exports = Color;\n\n},{\"../data/colors\":12,\"./node\":70}],51:[function(require,module,exports){\nvar Node = require(\"./node\");\n\nvar Combinator = function (value) {\n    if (value === ' ') {\n        this.value = ' ';\n        this.emptyOrWhitespace = true;\n    } else {\n        this.value = value ? value.trim() : \"\";\n        this.emptyOrWhitespace = this.value === \"\";\n    }\n};\nCombinator.prototype = new Node();\nCombinator.prototype.type = \"Combinator\";\nvar _noSpaceCombinators = {\n    '': true,\n    ' ': true,\n    '|': true\n};\nCombinator.prototype.genCSS = function (context, output) {\n    var spaceOrEmpty = (context.compress || _noSpaceCombinators[this.value]) ? '' : ' ';\n    output.add(spaceOrEmpty + this.value + spaceOrEmpty);\n};\nmodule.exports = Combinator;\n\n},{\"./node\":70}],52:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    getDebugInfo = require(\"./debug-info\");\n\nvar Comment = function (value, isLineComment, index, currentFileInfo) {\n    this.value = value;\n    this.isLineComment = isLineComment;\n    this.index = index;\n    this.currentFileInfo = currentFileInfo;\n    this.allowRoot = true;\n};\nComment.prototype = new Node();\nComment.prototype.type = \"Comment\";\nComment.prototype.genCSS = function (context, output) {\n    if (this.debugInfo) {\n        output.add(getDebugInfo(context, this), this.currentFileInfo, this.index);\n    }\n    output.add(this.value);\n};\nComment.prototype.isSilent = function(context) {\n    var isCompressed = context.compress && this.value[2] !== \"!\";\n    return this.isLineComment || isCompressed;\n};\nmodule.exports = Comment;\n\n},{\"./debug-info\":54,\"./node\":70}],53:[function(require,module,exports){\nvar Node = require(\"./node\");\n\nvar Condition = function (op, l, r, i, negate) {\n    this.op = op.trim();\n    this.lvalue = l;\n    this.rvalue = r;\n    this.index = i;\n    this.negate = negate;\n};\nCondition.prototype = new Node();\nCondition.prototype.type = \"Condition\";\nCondition.prototype.accept = function (visitor) {\n    this.lvalue = visitor.visit(this.lvalue);\n    this.rvalue = visitor.visit(this.rvalue);\n};\nCondition.prototype.eval = function (context) {\n    var result = (function (op, a, b) {\n        switch (op) {\n            case 'and': return a && b;\n            case 'or':  return a || b;\n            default:\n                switch (Node.compare(a, b)) {\n                    case -1:\n                        return op === '<' || op === '=<' || op === '<=';\n                    case 0:\n                        return op === '=' || op === '>=' || op === '=<' || op === '<=';\n                    case 1:\n                        return op === '>' || op === '>=';\n                    default:\n                        return false;\n                }\n        }\n    })(this.op, this.lvalue.eval(context), this.rvalue.eval(context));\n\n    return this.negate ? !result : result;\n};\nmodule.exports = Condition;\n\n},{\"./node\":70}],54:[function(require,module,exports){\nvar debugInfo = function(context, ctx, lineSeparator) {\n    var result = \"\";\n    if (context.dumpLineNumbers && !context.compress) {\n        switch(context.dumpLineNumbers) {\n            case 'comments':\n                result = debugInfo.asComment(ctx);\n                break;\n            case 'mediaquery':\n                result = debugInfo.asMediaQuery(ctx);\n                break;\n            case 'all':\n                result = debugInfo.asComment(ctx) + (lineSeparator || \"\") + debugInfo.asMediaQuery(ctx);\n                break;\n        }\n    }\n    return result;\n};\n\ndebugInfo.asComment = function(ctx) {\n    return '/* line ' + ctx.debugInfo.lineNumber + ', ' + ctx.debugInfo.fileName + ' */\\n';\n};\n\ndebugInfo.asMediaQuery = function(ctx) {\n    var filenameWithProtocol = ctx.debugInfo.fileName;\n    if (!/^[a-z]+:\\/\\//i.test(filenameWithProtocol)) {\n        filenameWithProtocol = 'file://' + filenameWithProtocol;\n    }\n    return '@media -sass-debug-info{filename{font-family:' +\n        filenameWithProtocol.replace(/([.:\\/\\\\])/g, function (a) {\n            if (a == '\\\\') {\n                a = '\\/';\n            }\n            return '\\\\' + a;\n        }) +\n        '}line{font-family:\\\\00003' + ctx.debugInfo.lineNumber + '}}\\n';\n};\n\nmodule.exports = debugInfo;\n\n},{}],55:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    contexts = require(\"../contexts\");\n\nvar DetachedRuleset = function (ruleset, frames) {\n    this.ruleset = ruleset;\n    this.frames = frames;\n};\nDetachedRuleset.prototype = new Node();\nDetachedRuleset.prototype.type = \"DetachedRuleset\";\nDetachedRuleset.prototype.evalFirst = true;\nDetachedRuleset.prototype.accept = function (visitor) {\n    this.ruleset = visitor.visit(this.ruleset);\n};\nDetachedRuleset.prototype.eval = function (context) {\n    var frames = this.frames || context.frames.slice(0);\n    return new DetachedRuleset(this.ruleset, frames);\n};\nDetachedRuleset.prototype.callEval = function (context) {\n    return this.ruleset.eval(this.frames ? new contexts.Eval(context, this.frames.concat(context.frames)) : context);\n};\nmodule.exports = DetachedRuleset;\n\n},{\"../contexts\":11,\"./node\":70}],56:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    unitConversions = require(\"../data/unit-conversions\"),\n    Unit = require(\"./unit\"),\n    Color = require(\"./color\");\n\n//\n// A number with a unit\n//\nvar Dimension = function (value, unit) {\n    this.value = parseFloat(value);\n    this.unit = (unit && unit instanceof Unit) ? unit :\n      new Unit(unit ? [unit] : undefined);\n};\n\nDimension.prototype = new Node();\nDimension.prototype.type = \"Dimension\";\nDimension.prototype.accept = function (visitor) {\n    this.unit = visitor.visit(this.unit);\n};\nDimension.prototype.eval = function (context) {\n    return this;\n};\nDimension.prototype.toColor = function () {\n    return new Color([this.value, this.value, this.value]);\n};\nDimension.prototype.genCSS = function (context, output) {\n    if ((context && context.strictUnits) && !this.unit.isSingular()) {\n        throw new Error(\"Multiple units in dimension. Correct the units or use the unit function. Bad unit: \" + this.unit.toString());\n    }\n\n    var value = this.fround(context, this.value),\n        strValue = String(value);\n\n    if (value !== 0 && value < 0.000001 && value > -0.000001) {\n        // would be output 1e-6 etc.\n        strValue = value.toFixed(20).replace(/0+$/, \"\");\n    }\n\n    if (context && context.compress) {\n        // Zero values doesn't need a unit\n        if (value === 0 && this.unit.isLength()) {\n            output.add(strValue);\n            return;\n        }\n\n        // Float values doesn't need a leading zero\n        if (value > 0 && value < 1) {\n            strValue = (strValue).substr(1);\n        }\n    }\n\n    output.add(strValue);\n    this.unit.genCSS(context, output);\n};\n\n// In an operation between two Dimensions,\n// we default to the first Dimension's unit,\n// so `1px + 2` will yield `3px`.\nDimension.prototype.operate = function (context, op, other) {\n    /*jshint noempty:false */\n    var value = this._operate(context, op, this.value, other.value),\n        unit = this.unit.clone();\n\n    if (op === '+' || op === '-') {\n        if (unit.numerator.length === 0 && unit.denominator.length === 0) {\n            unit = other.unit.clone();\n            if (this.unit.backupUnit) {\n                unit.backupUnit = this.unit.backupUnit;\n            }\n        } else if (other.unit.numerator.length === 0 && unit.denominator.length === 0) {\n            // do nothing\n        } else {\n            other = other.convertTo(this.unit.usedUnits());\n\n            if (context.strictUnits && other.unit.toString() !== unit.toString()) {\n                throw new Error(\"Incompatible units. Change the units or use the unit function. Bad units: '\" + unit.toString() +\n                    \"' and '\" + other.unit.toString() + \"'.\");\n            }\n\n            value = this._operate(context, op, this.value, other.value);\n        }\n    } else if (op === '*') {\n        unit.numerator = unit.numerator.concat(other.unit.numerator).sort();\n        unit.denominator = unit.denominator.concat(other.unit.denominator).sort();\n        unit.cancel();\n    } else if (op === '/') {\n        unit.numerator = unit.numerator.concat(other.unit.denominator).sort();\n        unit.denominator = unit.denominator.concat(other.unit.numerator).sort();\n        unit.cancel();\n    }\n    return new Dimension(value, unit);\n};\nDimension.prototype.compare = function (other) {\n    var a, b;\n\n    if (!(other instanceof Dimension)) {\n        return undefined;\n    }\n\n    if (this.unit.isEmpty() || other.unit.isEmpty()) {\n        a = this;\n        b = other;\n    } else {\n        a = this.unify();\n        b = other.unify();\n        if (a.unit.compare(b.unit) !== 0) {\n            return undefined;\n        }\n    }\n\n    return Node.numericCompare(a.value, b.value);\n};\nDimension.prototype.unify = function () {\n    return this.convertTo({ length: 'px', duration: 's', angle: 'rad' });\n};\nDimension.prototype.convertTo = function (conversions) {\n    var value = this.value, unit = this.unit.clone(),\n        i, groupName, group, targetUnit, derivedConversions = {}, applyUnit;\n\n    if (typeof conversions === 'string') {\n        for (i in unitConversions) {\n            if (unitConversions[i].hasOwnProperty(conversions)) {\n                derivedConversions = {};\n                derivedConversions[i] = conversions;\n            }\n        }\n        conversions = derivedConversions;\n    }\n    applyUnit = function (atomicUnit, denominator) {\n        /* jshint loopfunc:true */\n        if (group.hasOwnProperty(atomicUnit)) {\n            if (denominator) {\n                value = value / (group[atomicUnit] / group[targetUnit]);\n            } else {\n                value = value * (group[atomicUnit] / group[targetUnit]);\n            }\n\n            return targetUnit;\n        }\n\n        return atomicUnit;\n    };\n\n    for (groupName in conversions) {\n        if (conversions.hasOwnProperty(groupName)) {\n            targetUnit = conversions[groupName];\n            group = unitConversions[groupName];\n\n            unit.map(applyUnit);\n        }\n    }\n\n    unit.cancel();\n\n    return new Dimension(value, unit);\n};\nmodule.exports = Dimension;\n\n},{\"../data/unit-conversions\":14,\"./color\":50,\"./node\":70,\"./unit\":79}],57:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    Selector = require(\"./selector\"),\n    Ruleset = require(\"./ruleset\");\n\nvar Directive = function (name, value, rules, index, currentFileInfo, debugInfo, isRooted, visibilityInfo) {\n    var i;\n\n    this.name  = name;\n    this.value = value;\n    if (rules) {\n        if (Array.isArray(rules)) {\n            this.rules = rules;\n        } else {\n            this.rules = [rules];\n            this.rules[0].selectors = (new Selector([], null, null, this.index, currentFileInfo)).createEmptySelectors();\n        }\n        for (i = 0; i < this.rules.length; i++) {\n            this.rules[i].allowImports = true;\n        }\n    }\n    this.index = index;\n    this.currentFileInfo = currentFileInfo;\n    this.debugInfo = debugInfo;\n    this.isRooted = isRooted || false;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.allowRoot = true;\n};\n\nDirective.prototype = new Node();\nDirective.prototype.type = \"Directive\";\nDirective.prototype.accept = function (visitor) {\n    var value = this.value, rules = this.rules;\n    if (rules) {\n        this.rules = visitor.visitArray(rules);\n    }\n    if (value) {\n        this.value = visitor.visit(value);\n    }\n};\nDirective.prototype.isRulesetLike = function() {\n    return this.rules || !this.isCharset();\n};\nDirective.prototype.isCharset = function() {\n    return \"@charset\" === this.name;\n};\nDirective.prototype.genCSS = function (context, output) {\n    var value = this.value, rules = this.rules;\n    output.add(this.name, this.currentFileInfo, this.index);\n    if (value) {\n        output.add(' ');\n        value.genCSS(context, output);\n    }\n    if (rules) {\n        this.outputRuleset(context, output, rules);\n    } else {\n        output.add(';');\n    }\n};\nDirective.prototype.eval = function (context) {\n    var mediaPathBackup, mediaBlocksBackup, value = this.value, rules = this.rules;\n\n    //media stored inside other directive should not bubble over it\n    //backpup media bubbling information\n    mediaPathBackup = context.mediaPath;\n    mediaBlocksBackup = context.mediaBlocks;\n    //deleted media bubbling information\n    context.mediaPath = [];\n    context.mediaBlocks = [];\n\n    if (value) {\n        value = value.eval(context);\n    }\n    if (rules) {\n        // assuming that there is only one rule at this point - that is how parser constructs the rule\n        rules = [rules[0].eval(context)];\n        rules[0].root = true;\n    }\n    //restore media bubbling information\n    context.mediaPath = mediaPathBackup;\n    context.mediaBlocks = mediaBlocksBackup;\n\n    return new Directive(this.name, value, rules,\n        this.index, this.currentFileInfo, this.debugInfo, this.isRooted, this.visibilityInfo());\n};\nDirective.prototype.variable = function (name) {\n    if (this.rules) {\n        // assuming that there is only one rule at this point - that is how parser constructs the rule\n        return Ruleset.prototype.variable.call(this.rules[0], name);\n    }\n};\nDirective.prototype.find = function () {\n    if (this.rules) {\n        // assuming that there is only one rule at this point - that is how parser constructs the rule\n        return Ruleset.prototype.find.apply(this.rules[0], arguments);\n    }\n};\nDirective.prototype.rulesets = function () {\n    if (this.rules) {\n        // assuming that there is only one rule at this point - that is how parser constructs the rule\n        return Ruleset.prototype.rulesets.apply(this.rules[0]);\n    }\n};\nDirective.prototype.outputRuleset = function (context, output, rules) {\n    var ruleCnt = rules.length, i;\n    context.tabLevel = (context.tabLevel | 0) + 1;\n\n    // Compressed\n    if (context.compress) {\n        output.add('{');\n        for (i = 0; i < ruleCnt; i++) {\n            rules[i].genCSS(context, output);\n        }\n        output.add('}');\n        context.tabLevel--;\n        return;\n    }\n\n    // Non-compressed\n    var tabSetStr = '\\n' + Array(context.tabLevel).join(\"  \"), tabRuleStr = tabSetStr + \"  \";\n    if (!ruleCnt) {\n        output.add(\" {\" + tabSetStr + '}');\n    } else {\n        output.add(\" {\" + tabRuleStr);\n        rules[0].genCSS(context, output);\n        for (i = 1; i < ruleCnt; i++) {\n            output.add(tabRuleStr);\n            rules[i].genCSS(context, output);\n        }\n        output.add(tabSetStr + '}');\n    }\n\n    context.tabLevel--;\n};\nmodule.exports = Directive;\n\n},{\"./node\":70,\"./ruleset\":76,\"./selector\":77}],58:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    Paren = require(\"./paren\"),\n    Combinator = require(\"./combinator\");\n\nvar Element = function (combinator, value, index, currentFileInfo, info) {\n    this.combinator = combinator instanceof Combinator ?\n                      combinator : new Combinator(combinator);\n\n    if (typeof value === 'string') {\n        this.value = value.trim();\n    } else if (value) {\n        this.value = value;\n    } else {\n        this.value = \"\";\n    }\n    this.index = index;\n    this.currentFileInfo = currentFileInfo;\n    this.copyVisibilityInfo(info);\n};\nElement.prototype = new Node();\nElement.prototype.type = \"Element\";\nElement.prototype.accept = function (visitor) {\n    var value = this.value;\n    this.combinator = visitor.visit(this.combinator);\n    if (typeof value === \"object\") {\n        this.value = visitor.visit(value);\n    }\n};\nElement.prototype.eval = function (context) {\n    return new Element(this.combinator,\n                             this.value.eval ? this.value.eval(context) : this.value,\n                             this.index,\n                             this.currentFileInfo, this.visibilityInfo());\n};\nElement.prototype.clone = function () {\n    return new Element(this.combinator,\n        this.value,\n        this.index,\n        this.currentFileInfo, this.visibilityInfo());\n};\nElement.prototype.genCSS = function (context, output) {\n    output.add(this.toCSS(context), this.currentFileInfo, this.index);\n};\nElement.prototype.toCSS = function (context) {\n    context = context || {};\n    var value = this.value, firstSelector = context.firstSelector;\n    if (value instanceof Paren) {\n        // selector in parens should not be affected by outer selector\n        // flags (breaks only interpolated selectors - see #1973)\n        context.firstSelector = true;\n    }\n    value = value.toCSS ? value.toCSS(context) : value;\n    context.firstSelector = firstSelector;\n    if (value === '' && this.combinator.value.charAt(0) === '&') {\n        return '';\n    } else {\n        return this.combinator.toCSS(context) + value;\n    }\n};\nmodule.exports = Element;\n\n},{\"./combinator\":51,\"./node\":70,\"./paren\":72}],59:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    Paren = require(\"./paren\"),\n    Comment = require(\"./comment\");\n\nvar Expression = function (value) {\n    this.value = value;\n    if (!value) {\n        throw new Error(\"Expression requires an array parameter\");\n    }\n};\nExpression.prototype = new Node();\nExpression.prototype.type = \"Expression\";\nExpression.prototype.accept = function (visitor) {\n    this.value = visitor.visitArray(this.value);\n};\nExpression.prototype.eval = function (context) {\n    var returnValue,\n        inParenthesis = this.parens && !this.parensInOp,\n        doubleParen = false;\n    if (inParenthesis) {\n        context.inParenthesis();\n    }\n    if (this.value.length > 1) {\n        returnValue = new Expression(this.value.map(function (e) {\n            return e.eval(context);\n        }));\n    } else if (this.value.length === 1) {\n        if (this.value[0].parens && !this.value[0].parensInOp) {\n            doubleParen = true;\n        }\n        returnValue = this.value[0].eval(context);\n    } else {\n        returnValue = this;\n    }\n    if (inParenthesis) {\n        context.outOfParenthesis();\n    }\n    if (this.parens && this.parensInOp && !(context.isMathOn()) && !doubleParen) {\n        returnValue = new Paren(returnValue);\n    }\n    return returnValue;\n};\nExpression.prototype.genCSS = function (context, output) {\n    for (var i = 0; i < this.value.length; i++) {\n        this.value[i].genCSS(context, output);\n        if (i + 1 < this.value.length) {\n            output.add(\" \");\n        }\n    }\n};\nExpression.prototype.throwAwayComments = function () {\n    this.value = this.value.filter(function(v) {\n        return !(v instanceof Comment);\n    });\n};\nmodule.exports = Expression;\n\n},{\"./comment\":52,\"./node\":70,\"./paren\":72}],60:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    Selector = require(\"./selector\");\n\nvar Extend = function Extend(selector, option, index, currentFileInfo, visibilityInfo) {\n    this.selector = selector;\n    this.option = option;\n    this.index = index;\n    this.object_id = Extend.next_id++;\n    this.parent_ids = [this.object_id];\n    this.currentFileInfo = currentFileInfo || {};\n    this.copyVisibilityInfo(visibilityInfo);\n    this.allowRoot = true;\n\n    switch(option) {\n        case \"all\":\n            this.allowBefore = true;\n            this.allowAfter = true;\n            break;\n        default:\n            this.allowBefore = false;\n            this.allowAfter = false;\n            break;\n    }\n};\nExtend.next_id = 0;\n\nExtend.prototype = new Node();\nExtend.prototype.type = \"Extend\";\nExtend.prototype.accept = function (visitor) {\n    this.selector = visitor.visit(this.selector);\n};\nExtend.prototype.eval = function (context) {\n    return new Extend(this.selector.eval(context), this.option, this.index, this.currentFileInfo, this.visibilityInfo());\n};\nExtend.prototype.clone = function (context) {\n    return new Extend(this.selector, this.option, this.index, this.currentFileInfo, this.visibilityInfo());\n};\n//it concatenates (joins) all selectors in selector array\nExtend.prototype.findSelfSelectors = function (selectors) {\n    var selfElements = [],\n        i,\n        selectorElements;\n\n    for (i = 0; i < selectors.length; i++) {\n        selectorElements = selectors[i].elements;\n        // duplicate the logic in genCSS function inside the selector node.\n        // future TODO - move both logics into the selector joiner visitor\n        if (i > 0 && selectorElements.length && selectorElements[0].combinator.value === \"\") {\n            selectorElements[0].combinator.value = ' ';\n        }\n        selfElements = selfElements.concat(selectors[i].elements);\n    }\n\n    this.selfSelectors = [new Selector(selfElements)];\n    this.selfSelectors[0].copyVisibilityInfo(this.visibilityInfo());\n};\nmodule.exports = Extend;\n\n},{\"./node\":70,\"./selector\":77}],61:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    Media = require(\"./media\"),\n    URL = require(\"./url\"),\n    Quoted = require(\"./quoted\"),\n    Ruleset = require(\"./ruleset\"),\n    Anonymous = require(\"./anonymous\");\n\n//\n// CSS @import node\n//\n// The general strategy here is that we don't want to wait\n// for the parsing to be completed, before we start importing\n// the file. That's because in the context of a browser,\n// most of the time will be spent waiting for the server to respond.\n//\n// On creation, we push the import path to our import queue, though\n// `import,push`, we also pass it a callback, which it'll call once\n// the file has been fetched, and parsed.\n//\nvar Import = function (path, features, options, index, currentFileInfo, visibilityInfo) {\n    this.options = options;\n    this.index = index;\n    this.path = path;\n    this.features = features;\n    this.currentFileInfo = currentFileInfo;\n    this.allowRoot = true;\n\n    if (this.options.less !== undefined || this.options.inline) {\n        this.css = !this.options.less || this.options.inline;\n    } else {\n        var pathValue = this.getPath();\n        if (pathValue && /[#\\.\\&\\?\\/]css([\\?;].*)?$/.test(pathValue)) {\n            this.css = true;\n        }\n    }\n    this.copyVisibilityInfo(visibilityInfo);\n};\n\n//\n// The actual import node doesn't return anything, when converted to CSS.\n// The reason is that it's used at the evaluation stage, so that the rules\n// it imports can be treated like any other rules.\n//\n// In `eval`, we make sure all Import nodes get evaluated, recursively, so\n// we end up with a flat structure, which can easily be imported in the parent\n// ruleset.\n//\nImport.prototype = new Node();\nImport.prototype.type = \"Import\";\nImport.prototype.accept = function (visitor) {\n    if (this.features) {\n        this.features = visitor.visit(this.features);\n    }\n    this.path = visitor.visit(this.path);\n    if (!this.options.plugin && !this.options.inline && this.root) {\n        this.root = visitor.visit(this.root);\n    }\n};\nImport.prototype.genCSS = function (context, output) {\n    if (this.css && this.path.currentFileInfo.reference === undefined) {\n        output.add(\"@import \", this.currentFileInfo, this.index);\n        this.path.genCSS(context, output);\n        if (this.features) {\n            output.add(\" \");\n            this.features.genCSS(context, output);\n        }\n        output.add(';');\n    }\n};\nImport.prototype.getPath = function () {\n    return (this.path instanceof URL) ?\n        this.path.value.value : this.path.value;\n};\nImport.prototype.isVariableImport = function () {\n    var path = this.path;\n    if (path instanceof URL) {\n        path = path.value;\n    }\n    if (path instanceof Quoted) {\n        return path.containsVariables();\n    }\n\n    return true;\n};\nImport.prototype.evalForImport = function (context) {\n    var path = this.path;\n\n    if (path instanceof URL) {\n        path = path.value;\n    }\n\n    return new Import(path.eval(context), this.features, this.options, this.index, this.currentFileInfo, this.visibilityInfo());\n};\nImport.prototype.evalPath = function (context) {\n    var path = this.path.eval(context);\n    var rootpath = this.currentFileInfo && this.currentFileInfo.rootpath;\n\n    if (!(path instanceof URL)) {\n        if (rootpath) {\n            var pathValue = path.value;\n            // Add the base path if the import is relative\n            if (pathValue && context.isPathRelative(pathValue)) {\n                path.value = rootpath + pathValue;\n            }\n        }\n        path.value = context.normalizePath(path.value);\n    }\n\n    return path;\n};\nImport.prototype.eval = function (context) {\n    var result = this.doEval(context);\n    if (this.options.reference || this.blocksVisibility()) {\n        if (result.length || result.length === 0) {\n            result.forEach(function (node) {\n                    node.addVisibilityBlock();\n                }\n            );\n        } else {\n            result.addVisibilityBlock();\n        }\n    }\n    return result;\n};\nImport.prototype.doEval = function (context) {\n    var ruleset, registry,\n        features = this.features && this.features.eval(context);\n\n    if (this.options.plugin) {\n        registry = context.frames[0] && context.frames[0].functionRegistry;\n        if ( registry && this.root && this.root.functions ) {\n            registry.addMultiple( this.root.functions );\n        }\n        return [];\n    }\n\n    if (this.skip) {\n        if (typeof this.skip === \"function\") {\n            this.skip = this.skip();\n        }\n        if (this.skip) {\n            return [];\n        }\n    }\n    if (this.options.inline) {\n        var contents = new Anonymous(this.root, 0,\n          {\n              filename: this.importedFilename,\n              reference: this.path.currentFileInfo && this.path.currentFileInfo.reference\n          }, true, true);\n\n        return this.features ? new Media([contents], this.features.value) : [contents];\n    } else if (this.css) {\n        var newImport = new Import(this.evalPath(context), features, this.options, this.index);\n        if (!newImport.css && this.error) {\n            throw this.error;\n        }\n        return newImport;\n    } else {\n        ruleset = new Ruleset(null, this.root.rules.slice(0));\n        ruleset.evalImports(context);\n\n        return this.features ? new Media(ruleset.rules, this.features.value) : ruleset.rules;\n    }\n};\nmodule.exports = Import;\n\n},{\"./anonymous\":46,\"./media\":66,\"./node\":70,\"./quoted\":73,\"./ruleset\":76,\"./url\":80}],62:[function(require,module,exports){\nvar tree = {};\n\ntree.Node = require('./node');\ntree.Alpha = require('./alpha');\ntree.Color = require('./color');\ntree.Directive = require('./directive');\ntree.DetachedRuleset = require('./detached-ruleset');\ntree.Operation = require('./operation');\ntree.Dimension = require('./dimension');\ntree.Unit = require('./unit');\ntree.Keyword = require('./keyword');\ntree.Variable = require('./variable');\ntree.Ruleset = require('./ruleset');\ntree.Element = require('./element');\ntree.Attribute = require('./attribute');\ntree.Combinator = require('./combinator');\ntree.Selector = require('./selector');\ntree.Quoted = require('./quoted');\ntree.Expression = require('./expression');\ntree.Rule = require('./rule');\ntree.Call = require('./call');\ntree.URL = require('./url');\ntree.Import = require('./import');\ntree.mixin = {\n    Call: require('./mixin-call'),\n    Definition: require('./mixin-definition')\n};\ntree.Comment = require('./comment');\ntree.Anonymous = require('./anonymous');\ntree.Value = require('./value');\ntree.JavaScript = require('./javascript');\ntree.Assignment = require('./assignment');\ntree.Condition = require('./condition');\ntree.Paren = require('./paren');\ntree.Media = require('./media');\ntree.UnicodeDescriptor = require('./unicode-descriptor');\ntree.Negative = require('./negative');\ntree.Extend = require('./extend');\ntree.RulesetCall = require('./ruleset-call');\n\nmodule.exports = tree;\n\n},{\"./alpha\":45,\"./anonymous\":46,\"./assignment\":47,\"./attribute\":48,\"./call\":49,\"./color\":50,\"./combinator\":51,\"./comment\":52,\"./condition\":53,\"./detached-ruleset\":55,\"./dimension\":56,\"./directive\":57,\"./element\":58,\"./expression\":59,\"./extend\":60,\"./import\":61,\"./javascript\":63,\"./keyword\":65,\"./media\":66,\"./mixin-call\":67,\"./mixin-definition\":68,\"./negative\":69,\"./node\":70,\"./operation\":71,\"./paren\":72,\"./quoted\":73,\"./rule\":74,\"./ruleset\":76,\"./ruleset-call\":75,\"./selector\":77,\"./unicode-descriptor\":78,\"./unit\":79,\"./url\":80,\"./value\":81,\"./variable\":82}],63:[function(require,module,exports){\nvar JsEvalNode = require(\"./js-eval-node\"),\n    Dimension = require(\"./dimension\"),\n    Quoted = require(\"./quoted\"),\n    Anonymous = require(\"./anonymous\");\n\nvar JavaScript = function (string, escaped, index, currentFileInfo) {\n    this.escaped = escaped;\n    this.expression = string;\n    this.index = index;\n    this.currentFileInfo = currentFileInfo;\n};\nJavaScript.prototype = new JsEvalNode();\nJavaScript.prototype.type = \"JavaScript\";\nJavaScript.prototype.eval = function(context) {\n    var result = this.evaluateJavaScript(this.expression, context);\n\n    if (typeof result === 'number') {\n        return new Dimension(result);\n    } else if (typeof result === 'string') {\n        return new Quoted('\"' + result + '\"', result, this.escaped, this.index);\n    } else if (Array.isArray(result)) {\n        return new Anonymous(result.join(', '));\n    } else {\n        return new Anonymous(result);\n    }\n};\n\nmodule.exports = JavaScript;\n\n},{\"./anonymous\":46,\"./dimension\":56,\"./js-eval-node\":64,\"./quoted\":73}],64:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    Variable = require(\"./variable\");\n\nvar JsEvalNode = function() {\n};\nJsEvalNode.prototype = new Node();\n\nJsEvalNode.prototype.evaluateJavaScript = function (expression, context) {\n    var result,\n        that = this,\n        evalContext = {};\n\n    if (context.javascriptEnabled !== undefined && !context.javascriptEnabled) {\n        throw { message: \"You are using JavaScript, which has been disabled.\",\n            filename: this.currentFileInfo.filename,\n            index: this.index };\n    }\n\n    expression = expression.replace(/@\\{([\\w-]+)\\}/g, function (_, name) {\n        return that.jsify(new Variable('@' + name, that.index, that.currentFileInfo).eval(context));\n    });\n\n    try {\n        expression = new Function('return (' + expression + ')');\n    } catch (e) {\n        throw { message: \"JavaScript evaluation error: \" + e.message + \" from `\" + expression + \"`\" ,\n            filename: this.currentFileInfo.filename,\n            index: this.index };\n    }\n\n    var variables = context.frames[0].variables();\n    for (var k in variables) {\n        if (variables.hasOwnProperty(k)) {\n            /*jshint loopfunc:true */\n            evalContext[k.slice(1)] = {\n                value: variables[k].value,\n                toJS: function () {\n                    return this.value.eval(context).toCSS();\n                }\n            };\n        }\n    }\n\n    try {\n        result = expression.call(evalContext);\n    } catch (e) {\n        throw { message: \"JavaScript evaluation error: '\" + e.name + ': ' + e.message.replace(/[\"]/g, \"'\") + \"'\" ,\n            filename: this.currentFileInfo.filename,\n            index: this.index };\n    }\n    return result;\n};\nJsEvalNode.prototype.jsify = function (obj) {\n    if (Array.isArray(obj.value) && (obj.value.length > 1)) {\n        return '[' + obj.value.map(function (v) { return v.toCSS(); }).join(', ') + ']';\n    } else {\n        return obj.toCSS();\n    }\n};\n\nmodule.exports = JsEvalNode;\n\n},{\"./node\":70,\"./variable\":82}],65:[function(require,module,exports){\nvar Node = require(\"./node\");\n\nvar Keyword = function (value) { this.value = value; };\nKeyword.prototype = new Node();\nKeyword.prototype.type = \"Keyword\";\nKeyword.prototype.genCSS = function (context, output) {\n    if (this.value === '%') { throw { type: \"Syntax\", message: \"Invalid % without number\" }; }\n    output.add(this.value);\n};\n\nKeyword.True = new Keyword('true');\nKeyword.False = new Keyword('false');\n\nmodule.exports = Keyword;\n\n},{\"./node\":70}],66:[function(require,module,exports){\nvar Ruleset = require(\"./ruleset\"),\n    Value = require(\"./value\"),\n    Selector = require(\"./selector\"),\n    Anonymous = require(\"./anonymous\"),\n    Expression = require(\"./expression\"),\n    Directive = require(\"./directive\");\n\nvar Media = function (value, features, index, currentFileInfo, visibilityInfo) {\n    this.index = index;\n    this.currentFileInfo = currentFileInfo;\n\n    var selectors = (new Selector([], null, null, this.index, this.currentFileInfo)).createEmptySelectors();\n\n    this.features = new Value(features);\n    this.rules = [new Ruleset(selectors, value)];\n    this.rules[0].allowImports = true;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.allowRoot = true;\n};\nMedia.prototype = new Directive();\nMedia.prototype.type = \"Media\";\nMedia.prototype.isRulesetLike = true;\nMedia.prototype.accept = function (visitor) {\n    if (this.features) {\n        this.features = visitor.visit(this.features);\n    }\n    if (this.rules) {\n        this.rules = visitor.visitArray(this.rules);\n    }\n};\nMedia.prototype.genCSS = function (context, output) {\n    output.add('@media ', this.currentFileInfo, this.index);\n    this.features.genCSS(context, output);\n    this.outputRuleset(context, output, this.rules);\n};\nMedia.prototype.eval = function (context) {\n    if (!context.mediaBlocks) {\n        context.mediaBlocks = [];\n        context.mediaPath = [];\n    }\n\n    var media = new Media(null, [], this.index, this.currentFileInfo, this.visibilityInfo());\n    if (this.debugInfo) {\n        this.rules[0].debugInfo = this.debugInfo;\n        media.debugInfo = this.debugInfo;\n    }\n    var strictMathBypass = false;\n    if (!context.strictMath) {\n        strictMathBypass = true;\n        context.strictMath = true;\n    }\n    try {\n        media.features = this.features.eval(context);\n    }\n    finally {\n        if (strictMathBypass) {\n            context.strictMath = false;\n        }\n    }\n\n    context.mediaPath.push(media);\n    context.mediaBlocks.push(media);\n\n    this.rules[0].functionRegistry = context.frames[0].functionRegistry.inherit();\n    context.frames.unshift(this.rules[0]);\n    media.rules = [this.rules[0].eval(context)];\n    context.frames.shift();\n\n    context.mediaPath.pop();\n\n    return context.mediaPath.length === 0 ? media.evalTop(context) :\n                media.evalNested(context);\n};\nMedia.prototype.evalTop = function (context) {\n    var result = this;\n\n    // Render all dependent Media blocks.\n    if (context.mediaBlocks.length > 1) {\n        var selectors = (new Selector([], null, null, this.index, this.currentFileInfo)).createEmptySelectors();\n        result = new Ruleset(selectors, context.mediaBlocks);\n        result.multiMedia = true;\n        result.copyVisibilityInfo(this.visibilityInfo());\n    }\n\n    delete context.mediaBlocks;\n    delete context.mediaPath;\n\n    return result;\n};\nMedia.prototype.evalNested = function (context) {\n    var i, value,\n        path = context.mediaPath.concat([this]);\n\n    // Extract the media-query conditions separated with `,` (OR).\n    for (i = 0; i < path.length; i++) {\n        value = path[i].features instanceof Value ?\n                    path[i].features.value : path[i].features;\n        path[i] = Array.isArray(value) ? value : [value];\n    }\n\n    // Trace all permutations to generate the resulting media-query.\n    //\n    // (a, b and c) with nested (d, e) ->\n    //    a and d\n    //    a and e\n    //    b and c and d\n    //    b and c and e\n    this.features = new Value(this.permute(path).map(function (path) {\n        path = path.map(function (fragment) {\n            return fragment.toCSS ? fragment : new Anonymous(fragment);\n        });\n\n        for (i = path.length - 1; i > 0; i--) {\n            path.splice(i, 0, new Anonymous(\"and\"));\n        }\n\n        return new Expression(path);\n    }));\n\n    // Fake a tree-node that doesn't output anything.\n    return new Ruleset([], []);\n};\nMedia.prototype.permute = function (arr) {\n    if (arr.length === 0) {\n        return [];\n    } else if (arr.length === 1) {\n        return arr[0];\n    } else {\n        var result = [];\n        var rest = this.permute(arr.slice(1));\n        for (var i = 0; i < rest.length; i++) {\n            for (var j = 0; j < arr[0].length; j++) {\n                result.push([arr[0][j]].concat(rest[i]));\n            }\n        }\n        return result;\n    }\n};\nMedia.prototype.bubbleSelectors = function (selectors) {\n    if (!selectors) {\n        return;\n    }\n    this.rules = [new Ruleset(selectors.slice(0), [this.rules[0]])];\n};\nmodule.exports = Media;\n\n},{\"./anonymous\":46,\"./directive\":57,\"./expression\":59,\"./ruleset\":76,\"./selector\":77,\"./value\":81}],67:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    Selector = require(\"./selector\"),\n    MixinDefinition = require(\"./mixin-definition\"),\n    defaultFunc = require(\"../functions/default\");\n\nvar MixinCall = function (elements, args, index, currentFileInfo, important) {\n    this.selector = new Selector(elements);\n    this.arguments = args || [];\n    this.index = index;\n    this.currentFileInfo = currentFileInfo;\n    this.important = important;\n    this.allowRoot = true;\n};\nMixinCall.prototype = new Node();\nMixinCall.prototype.type = \"MixinCall\";\nMixinCall.prototype.accept = function (visitor) {\n    if (this.selector) {\n        this.selector = visitor.visit(this.selector);\n    }\n    if (this.arguments.length) {\n        this.arguments = visitor.visitArray(this.arguments);\n    }\n};\nMixinCall.prototype.eval = function (context) {\n    var mixins, mixin, mixinPath, args = [], arg, argValue,\n        rules = [], match = false, i, m, f, isRecursive, isOneFound,\n        candidates = [], candidate, conditionResult = [], defaultResult, defFalseEitherCase = -1,\n        defNone = 0, defTrue = 1, defFalse = 2, count, originalRuleset, noArgumentsFilter;\n\n    function calcDefGroup(mixin, mixinPath) {\n        var f, p, namespace;\n\n        for (f = 0; f < 2; f++) {\n            conditionResult[f] = true;\n            defaultFunc.value(f);\n            for (p = 0; p < mixinPath.length && conditionResult[f]; p++) {\n                namespace = mixinPath[p];\n                if (namespace.matchCondition) {\n                    conditionResult[f] = conditionResult[f] && namespace.matchCondition(null, context);\n                }\n            }\n            if (mixin.matchCondition) {\n                conditionResult[f] = conditionResult[f] && mixin.matchCondition(args, context);\n            }\n        }\n        if (conditionResult[0] || conditionResult[1]) {\n            if (conditionResult[0] != conditionResult[1]) {\n                return conditionResult[1] ?\n                    defTrue : defFalse;\n            }\n\n            return defNone;\n        }\n        return defFalseEitherCase;\n    }\n\n    for (i = 0; i < this.arguments.length; i++) {\n        arg = this.arguments[i];\n        argValue = arg.value.eval(context);\n        if (arg.expand && Array.isArray(argValue.value)) {\n            argValue = argValue.value;\n            for (m = 0; m < argValue.length; m++) {\n                args.push({value: argValue[m]});\n            }\n        } else {\n            args.push({name: arg.name, value: argValue});\n        }\n    }\n\n    noArgumentsFilter = function(rule) {return rule.matchArgs(null, context);};\n\n    for (i = 0; i < context.frames.length; i++) {\n        if ((mixins = context.frames[i].find(this.selector, null, noArgumentsFilter)).length > 0) {\n            isOneFound = true;\n\n            // To make `default()` function independent of definition order we have two \"subpasses\" here.\n            // At first we evaluate each guard *twice* (with `default() == true` and `default() == false`),\n            // and build candidate list with corresponding flags. Then, when we know all possible matches,\n            // we make a final decision.\n\n            for (m = 0; m < mixins.length; m++) {\n                mixin = mixins[m].rule;\n                mixinPath = mixins[m].path;\n                isRecursive = false;\n                for (f = 0; f < context.frames.length; f++) {\n                    if ((!(mixin instanceof MixinDefinition)) && mixin === (context.frames[f].originalRuleset || context.frames[f])) {\n                        isRecursive = true;\n                        break;\n                    }\n                }\n                if (isRecursive) {\n                    continue;\n                }\n\n                if (mixin.matchArgs(args, context)) {\n                    candidate = {mixin: mixin, group: calcDefGroup(mixin, mixinPath)};\n\n                    if (candidate.group !== defFalseEitherCase) {\n                        candidates.push(candidate);\n                    }\n\n                    match = true;\n                }\n            }\n\n            defaultFunc.reset();\n\n            count = [0, 0, 0];\n            for (m = 0; m < candidates.length; m++) {\n                count[candidates[m].group]++;\n            }\n\n            if (count[defNone] > 0) {\n                defaultResult = defFalse;\n            } else {\n                defaultResult = defTrue;\n                if ((count[defTrue] + count[defFalse]) > 1) {\n                    throw { type: 'Runtime',\n                        message: 'Ambiguous use of `default()` found when matching for `' + this.format(args) + '`',\n                        index: this.index, filename: this.currentFileInfo.filename };\n                }\n            }\n\n            for (m = 0; m < candidates.length; m++) {\n                candidate = candidates[m].group;\n                if ((candidate === defNone) || (candidate === defaultResult)) {\n                    try {\n                        mixin = candidates[m].mixin;\n                        if (!(mixin instanceof MixinDefinition)) {\n                            originalRuleset = mixin.originalRuleset || mixin;\n                            mixin = new MixinDefinition(\"\", [], mixin.rules, null, false, null, originalRuleset.visibilityInfo());\n                            mixin.originalRuleset = originalRuleset;\n                        }\n                        var newRules = mixin.evalCall(context, args, this.important).rules;\n                        this._setVisibilityToReplacement(newRules);\n                        Array.prototype.push.apply(rules, newRules);\n                    } catch (e) {\n                        throw { message: e.message, index: this.index, filename: this.currentFileInfo.filename, stack: e.stack };\n                    }\n                }\n            }\n\n            if (match) {\n                return rules;\n            }\n        }\n    }\n    if (isOneFound) {\n        throw { type:    'Runtime',\n            message: 'No matching definition was found for `' + this.format(args) + '`',\n            index:   this.index, filename: this.currentFileInfo.filename };\n    } else {\n        throw { type:    'Name',\n            message: this.selector.toCSS().trim() + \" is undefined\",\n            index:   this.index, filename: this.currentFileInfo.filename };\n    }\n};\n\nMixinCall.prototype._setVisibilityToReplacement = function (replacement) {\n    var i, rule;\n    if (this.blocksVisibility()) {\n        for (i = 0; i < replacement.length; i++) {\n            rule = replacement[i];\n            rule.addVisibilityBlock();\n        }\n    }\n};\nMixinCall.prototype.format = function (args) {\n    return this.selector.toCSS().trim() + '(' +\n        (args ? args.map(function (a) {\n            var argValue = \"\";\n            if (a.name) {\n                argValue += a.name + \":\";\n            }\n            if (a.value.toCSS) {\n                argValue += a.value.toCSS();\n            } else {\n                argValue += \"???\";\n            }\n            return argValue;\n        }).join(', ') : \"\") + \")\";\n};\nmodule.exports = MixinCall;\n\n},{\"../functions/default\":20,\"./mixin-definition\":68,\"./node\":70,\"./selector\":77}],68:[function(require,module,exports){\nvar Selector = require(\"./selector\"),\n    Element = require(\"./element\"),\n    Ruleset = require(\"./ruleset\"),\n    Rule = require(\"./rule\"),\n    Expression = require(\"./expression\"),\n    contexts = require(\"../contexts\");\n\nvar Definition = function (name, params, rules, condition, variadic, frames, visibilityInfo) {\n    this.name = name;\n    this.selectors = [new Selector([new Element(null, name, this.index, this.currentFileInfo)])];\n    this.params = params;\n    this.condition = condition;\n    this.variadic = variadic;\n    this.arity = params.length;\n    this.rules = rules;\n    this._lookups = {};\n    var optionalParameters = [];\n    this.required = params.reduce(function (count, p) {\n        if (!p.name || (p.name && !p.value)) {\n            return count + 1;\n        }\n        else {\n            optionalParameters.push(p.name);\n            return count;\n        }\n    }, 0);\n    this.optionalParameters = optionalParameters;\n    this.frames = frames;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.allowRoot = true;\n};\nDefinition.prototype = new Ruleset();\nDefinition.prototype.type = \"MixinDefinition\";\nDefinition.prototype.evalFirst = true;\nDefinition.prototype.accept = function (visitor) {\n    if (this.params && this.params.length) {\n        this.params = visitor.visitArray(this.params);\n    }\n    this.rules = visitor.visitArray(this.rules);\n    if (this.condition) {\n        this.condition = visitor.visit(this.condition);\n    }\n};\nDefinition.prototype.evalParams = function (context, mixinEnv, args, evaldArguments) {\n    /*jshint boss:true */\n    var frame = new Ruleset(null, null),\n        varargs, arg,\n        params = this.params.slice(0),\n        i, j, val, name, isNamedFound, argIndex, argsLength = 0;\n\n    if (mixinEnv.frames && mixinEnv.frames[0] && mixinEnv.frames[0].functionRegistry) {\n        frame.functionRegistry = mixinEnv.frames[0].functionRegistry.inherit();\n    }\n    mixinEnv = new contexts.Eval(mixinEnv, [frame].concat(mixinEnv.frames));\n\n    if (args) {\n        args = args.slice(0);\n        argsLength = args.length;\n\n        for (i = 0; i < argsLength; i++) {\n            arg = args[i];\n            if (name = (arg && arg.name)) {\n                isNamedFound = false;\n                for (j = 0; j < params.length; j++) {\n                    if (!evaldArguments[j] && name === params[j].name) {\n                        evaldArguments[j] = arg.value.eval(context);\n                        frame.prependRule(new Rule(name, arg.value.eval(context)));\n                        isNamedFound = true;\n                        break;\n                    }\n                }\n                if (isNamedFound) {\n                    args.splice(i, 1);\n                    i--;\n                    continue;\n                } else {\n                    throw { type: 'Runtime', message: \"Named argument for \" + this.name +\n                        ' ' + args[i].name + ' not found' };\n                }\n            }\n        }\n    }\n    argIndex = 0;\n    for (i = 0; i < params.length; i++) {\n        if (evaldArguments[i]) { continue; }\n\n        arg = args && args[argIndex];\n\n        if (name = params[i].name) {\n            if (params[i].variadic) {\n                varargs = [];\n                for (j = argIndex; j < argsLength; j++) {\n                    varargs.push(args[j].value.eval(context));\n                }\n                frame.prependRule(new Rule(name, new Expression(varargs).eval(context)));\n            } else {\n                val = arg && arg.value;\n                if (val) {\n                    val = val.eval(context);\n                } else if (params[i].value) {\n                    val = params[i].value.eval(mixinEnv);\n                    frame.resetCache();\n                } else {\n                    throw { type: 'Runtime', message: \"wrong number of arguments for \" + this.name +\n                        ' (' + argsLength + ' for ' + this.arity + ')' };\n                }\n\n                frame.prependRule(new Rule(name, val));\n                evaldArguments[i] = val;\n            }\n        }\n\n        if (params[i].variadic && args) {\n            for (j = argIndex; j < argsLength; j++) {\n                evaldArguments[j] = args[j].value.eval(context);\n            }\n        }\n        argIndex++;\n    }\n\n    return frame;\n};\nDefinition.prototype.makeImportant = function() {\n    var rules = !this.rules ? this.rules : this.rules.map(function (r) {\n        if (r.makeImportant) {\n            return r.makeImportant(true);\n        } else {\n            return r;\n        }\n    });\n    var result = new Definition(this.name, this.params, rules, this.condition, this.variadic, this.frames);\n    return result;\n};\nDefinition.prototype.eval = function (context) {\n    return new Definition(this.name, this.params, this.rules, this.condition, this.variadic, this.frames || context.frames.slice(0));\n};\nDefinition.prototype.evalCall = function (context, args, important) {\n    var _arguments = [],\n        mixinFrames = this.frames ? this.frames.concat(context.frames) : context.frames,\n        frame = this.evalParams(context, new contexts.Eval(context, mixinFrames), args, _arguments),\n        rules, ruleset;\n\n    frame.prependRule(new Rule('@arguments', new Expression(_arguments).eval(context)));\n\n    rules = this.rules.slice(0);\n\n    ruleset = new Ruleset(null, rules);\n    ruleset.originalRuleset = this;\n    ruleset = ruleset.eval(new contexts.Eval(context, [this, frame].concat(mixinFrames)));\n    if (important) {\n        ruleset = ruleset.makeImportant();\n    }\n    return ruleset;\n};\nDefinition.prototype.matchCondition = function (args, context) {\n    if (this.condition && !this.condition.eval(\n        new contexts.Eval(context,\n            [this.evalParams(context, /* the parameter variables*/\n                new contexts.Eval(context, this.frames ? this.frames.concat(context.frames) : context.frames), args, [])]\n            .concat(this.frames || []) // the parent namespace/mixin frames\n            .concat(context.frames)))) { // the current environment frames\n        return false;\n    }\n    return true;\n};\nDefinition.prototype.matchArgs = function (args, context) {\n    var allArgsCnt = (args && args.length) || 0, len, optionalParameters = this.optionalParameters;\n    var requiredArgsCnt = !args ? 0 : args.reduce(function (count, p) {\n        if (optionalParameters.indexOf(p.name) < 0) {\n            return count + 1;\n        } else {\n            return count;\n        }\n    }, 0);\n\n    if (! this.variadic) {\n        if (requiredArgsCnt < this.required) {\n            return false;\n        }\n        if (allArgsCnt > this.params.length) {\n            return false;\n        }\n    } else {\n        if (requiredArgsCnt < (this.required - 1)) {\n            return false;\n        }\n    }\n\n    // check patterns\n    len = Math.min(requiredArgsCnt, this.arity);\n\n    for (var i = 0; i < len; i++) {\n        if (!this.params[i].name && !this.params[i].variadic) {\n            if (args[i].value.eval(context).toCSS() != this.params[i].value.eval(context).toCSS()) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\nmodule.exports = Definition;\n\n},{\"../contexts\":11,\"./element\":58,\"./expression\":59,\"./rule\":74,\"./ruleset\":76,\"./selector\":77}],69:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    Operation = require(\"./operation\"),\n    Dimension = require(\"./dimension\");\n\nvar Negative = function (node) {\n    this.value = node;\n};\nNegative.prototype = new Node();\nNegative.prototype.type = \"Negative\";\nNegative.prototype.genCSS = function (context, output) {\n    output.add('-');\n    this.value.genCSS(context, output);\n};\nNegative.prototype.eval = function (context) {\n    if (context.isMathOn()) {\n        return (new Operation('*', [new Dimension(-1), this.value])).eval(context);\n    }\n    return new Negative(this.value.eval(context));\n};\nmodule.exports = Negative;\n\n},{\"./dimension\":56,\"./node\":70,\"./operation\":71}],70:[function(require,module,exports){\nvar Node = function() {\n};\nNode.prototype.toCSS = function (context) {\n    var strs = [];\n    this.genCSS(context, {\n        add: function(chunk, fileInfo, index) {\n            strs.push(chunk);\n        },\n        isEmpty: function () {\n            return strs.length === 0;\n        }\n    });\n    return strs.join('');\n};\nNode.prototype.genCSS = function (context, output) {\n    output.add(this.value);\n};\nNode.prototype.accept = function (visitor) {\n    this.value = visitor.visit(this.value);\n};\nNode.prototype.eval = function () { return this; };\nNode.prototype._operate = function (context, op, a, b) {\n    switch (op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/': return a / b;\n    }\n};\nNode.prototype.fround = function(context, value) {\n    var precision = context && context.numPrecision;\n    //add \"epsilon\" to ensure numbers like 1.000000005 (represented as 1.000000004999....) are properly rounded...\n    return (precision == null) ? value : Number((value + 2e-16).toFixed(precision));\n};\nNode.compare = function (a, b) {\n    /* returns:\n     -1: a < b\n     0: a = b\n     1: a > b\n     and *any* other value for a != b (e.g. undefined, NaN, -2 etc.) */\n\n    if ((a.compare) &&\n        // for \"symmetric results\" force toCSS-based comparison\n        // of Quoted or Anonymous if either value is one of those\n        !(b.type === \"Quoted\" || b.type === \"Anonymous\")) {\n        return a.compare(b);\n    } else if (b.compare) {\n        return -b.compare(a);\n    } else if (a.type !== b.type) {\n        return undefined;\n    }\n\n    a = a.value;\n    b = b.value;\n    if (!Array.isArray(a)) {\n        return a === b ? 0 : undefined;\n    }\n    if (a.length !== b.length) {\n        return undefined;\n    }\n    for (var i = 0; i < a.length; i++) {\n        if (Node.compare(a[i], b[i]) !== 0) {\n            return undefined;\n        }\n    }\n    return 0;\n};\n\nNode.numericCompare = function (a, b) {\n    return a  <  b ? -1\n        : a === b ?  0\n        : a  >  b ?  1 : undefined;\n};\n// Returns true if this node represents root of ast imported by reference\nNode.prototype.blocksVisibility = function () {\n    if (this.visibilityBlocks == null) {\n        this.visibilityBlocks = 0;\n    }\n    return this.visibilityBlocks !== 0;\n};\nNode.prototype.addVisibilityBlock = function () {\n    if (this.visibilityBlocks == null) {\n        this.visibilityBlocks = 0;\n    }\n    this.visibilityBlocks = this.visibilityBlocks + 1;\n};\nNode.prototype.removeVisibilityBlock = function () {\n    if (this.visibilityBlocks == null) {\n        this.visibilityBlocks = 0;\n    }\n    this.visibilityBlocks = this.visibilityBlocks - 1;\n};\n//Turns on node visibility - if called node will be shown in output regardless\n//of whether it comes from import by reference or not\nNode.prototype.ensureVisibility = function () {\n    this.nodeVisible = true;\n};\n//Turns off node visibility - if called node will NOT be shown in output regardless\n//of whether it comes from import by reference or not\nNode.prototype.ensureInvisibility = function () {\n    this.nodeVisible = false;\n};\n// return values:\n// false - the node must not be visible\n// true - the node must be visible\n// undefined or null - the node has the same visibility as its parent\nNode.prototype.isVisible = function () {\n    return this.nodeVisible;\n};\nNode.prototype.visibilityInfo = function() {\n    return {\n        visibilityBlocks: this.visibilityBlocks,\n        nodeVisible: this.nodeVisible\n    };\n};\nNode.prototype.copyVisibilityInfo = function(info) {\n    if (!info) {\n        return;\n    }\n    this.visibilityBlocks = info.visibilityBlocks;\n    this.nodeVisible = info.nodeVisible;\n};\nmodule.exports = Node;\n\n},{}],71:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    Color = require(\"./color\"),\n    Dimension = require(\"./dimension\");\n\nvar Operation = function (op, operands, isSpaced) {\n    this.op = op.trim();\n    this.operands = operands;\n    this.isSpaced = isSpaced;\n};\nOperation.prototype = new Node();\nOperation.prototype.type = \"Operation\";\nOperation.prototype.accept = function (visitor) {\n    this.operands = visitor.visit(this.operands);\n};\nOperation.prototype.eval = function (context) {\n    var a = this.operands[0].eval(context),\n        b = this.operands[1].eval(context);\n\n    if (context.isMathOn()) {\n        if (a instanceof Dimension && b instanceof Color) {\n            a = a.toColor();\n        }\n        if (b instanceof Dimension && a instanceof Color) {\n            b = b.toColor();\n        }\n        if (!a.operate) {\n            throw { type: \"Operation\",\n                    message: \"Operation on an invalid type\" };\n        }\n\n        return a.operate(context, this.op, b);\n    } else {\n        return new Operation(this.op, [a, b], this.isSpaced);\n    }\n};\nOperation.prototype.genCSS = function (context, output) {\n    this.operands[0].genCSS(context, output);\n    if (this.isSpaced) {\n        output.add(\" \");\n    }\n    output.add(this.op);\n    if (this.isSpaced) {\n        output.add(\" \");\n    }\n    this.operands[1].genCSS(context, output);\n};\n\nmodule.exports = Operation;\n\n},{\"./color\":50,\"./dimension\":56,\"./node\":70}],72:[function(require,module,exports){\nvar Node = require(\"./node\");\n\nvar Paren = function (node) {\n    this.value = node;\n};\nParen.prototype = new Node();\nParen.prototype.type = \"Paren\";\nParen.prototype.genCSS = function (context, output) {\n    output.add('(');\n    this.value.genCSS(context, output);\n    output.add(')');\n};\nParen.prototype.eval = function (context) {\n    return new Paren(this.value.eval(context));\n};\nmodule.exports = Paren;\n\n},{\"./node\":70}],73:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    JsEvalNode = require(\"./js-eval-node\"),\n    Variable = require(\"./variable\");\n\nvar Quoted = function (str, content, escaped, index, currentFileInfo) {\n    this.escaped = (escaped == null) ? true : escaped;\n    this.value = content || '';\n    this.quote = str.charAt(0);\n    this.index = index;\n    this.currentFileInfo = currentFileInfo;\n};\nQuoted.prototype = new JsEvalNode();\nQuoted.prototype.type = \"Quoted\";\nQuoted.prototype.genCSS = function (context, output) {\n    if (!this.escaped) {\n        output.add(this.quote, this.currentFileInfo, this.index);\n    }\n    output.add(this.value);\n    if (!this.escaped) {\n        output.add(this.quote);\n    }\n};\nQuoted.prototype.containsVariables = function() {\n    return this.value.match(/(`([^`]+)`)|@\\{([\\w-]+)\\}/);\n};\nQuoted.prototype.eval = function (context) {\n    var that = this, value = this.value;\n    var javascriptReplacement = function (_, exp) {\n        return String(that.evaluateJavaScript(exp, context));\n    };\n    var interpolationReplacement = function (_, name) {\n        var v = new Variable('@' + name, that.index, that.currentFileInfo).eval(context, true);\n        return (v instanceof Quoted) ? v.value : v.toCSS();\n    };\n    function iterativeReplace(value, regexp, replacementFnc) {\n        var evaluatedValue = value;\n        do {\n            value = evaluatedValue;\n            evaluatedValue = value.replace(regexp, replacementFnc);\n        } while (value !== evaluatedValue);\n        return evaluatedValue;\n    }\n    value = iterativeReplace(value, /`([^`]+)`/g, javascriptReplacement);\n    value = iterativeReplace(value, /@\\{([\\w-]+)\\}/g, interpolationReplacement);\n    return new Quoted(this.quote + value + this.quote, value, this.escaped, this.index, this.currentFileInfo);\n};\nQuoted.prototype.compare = function (other) {\n    // when comparing quoted strings allow the quote to differ\n    if (other.type === \"Quoted\" && !this.escaped && !other.escaped) {\n        return Node.numericCompare(this.value, other.value);\n    } else {\n        return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;\n    }\n};\nmodule.exports = Quoted;\n\n},{\"./js-eval-node\":64,\"./node\":70,\"./variable\":82}],74:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    Value = require(\"./value\"),\n    Keyword = require(\"./keyword\");\n\nvar Rule = function (name, value, important, merge, index, currentFileInfo, inline, variable) {\n    this.name = name;\n    this.value = (value instanceof Node) ? value : new Value([value]); //value instanceof tree.Value || value instanceof tree.Ruleset ??\n    this.important = important ? ' ' + important.trim() : '';\n    this.merge = merge;\n    this.index = index;\n    this.currentFileInfo = currentFileInfo;\n    this.inline = inline || false;\n    this.variable = (variable !== undefined) ? variable\n        : (name.charAt && (name.charAt(0) === '@'));\n    this.allowRoot = true;\n};\n\nfunction evalName(context, name) {\n    var value = \"\", i, n = name.length,\n        output = {add: function (s) {value += s;}};\n    for (i = 0; i < n; i++) {\n        name[i].eval(context).genCSS(context, output);\n    }\n    return value;\n}\n\nRule.prototype = new Node();\nRule.prototype.type = \"Rule\";\nRule.prototype.genCSS = function (context, output) {\n    output.add(this.name + (context.compress ? ':' : ': '), this.currentFileInfo, this.index);\n    try {\n        this.value.genCSS(context, output);\n    }\n    catch(e) {\n        e.index = this.index;\n        e.filename = this.currentFileInfo.filename;\n        throw e;\n    }\n    output.add(this.important + ((this.inline || (context.lastRule && context.compress)) ? \"\" : \";\"), this.currentFileInfo, this.index);\n};\nRule.prototype.eval = function (context) {\n    var strictMathBypass = false, name = this.name, evaldValue, variable = this.variable;\n    if (typeof name !== \"string\") {\n        // expand 'primitive' name directly to get\n        // things faster (~10% for benchmark.less):\n        name = (name.length === 1) && (name[0] instanceof Keyword) ?\n                name[0].value : evalName(context, name);\n        variable = false; // never treat expanded interpolation as new variable name\n    }\n    if (name === \"font\" && !context.strictMath) {\n        strictMathBypass = true;\n        context.strictMath = true;\n    }\n    try {\n        context.importantScope.push({});\n        evaldValue = this.value.eval(context);\n\n        if (!this.variable && evaldValue.type === \"DetachedRuleset\") {\n            throw { message: \"Rulesets cannot be evaluated on a property.\",\n                    index: this.index, filename: this.currentFileInfo.filename };\n        }\n        var important = this.important,\n            importantResult = context.importantScope.pop();\n        if (!important && importantResult.important) {\n            important = importantResult.important;\n        }\n\n        return new Rule(name,\n                          evaldValue,\n                          important,\n                          this.merge,\n                          this.index, this.currentFileInfo, this.inline,\n                              variable);\n    }\n    catch(e) {\n        if (typeof e.index !== 'number') {\n            e.index = this.index;\n            e.filename = this.currentFileInfo.filename;\n        }\n        throw e;\n    }\n    finally {\n        if (strictMathBypass) {\n            context.strictMath = false;\n        }\n    }\n};\nRule.prototype.makeImportant = function () {\n    return new Rule(this.name,\n                          this.value,\n                          \"!important\",\n                          this.merge,\n                          this.index, this.currentFileInfo, this.inline);\n};\n\nmodule.exports = Rule;\n},{\"./keyword\":65,\"./node\":70,\"./value\":81}],75:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    Variable = require(\"./variable\");\n\nvar RulesetCall = function (variable) {\n    this.variable = variable;\n    this.allowRoot = true;\n};\nRulesetCall.prototype = new Node();\nRulesetCall.prototype.type = \"RulesetCall\";\nRulesetCall.prototype.eval = function (context) {\n    var detachedRuleset = new Variable(this.variable).eval(context);\n    return detachedRuleset.callEval(context);\n};\nmodule.exports = RulesetCall;\n\n},{\"./node\":70,\"./variable\":82}],76:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    Rule = require(\"./rule\"),\n    Selector = require(\"./selector\"),\n    Element = require(\"./element\"),\n    Paren = require(\"./paren\"),\n    contexts = require(\"../contexts\"),\n    globalFunctionRegistry = require(\"../functions/function-registry\"),\n    defaultFunc = require(\"../functions/default\"),\n    getDebugInfo = require(\"./debug-info\");\n\nvar Ruleset = function (selectors, rules, strictImports, visibilityInfo) {\n    this.selectors = selectors;\n    this.rules = rules;\n    this._lookups = {};\n    this.strictImports = strictImports;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.allowRoot = true;\n};\nRuleset.prototype = new Node();\nRuleset.prototype.type = \"Ruleset\";\nRuleset.prototype.isRuleset = true;\nRuleset.prototype.isRulesetLike = true;\nRuleset.prototype.accept = function (visitor) {\n    if (this.paths) {\n        this.paths = visitor.visitArray(this.paths, true);\n    } else if (this.selectors) {\n        this.selectors = visitor.visitArray(this.selectors);\n    }\n    if (this.rules && this.rules.length) {\n        this.rules = visitor.visitArray(this.rules);\n    }\n};\nRuleset.prototype.eval = function (context) {\n    var thisSelectors = this.selectors, selectors,\n        selCnt, selector, i, hasOnePassingSelector = false;\n\n    if (thisSelectors && (selCnt = thisSelectors.length)) {\n        selectors = [];\n        defaultFunc.error({\n            type: \"Syntax\",\n            message: \"it is currently only allowed in parametric mixin guards,\"\n        });\n        for (i = 0; i < selCnt; i++) {\n            selector = thisSelectors[i].eval(context);\n            selectors.push(selector);\n            if (selector.evaldCondition) {\n                hasOnePassingSelector = true;\n            }\n        }\n        defaultFunc.reset();\n    } else {\n        hasOnePassingSelector = true;\n    }\n\n    var rules = this.rules ? this.rules.slice(0) : null,\n        ruleset = new Ruleset(selectors, rules, this.strictImports, this.visibilityInfo()),\n        rule, subRule;\n\n    ruleset.originalRuleset = this;\n    ruleset.root = this.root;\n    ruleset.firstRoot = this.firstRoot;\n    ruleset.allowImports = this.allowImports;\n\n    if (this.debugInfo) {\n        ruleset.debugInfo = this.debugInfo;\n    }\n\n    if (!hasOnePassingSelector) {\n        rules.length = 0;\n    }\n\n    // inherit a function registry from the frames stack when possible;\n    // otherwise from the global registry\n    ruleset.functionRegistry = (function (frames) {\n        var i = 0,\n            n = frames.length,\n            found;\n        for ( ; i !== n ; ++i ) {\n            found = frames[ i ].functionRegistry;\n            if ( found ) { return found; }\n        }\n        return globalFunctionRegistry;\n    }(context.frames)).inherit();\n\n    // push the current ruleset to the frames stack\n    var ctxFrames = context.frames;\n    ctxFrames.unshift(ruleset);\n\n    // currrent selectors\n    var ctxSelectors = context.selectors;\n    if (!ctxSelectors) {\n        context.selectors = ctxSelectors = [];\n    }\n    ctxSelectors.unshift(this.selectors);\n\n    // Evaluate imports\n    if (ruleset.root || ruleset.allowImports || !ruleset.strictImports) {\n        ruleset.evalImports(context);\n    }\n\n    // Store the frames around mixin definitions,\n    // so they can be evaluated like closures when the time comes.\n    var rsRules = ruleset.rules, rsRuleCnt = rsRules ? rsRules.length : 0;\n    for (i = 0; i < rsRuleCnt; i++) {\n        if (rsRules[i].evalFirst) {\n            rsRules[i] = rsRules[i].eval(context);\n        }\n    }\n\n    var mediaBlockCount = (context.mediaBlocks && context.mediaBlocks.length) || 0;\n\n    // Evaluate mixin calls.\n    for (i = 0; i < rsRuleCnt; i++) {\n        if (rsRules[i].type === \"MixinCall\") {\n            /*jshint loopfunc:true */\n            rules = rsRules[i].eval(context).filter(function(r) {\n                if ((r instanceof Rule) && r.variable) {\n                    // do not pollute the scope if the variable is\n                    // already there. consider returning false here\n                    // but we need a way to \"return\" variable from mixins\n                    return !(ruleset.variable(r.name));\n                }\n                return true;\n            });\n            rsRules.splice.apply(rsRules, [i, 1].concat(rules));\n            rsRuleCnt += rules.length - 1;\n            i += rules.length - 1;\n            ruleset.resetCache();\n        } else if (rsRules[i].type === \"RulesetCall\") {\n            /*jshint loopfunc:true */\n            rules = rsRules[i].eval(context).rules.filter(function(r) {\n                if ((r instanceof Rule) && r.variable) {\n                    // do not pollute the scope at all\n                    return false;\n                }\n                return true;\n            });\n            rsRules.splice.apply(rsRules, [i, 1].concat(rules));\n            rsRuleCnt += rules.length - 1;\n            i += rules.length - 1;\n            ruleset.resetCache();\n        }\n    }\n\n    // Evaluate everything else\n    for (i = 0; i < rsRules.length; i++) {\n        rule = rsRules[i];\n        if (!rule.evalFirst) {\n            rsRules[i] = rule = rule.eval ? rule.eval(context) : rule;\n        }\n    }\n\n    // Evaluate everything else\n    for (i = 0; i < rsRules.length; i++) {\n        rule = rsRules[i];\n        // for rulesets, check if it is a css guard and can be removed\n        if (rule instanceof Ruleset && rule.selectors && rule.selectors.length === 1) {\n            // check if it can be folded in (e.g. & where)\n            if (rule.selectors[0].isJustParentSelector()) {\n                rsRules.splice(i--, 1);\n\n                for (var j = 0; j < rule.rules.length; j++) {\n                    subRule = rule.rules[j];\n                    subRule.copyVisibilityInfo(rule.visibilityInfo());\n                    if (!(subRule instanceof Rule) || !subRule.variable) {\n                        rsRules.splice(++i, 0, subRule);\n                    }\n                }\n            }\n        }\n    }\n\n    // Pop the stack\n    ctxFrames.shift();\n    ctxSelectors.shift();\n\n    if (context.mediaBlocks) {\n        for (i = mediaBlockCount; i < context.mediaBlocks.length; i++) {\n            context.mediaBlocks[i].bubbleSelectors(selectors);\n        }\n    }\n\n    return ruleset;\n};\nRuleset.prototype.evalImports = function(context) {\n    var rules = this.rules, i, importRules;\n    if (!rules) { return; }\n\n    for (i = 0; i < rules.length; i++) {\n        if (rules[i].type === \"Import\") {\n            importRules = rules[i].eval(context);\n            if (importRules && (importRules.length || importRules.length === 0)) {\n                rules.splice.apply(rules, [i, 1].concat(importRules));\n                i+= importRules.length - 1;\n            } else {\n                rules.splice(i, 1, importRules);\n            }\n            this.resetCache();\n        }\n    }\n};\nRuleset.prototype.makeImportant = function() {\n    var result = new Ruleset(this.selectors, this.rules.map(function (r) {\n        if (r.makeImportant) {\n            return r.makeImportant();\n        } else {\n            return r;\n        }\n    }), this.strictImports, this.visibilityInfo());\n\n    return result;\n};\nRuleset.prototype.matchArgs = function (args) {\n    return !args || args.length === 0;\n};\n// lets you call a css selector with a guard\nRuleset.prototype.matchCondition = function (args, context) {\n    var lastSelector = this.selectors[this.selectors.length - 1];\n    if (!lastSelector.evaldCondition) {\n        return false;\n    }\n    if (lastSelector.condition &&\n        !lastSelector.condition.eval(\n            new contexts.Eval(context,\n                context.frames))) {\n        return false;\n    }\n    return true;\n};\nRuleset.prototype.resetCache = function () {\n    this._rulesets = null;\n    this._variables = null;\n    this._lookups = {};\n};\nRuleset.prototype.variables = function () {\n    if (!this._variables) {\n        this._variables = !this.rules ? {} : this.rules.reduce(function (hash, r) {\n            if (r instanceof Rule && r.variable === true) {\n                hash[r.name] = r;\n            }\n            // when evaluating variables in an import statement, imports have not been eval'd\n            // so we need to go inside import statements.\n            // guard against root being a string (in the case of inlined less)\n            if (r.type === \"Import\" && r.root && r.root.variables) {\n                var vars = r.root.variables();\n                for (var name in vars) {\n                    if (vars.hasOwnProperty(name)) {\n                        hash[name] = vars[name];\n                    }\n                }\n            }\n            return hash;\n        }, {});\n    }\n    return this._variables;\n};\nRuleset.prototype.variable = function (name) {\n    return this.variables()[name];\n};\nRuleset.prototype.rulesets = function () {\n    if (!this.rules) { return []; }\n\n    var filtRules = [], rules = this.rules, cnt = rules.length,\n        i, rule;\n\n    for (i = 0; i < cnt; i++) {\n        rule = rules[i];\n        if (rule.isRuleset) {\n            filtRules.push(rule);\n        }\n    }\n\n    return filtRules;\n};\nRuleset.prototype.prependRule = function (rule) {\n    var rules = this.rules;\n    if (rules) {\n        rules.unshift(rule);\n    } else {\n        this.rules = [ rule ];\n    }\n};\nRuleset.prototype.find = function (selector, self, filter) {\n    self = self || this;\n    var rules = [], match, foundMixins,\n        key = selector.toCSS();\n\n    if (key in this._lookups) { return this._lookups[key]; }\n\n    this.rulesets().forEach(function (rule) {\n        if (rule !== self) {\n            for (var j = 0; j < rule.selectors.length; j++) {\n                match = selector.match(rule.selectors[j]);\n                if (match) {\n                    if (selector.elements.length > match) {\n                        if (!filter || filter(rule)) {\n                            foundMixins = rule.find(new Selector(selector.elements.slice(match)), self, filter);\n                            for (var i = 0; i < foundMixins.length; ++i) {\n                                foundMixins[i].path.push(rule);\n                            }\n                            Array.prototype.push.apply(rules, foundMixins);\n                        }\n                    } else {\n                        rules.push({ rule: rule, path: []});\n                    }\n                    break;\n                }\n            }\n        }\n    });\n    this._lookups[key] = rules;\n    return rules;\n};\nRuleset.prototype.genCSS = function (context, output) {\n    var i, j,\n        charsetRuleNodes = [],\n        ruleNodes = [],\n        debugInfo,     // Line number debugging\n        rule,\n        path;\n\n    context.tabLevel = (context.tabLevel || 0);\n\n    if (!this.root) {\n        context.tabLevel++;\n    }\n\n    var tabRuleStr = context.compress ? '' : Array(context.tabLevel + 1).join(\"  \"),\n        tabSetStr = context.compress ? '' : Array(context.tabLevel).join(\"  \"),\n        sep;\n\n    function isRulesetLikeNode(rule) {\n        // if it has nested rules, then it should be treated like a ruleset\n        // medias and comments do not have nested rules, but should be treated like rulesets anyway\n        // some directives and anonymous nodes are ruleset like, others are not\n        if (typeof rule.isRulesetLike === \"boolean\") {\n            return rule.isRulesetLike;\n        } else if (typeof rule.isRulesetLike === \"function\") {\n            return rule.isRulesetLike();\n        }\n\n        //anything else is assumed to be a rule\n        return false;\n    }\n\n    var charsetNodeIndex = 0;\n    var importNodeIndex = 0;\n    for (i = 0; i < this.rules.length; i++) {\n        rule = this.rules[i];\n        if (rule.type === \"Comment\") {\n            if (importNodeIndex === i) {\n                importNodeIndex++;\n            }\n            ruleNodes.push(rule);\n        } else if (rule.isCharset && rule.isCharset()) {\n            ruleNodes.splice(charsetNodeIndex, 0, rule);\n            charsetNodeIndex++;\n            importNodeIndex++;\n        } else if (rule.type === \"Import\") {\n            ruleNodes.splice(importNodeIndex, 0, rule);\n            importNodeIndex++;\n        } else {\n            ruleNodes.push(rule);\n        }\n    }\n    ruleNodes = charsetRuleNodes.concat(ruleNodes);\n\n    // If this is the root node, we don't render\n    // a selector, or {}.\n    if (!this.root) {\n        debugInfo = getDebugInfo(context, this, tabSetStr);\n\n        if (debugInfo) {\n            output.add(debugInfo);\n            output.add(tabSetStr);\n        }\n\n        var paths = this.paths, pathCnt = paths.length,\n            pathSubCnt;\n\n        sep = context.compress ? ',' : (',\\n' + tabSetStr);\n\n        for (i = 0; i < pathCnt; i++) {\n            path = paths[i];\n            if (!(pathSubCnt = path.length)) { continue; }\n            if (i > 0) { output.add(sep); }\n\n            context.firstSelector = true;\n            path[0].genCSS(context, output);\n\n            context.firstSelector = false;\n            for (j = 1; j < pathSubCnt; j++) {\n                path[j].genCSS(context, output);\n            }\n        }\n\n        output.add((context.compress ? '{' : ' {\\n') + tabRuleStr);\n    }\n\n    // Compile rules and rulesets\n    for (i = 0; i < ruleNodes.length; i++) {\n        rule = ruleNodes[i];\n\n        if (i + 1 === ruleNodes.length) {\n            context.lastRule = true;\n        }\n\n        var currentLastRule = context.lastRule;\n        if (isRulesetLikeNode(rule)) {\n            context.lastRule = false;\n        }\n\n        if (rule.genCSS) {\n            rule.genCSS(context, output);\n        } else if (rule.value) {\n            output.add(rule.value.toString());\n        }\n\n        context.lastRule = currentLastRule;\n\n        if (!context.lastRule) {\n            output.add(context.compress ? '' : ('\\n' + tabRuleStr));\n        } else {\n            context.lastRule = false;\n        }\n    }\n\n    if (!this.root) {\n        output.add((context.compress ? '}' : '\\n' + tabSetStr + '}'));\n        context.tabLevel--;\n    }\n\n    if (!output.isEmpty() && !context.compress && this.firstRoot) {\n        output.add('\\n');\n    }\n};\n\nRuleset.prototype.joinSelectors = function (paths, context, selectors) {\n    for (var s = 0; s < selectors.length; s++) {\n        this.joinSelector(paths, context, selectors[s]);\n    }\n};\n\nRuleset.prototype.joinSelector = function (paths, context, selector) {\n\n    function createParenthesis(elementsToPak, originalElement) {\n        var replacementParen, j;\n        if (elementsToPak.length === 0) {\n            replacementParen = new Paren(elementsToPak[0]);\n        } else {\n            var insideParent = [];\n            for (j = 0; j < elementsToPak.length; j++) {\n                insideParent.push(new Element(null, elementsToPak[j], originalElement.index, originalElement.currentFileInfo));\n            }\n            replacementParen = new Paren(new Selector(insideParent));\n        }\n        return replacementParen;\n    }\n\n    function createSelector(containedElement, originalElement) {\n        var element, selector;\n        element = new Element(null, containedElement, originalElement.index, originalElement.currentFileInfo);\n        selector = new Selector([element]);\n        return selector;\n    }\n\n    // joins selector path from `beginningPath` with selector path in `addPath`\n    // `replacedElement` contains element that is being replaced by `addPath`\n    // returns concatenated path\n    function addReplacementIntoPath(beginningPath, addPath, replacedElement, originalSelector) {\n        var newSelectorPath, lastSelector, newJoinedSelector;\n        // our new selector path\n        newSelectorPath = [];\n\n        //construct the joined selector - if & is the first thing this will be empty,\n        // if not newJoinedSelector will be the last set of elements in the selector\n        if (beginningPath.length > 0) {\n            newSelectorPath = beginningPath.slice(0);\n            lastSelector = newSelectorPath.pop();\n            newJoinedSelector = originalSelector.createDerived(lastSelector.elements.slice(0));\n        }\n        else {\n            newJoinedSelector = originalSelector.createDerived([]);\n        }\n\n        if (addPath.length > 0) {\n            // /deep/ is a combinator that is valid without anything in front of it\n            // so if the & does not have a combinator that is \"\" or \" \" then\n            // and there is a combinator on the parent, then grab that.\n            // this also allows + a { & .b { .a & { ... though not sure why you would want to do that\n            var combinator = replacedElement.combinator, parentEl = addPath[0].elements[0];\n            if (combinator.emptyOrWhitespace && !parentEl.combinator.emptyOrWhitespace) {\n                combinator = parentEl.combinator;\n            }\n            // join the elements so far with the first part of the parent\n            newJoinedSelector.elements.push(new Element(combinator, parentEl.value, replacedElement.index, replacedElement.currentFileInfo));\n            newJoinedSelector.elements = newJoinedSelector.elements.concat(addPath[0].elements.slice(1));\n        }\n\n        // now add the joined selector - but only if it is not empty\n        if (newJoinedSelector.elements.length !== 0) {\n            newSelectorPath.push(newJoinedSelector);\n        }\n\n        //put together the parent selectors after the join (e.g. the rest of the parent)\n        if (addPath.length > 1) {\n            var restOfPath = addPath.slice(1);\n            restOfPath = restOfPath.map(function (selector) {\n                return selector.createDerived(selector.elements, []);\n            });\n            newSelectorPath = newSelectorPath.concat(restOfPath);\n        }\n        return newSelectorPath;\n    }\n\n    // joins selector path from `beginningPath` with every selector path in `addPaths` array\n    // `replacedElement` contains element that is being replaced by `addPath`\n    // returns array with all concatenated paths\n    function addAllReplacementsIntoPath( beginningPath, addPaths, replacedElement, originalSelector, result) {\n        var j;\n        for (j = 0; j < beginningPath.length; j++) {\n            var newSelectorPath = addReplacementIntoPath(beginningPath[j], addPaths, replacedElement, originalSelector);\n            result.push(newSelectorPath);\n        }\n        return result;\n    }\n\n    function mergeElementsOnToSelectors(elements, selectors) {\n        var i, sel;\n\n        if (elements.length === 0) {\n            return ;\n        }\n        if (selectors.length === 0) {\n            selectors.push([ new Selector(elements) ]);\n            return;\n        }\n\n        for (i = 0; i < selectors.length; i++) {\n            sel = selectors[i];\n\n            // if the previous thing in sel is a parent this needs to join on to it\n            if (sel.length > 0) {\n                sel[sel.length - 1] = sel[sel.length - 1].createDerived(sel[sel.length - 1].elements.concat(elements));\n            }\n            else {\n                sel.push(new Selector(elements));\n            }\n        }\n    }\n\n    // replace all parent selectors inside `inSelector` by content of `context` array\n    // resulting selectors are returned inside `paths` array\n    // returns true if `inSelector` contained at least one parent selector\n    function replaceParentSelector(paths, context, inSelector) {\n        // The paths are [[Selector]]\n        // The first list is a list of comma separated selectors\n        // The inner list is a list of inheritance separated selectors\n        // e.g.\n        // .a, .b {\n        //   .c {\n        //   }\n        // }\n        // == [[.a] [.c]] [[.b] [.c]]\n        //\n        var i, j, k, currentElements, newSelectors, selectorsMultiplied, sel, el, hadParentSelector = false, length, lastSelector;\n        function findNestedSelector(element) {\n            var maybeSelector;\n            if (element.value.type !== 'Paren') {\n                return null;\n            }\n\n            maybeSelector = element.value.value;\n            if (maybeSelector.type !== 'Selector') {\n                return null;\n            }\n\n            return maybeSelector;\n        }\n\n        // the elements from the current selector so far\n        currentElements = [];\n        // the current list of new selectors to add to the path.\n        // We will build it up. We initiate it with one empty selector as we \"multiply\" the new selectors\n        // by the parents\n        newSelectors = [\n            []\n        ];\n\n        for (i = 0; i < inSelector.elements.length; i++) {\n            el = inSelector.elements[i];\n            // non parent reference elements just get added\n            if (el.value !== \"&\") {\n                var nestedSelector = findNestedSelector(el);\n                if (nestedSelector != null) {\n                    // merge the current list of non parent selector elements\n                    // on to the current list of selectors to add\n                    mergeElementsOnToSelectors(currentElements, newSelectors);\n\n                    var nestedPaths = [], replaced, replacedNewSelectors = [];\n                    replaced = replaceParentSelector(nestedPaths, context, nestedSelector);\n                    hadParentSelector = hadParentSelector || replaced;\n                    //the nestedPaths array should have only one member - replaceParentSelector does not multiply selectors\n                    for (k = 0; k < nestedPaths.length; k++) {\n                        var replacementSelector = createSelector(createParenthesis(nestedPaths[k], el), el);\n                        addAllReplacementsIntoPath(newSelectors, [replacementSelector], el, inSelector, replacedNewSelectors);\n                    }\n                    newSelectors = replacedNewSelectors;\n                    currentElements = [];\n\n                } else {\n                    currentElements.push(el);\n                }\n\n            } else {\n                hadParentSelector = true;\n                // the new list of selectors to add\n                selectorsMultiplied = [];\n\n                // merge the current list of non parent selector elements\n                // on to the current list of selectors to add\n                mergeElementsOnToSelectors(currentElements, newSelectors);\n\n                // loop through our current selectors\n                for (j = 0; j < newSelectors.length; j++) {\n                    sel = newSelectors[j];\n                    // if we don't have any parent paths, the & might be in a mixin so that it can be used\n                    // whether there are parents or not\n                    if (context.length === 0) {\n                        // the combinator used on el should now be applied to the next element instead so that\n                        // it is not lost\n                        if (sel.length > 0) {\n                            sel[0].elements.push(new Element(el.combinator, '', el.index, el.currentFileInfo));\n                        }\n                        selectorsMultiplied.push(sel);\n                    }\n                    else {\n                        // and the parent selectors\n                        for (k = 0; k < context.length; k++) {\n                            // We need to put the current selectors\n                            // then join the last selector's elements on to the parents selectors\n                            var newSelectorPath = addReplacementIntoPath(sel, context[k], el, inSelector);\n                            // add that to our new set of selectors\n                            selectorsMultiplied.push(newSelectorPath);\n                        }\n                    }\n                }\n\n                // our new selectors has been multiplied, so reset the state\n                newSelectors = selectorsMultiplied;\n                currentElements = [];\n            }\n        }\n\n        // if we have any elements left over (e.g. .a& .b == .b)\n        // add them on to all the current selectors\n        mergeElementsOnToSelectors(currentElements, newSelectors);\n\n        for (i = 0; i < newSelectors.length; i++) {\n            length = newSelectors[i].length;\n            if (length > 0) {\n                paths.push(newSelectors[i]);\n                lastSelector = newSelectors[i][length - 1];\n                newSelectors[i][length - 1] = lastSelector.createDerived(lastSelector.elements, inSelector.extendList);\n                //newSelectors[i][length - 1].copyVisibilityInfo(inSelector.visibilityInfo());\n            }\n        }\n\n        return hadParentSelector;\n    }\n\n    function deriveSelector(visibilityInfo, deriveFrom) {\n        var newSelector = deriveFrom.createDerived(deriveFrom.elements, deriveFrom.extendList, deriveFrom.evaldCondition);\n        newSelector.copyVisibilityInfo(visibilityInfo);\n        return newSelector;\n    }\n\n    // joinSelector code follows\n    var i, newPaths, hadParentSelector;\n\n    newPaths = [];\n    hadParentSelector = replaceParentSelector(newPaths, context, selector);\n\n    if (!hadParentSelector) {\n        if (context.length > 0) {\n            newPaths = [];\n            for (i = 0; i < context.length; i++) {\n                //var concatenated = [];\n                //context[i].forEach(function(entry) {\n                //    var newEntry = entry.createDerived(entry.elements, entry.extendList, entry.evaldCondition);\n                //    newEntry.copyVisibilityInfo(selector.visibilityInfo());\n                //    concatenated.push(newEntry);\n                //}, this);\n                var concatenated = context[i].map(deriveSelector.bind(this, selector.visibilityInfo()));\n\n                concatenated.push(selector);\n                newPaths.push(concatenated);\n            }\n        }\n        else {\n            newPaths = [[selector]];\n        }\n    }\n\n    for (i = 0; i < newPaths.length; i++) {\n        paths.push(newPaths[i]);\n    }\n\n};\nmodule.exports = Ruleset;\n\n},{\"../contexts\":11,\"../functions/default\":20,\"../functions/function-registry\":22,\"./debug-info\":54,\"./element\":58,\"./node\":70,\"./paren\":72,\"./rule\":74,\"./selector\":77}],77:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    Element = require(\"./element\");\n\nvar Selector = function (elements, extendList, condition, index, currentFileInfo, visibilityInfo) {\n    this.elements = elements;\n    this.extendList = extendList;\n    this.condition = condition;\n    this.currentFileInfo = currentFileInfo || {};\n    if (!condition) {\n        this.evaldCondition = true;\n    }\n    this.copyVisibilityInfo(visibilityInfo);\n};\nSelector.prototype = new Node();\nSelector.prototype.type = \"Selector\";\nSelector.prototype.accept = function (visitor) {\n    if (this.elements) {\n        this.elements = visitor.visitArray(this.elements);\n    }\n    if (this.extendList) {\n        this.extendList = visitor.visitArray(this.extendList);\n    }\n    if (this.condition) {\n        this.condition = visitor.visit(this.condition);\n    }\n};\nSelector.prototype.createDerived = function(elements, extendList, evaldCondition) {\n    var info = this.visibilityInfo();\n    evaldCondition = (evaldCondition != null) ? evaldCondition : this.evaldCondition;\n    var newSelector = new Selector(elements, extendList || this.extendList, null, this.index, this.currentFileInfo, info);\n    newSelector.evaldCondition = evaldCondition;\n    newSelector.mediaEmpty = this.mediaEmpty;\n    return newSelector;\n};\nSelector.prototype.createEmptySelectors = function() {\n    var el = new Element('', '&', this.index, this.currentFileInfo),\n        sels = [new Selector([el], null, null, this.index, this.currentFileInfo)];\n    sels[0].mediaEmpty = true;\n    return sels;\n};\nSelector.prototype.match = function (other) {\n    var elements = this.elements,\n        len = elements.length,\n        olen, i;\n\n    other.CacheElements();\n\n    olen = other._elements.length;\n    if (olen === 0 || len < olen) {\n        return 0;\n    } else {\n        for (i = 0; i < olen; i++) {\n            if (elements[i].value !== other._elements[i]) {\n                return 0;\n            }\n        }\n    }\n\n    return olen; // return number of matched elements\n};\nSelector.prototype.CacheElements = function() {\n    if (this._elements) {\n        return;\n    }\n\n    var elements = this.elements.map( function(v) {\n        return v.combinator.value + (v.value.value || v.value);\n    }).join(\"\").match(/[,&#\\*\\.\\w-]([\\w-]|(\\\\.))*/g);\n\n    if (elements) {\n        if (elements[0] === \"&\") {\n            elements.shift();\n        }\n    } else {\n        elements = [];\n    }\n\n    this._elements = elements;\n};\nSelector.prototype.isJustParentSelector = function() {\n    return !this.mediaEmpty &&\n        this.elements.length === 1 &&\n        this.elements[0].value === '&' &&\n        (this.elements[0].combinator.value === ' ' || this.elements[0].combinator.value === '');\n};\nSelector.prototype.eval = function (context) {\n    var evaldCondition = this.condition && this.condition.eval(context),\n        elements = this.elements, extendList = this.extendList;\n\n    elements = elements && elements.map(function (e) { return e.eval(context); });\n    extendList = extendList && extendList.map(function(extend) { return extend.eval(context); });\n\n    return this.createDerived(elements, extendList, evaldCondition);\n};\nSelector.prototype.genCSS = function (context, output) {\n    var i, element;\n    if ((!context || !context.firstSelector) && this.elements[0].combinator.value === \"\") {\n        output.add(' ', this.currentFileInfo, this.index);\n    }\n    if (!this._css) {\n        //TODO caching? speed comparison?\n        for (i = 0; i < this.elements.length; i++) {\n            element = this.elements[i];\n            element.genCSS(context, output);\n        }\n    }\n};\nSelector.prototype.getIsOutput = function() {\n    return this.evaldCondition;\n};\nmodule.exports = Selector;\n\n},{\"./element\":58,\"./node\":70}],78:[function(require,module,exports){\nvar Node = require(\"./node\");\n\nvar UnicodeDescriptor = function (value) {\n    this.value = value;\n};\nUnicodeDescriptor.prototype = new Node();\nUnicodeDescriptor.prototype.type = \"UnicodeDescriptor\";\n\nmodule.exports = UnicodeDescriptor;\n\n},{\"./node\":70}],79:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    unitConversions = require(\"../data/unit-conversions\");\n\nvar Unit = function (numerator, denominator, backupUnit) {\n    this.numerator = numerator ? numerator.slice(0).sort() : [];\n    this.denominator = denominator ? denominator.slice(0).sort() : [];\n    if (backupUnit) {\n        this.backupUnit = backupUnit;\n    } else if (numerator && numerator.length) {\n        this.backupUnit = numerator[0];\n    }\n};\n\nUnit.prototype = new Node();\nUnit.prototype.type = \"Unit\";\nUnit.prototype.clone = function () {\n    return new Unit(this.numerator.slice(0), this.denominator.slice(0), this.backupUnit);\n};\nUnit.prototype.genCSS = function (context, output) {\n    // Dimension checks the unit is singular and throws an error if in strict math mode.\n    var strictUnits = context && context.strictUnits;\n    if (this.numerator.length === 1) {\n        output.add(this.numerator[0]); // the ideal situation\n    } else if (!strictUnits && this.backupUnit) {\n        output.add(this.backupUnit);\n    } else if (!strictUnits && this.denominator.length) {\n        output.add(this.denominator[0]);\n    }\n};\nUnit.prototype.toString = function () {\n    var i, returnStr = this.numerator.join(\"*\");\n    for (i = 0; i < this.denominator.length; i++) {\n        returnStr += \"/\" + this.denominator[i];\n    }\n    return returnStr;\n};\nUnit.prototype.compare = function (other) {\n    return this.is(other.toString()) ? 0 : undefined;\n};\nUnit.prototype.is = function (unitString) {\n    return this.toString().toUpperCase() === unitString.toUpperCase();\n};\nUnit.prototype.isLength = function () {\n    return Boolean(this.toCSS().match(/px|em|%|in|cm|mm|pc|pt|ex/));\n};\nUnit.prototype.isEmpty = function () {\n    return this.numerator.length === 0 && this.denominator.length === 0;\n};\nUnit.prototype.isSingular = function() {\n    return this.numerator.length <= 1 && this.denominator.length === 0;\n};\nUnit.prototype.map = function(callback) {\n    var i;\n\n    for (i = 0; i < this.numerator.length; i++) {\n        this.numerator[i] = callback(this.numerator[i], false);\n    }\n\n    for (i = 0; i < this.denominator.length; i++) {\n        this.denominator[i] = callback(this.denominator[i], true);\n    }\n};\nUnit.prototype.usedUnits = function() {\n    var group, result = {}, mapUnit, groupName;\n\n    mapUnit = function (atomicUnit) {\n        /*jshint loopfunc:true */\n        if (group.hasOwnProperty(atomicUnit) && !result[groupName]) {\n            result[groupName] = atomicUnit;\n        }\n\n        return atomicUnit;\n    };\n\n    for (groupName in unitConversions) {\n        if (unitConversions.hasOwnProperty(groupName)) {\n            group = unitConversions[groupName];\n\n            this.map(mapUnit);\n        }\n    }\n\n    return result;\n};\nUnit.prototype.cancel = function () {\n    var counter = {}, atomicUnit, i;\n\n    for (i = 0; i < this.numerator.length; i++) {\n        atomicUnit = this.numerator[i];\n        counter[atomicUnit] = (counter[atomicUnit] || 0) + 1;\n    }\n\n    for (i = 0; i < this.denominator.length; i++) {\n        atomicUnit = this.denominator[i];\n        counter[atomicUnit] = (counter[atomicUnit] || 0) - 1;\n    }\n\n    this.numerator = [];\n    this.denominator = [];\n\n    for (atomicUnit in counter) {\n        if (counter.hasOwnProperty(atomicUnit)) {\n            var count = counter[atomicUnit];\n\n            if (count > 0) {\n                for (i = 0; i < count; i++) {\n                    this.numerator.push(atomicUnit);\n                }\n            } else if (count < 0) {\n                for (i = 0; i < -count; i++) {\n                    this.denominator.push(atomicUnit);\n                }\n            }\n        }\n    }\n\n    this.numerator.sort();\n    this.denominator.sort();\n};\nmodule.exports = Unit;\n\n},{\"../data/unit-conversions\":14,\"./node\":70}],80:[function(require,module,exports){\nvar Node = require(\"./node\");\n\nvar URL = function (val, index, currentFileInfo, isEvald) {\n    this.value = val;\n    this.currentFileInfo = currentFileInfo;\n    this.index = index;\n    this.isEvald = isEvald;\n};\nURL.prototype = new Node();\nURL.prototype.type = \"Url\";\nURL.prototype.accept = function (visitor) {\n    this.value = visitor.visit(this.value);\n};\nURL.prototype.genCSS = function (context, output) {\n    output.add(\"url(\");\n    this.value.genCSS(context, output);\n    output.add(\")\");\n};\nURL.prototype.eval = function (context) {\n    var val = this.value.eval(context),\n        rootpath;\n\n    if (!this.isEvald) {\n        // Add the base path if the URL is relative\n        rootpath = this.currentFileInfo && this.currentFileInfo.rootpath;\n        if (rootpath &&\n            typeof val.value === \"string\" &&\n            context.isPathRelative(val.value)) {\n\n            if (!val.quote) {\n                rootpath = rootpath.replace(/[\\(\\)'\"\\s]/g, function(match) { return \"\\\\\" + match; });\n            }\n            val.value = rootpath + val.value;\n        }\n\n        val.value = context.normalizePath(val.value);\n\n        // Add url args if enabled\n        if (context.urlArgs) {\n            if (!val.value.match(/^\\s*data:/)) {\n                var delimiter = val.value.indexOf('?') === -1 ? '?' : '&';\n                var urlArgs = delimiter + context.urlArgs;\n                if (val.value.indexOf('#') !== -1) {\n                    val.value = val.value.replace('#', urlArgs + '#');\n                } else {\n                    val.value += urlArgs;\n                }\n            }\n        }\n    }\n\n    return new URL(val, this.index, this.currentFileInfo, true);\n};\nmodule.exports = URL;\n\n},{\"./node\":70}],81:[function(require,module,exports){\nvar Node = require(\"./node\");\n\nvar Value = function (value) {\n    this.value = value;\n    if (!value) {\n        throw new Error(\"Value requires an array argument\");\n    }\n};\nValue.prototype = new Node();\nValue.prototype.type = \"Value\";\nValue.prototype.accept = function (visitor) {\n    if (this.value) {\n        this.value = visitor.visitArray(this.value);\n    }\n};\nValue.prototype.eval = function (context) {\n    if (this.value.length === 1) {\n        return this.value[0].eval(context);\n    } else {\n        return new Value(this.value.map(function (v) {\n            return v.eval(context);\n        }));\n    }\n};\nValue.prototype.genCSS = function (context, output) {\n    var i;\n    for (i = 0; i < this.value.length; i++) {\n        this.value[i].genCSS(context, output);\n        if (i + 1 < this.value.length) {\n            output.add((context && context.compress) ? ',' : ', ');\n        }\n    }\n};\nmodule.exports = Value;\n\n},{\"./node\":70}],82:[function(require,module,exports){\nvar Node = require(\"./node\");\n\nvar Variable = function (name, index, currentFileInfo) {\n    this.name = name;\n    this.index = index;\n    this.currentFileInfo = currentFileInfo || {};\n};\nVariable.prototype = new Node();\nVariable.prototype.type = \"Variable\";\nVariable.prototype.eval = function (context) {\n    var variable, name = this.name;\n\n    if (name.indexOf('@@') === 0) {\n        name = '@' + new Variable(name.slice(1), this.index, this.currentFileInfo).eval(context).value;\n    }\n\n    if (this.evaluating) {\n        throw { type: 'Name',\n                message: \"Recursive variable definition for \" + name,\n                filename: this.currentFileInfo.filename,\n                index: this.index };\n    }\n\n    this.evaluating = true;\n\n    variable = this.find(context.frames, function (frame) {\n        var v = frame.variable(name);\n        if (v) {\n            if (v.important) {\n                var importantScope = context.importantScope[context.importantScope.length - 1];\n                importantScope.important = v.important;\n            }\n            return v.value.eval(context);\n        }\n    });\n    if (variable) {\n        this.evaluating = false;\n        return variable;\n    } else {\n        throw { type: 'Name',\n                message: \"variable \" + name + \" is undefined\",\n                filename: this.currentFileInfo.filename,\n                index: this.index };\n    }\n};\nVariable.prototype.find = function (obj, fun) {\n    for (var i = 0, r; i < obj.length; i++) {\n        r = fun.call(obj, obj[i]);\n        if (r) { return r; }\n    }\n    return null;\n};\nmodule.exports = Variable;\n\n},{\"./node\":70}],83:[function(require,module,exports){\nmodule.exports = {\n    getLocation: function(index, inputStream) {\n        var n = index + 1,\n            line = null,\n            column = -1;\n\n        while (--n >= 0 && inputStream.charAt(n) !== '\\n') {\n            column++;\n        }\n\n        if (typeof index === 'number') {\n            line = (inputStream.slice(0, index).match(/\\n/g) || \"\").length;\n        }\n\n        return {\n            line: line,\n            column: column\n        };\n    }\n};\n\n},{}],84:[function(require,module,exports){\nvar tree = require(\"../tree\"),\n    Visitor = require(\"./visitor\"),\n    logger = require(\"../logger\");\n\n/*jshint loopfunc:true */\n\nvar ExtendFinderVisitor = function() {\n    this._visitor = new Visitor(this);\n    this.contexts = [];\n    this.allExtendsStack = [[]];\n};\n\nExtendFinderVisitor.prototype = {\n    run: function (root) {\n        root = this._visitor.visit(root);\n        root.allExtends = this.allExtendsStack[0];\n        return root;\n    },\n    visitRule: function (ruleNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    },\n    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    },\n    visitRuleset: function (rulesetNode, visitArgs) {\n        if (rulesetNode.root) {\n            return;\n        }\n\n        var i, j, extend, allSelectorsExtendList = [], extendList;\n\n        // get &:extend(.a); rules which apply to all selectors in this ruleset\n        var rules = rulesetNode.rules, ruleCnt = rules ? rules.length : 0;\n        for (i = 0; i < ruleCnt; i++) {\n            if (rulesetNode.rules[i] instanceof tree.Extend) {\n                allSelectorsExtendList.push(rules[i]);\n                rulesetNode.extendOnEveryPath = true;\n            }\n        }\n\n        // now find every selector and apply the extends that apply to all extends\n        // and the ones which apply to an individual extend\n        var paths = rulesetNode.paths;\n        for (i = 0; i < paths.length; i++) {\n            var selectorPath = paths[i],\n                selector = selectorPath[selectorPath.length - 1],\n                selExtendList = selector.extendList;\n\n            extendList = selExtendList ? selExtendList.slice(0).concat(allSelectorsExtendList)\n                                       : allSelectorsExtendList;\n\n            if (extendList) {\n                extendList = extendList.map(function(allSelectorsExtend) {\n                    return allSelectorsExtend.clone();\n                });\n            }\n\n            for (j = 0; j < extendList.length; j++) {\n                this.foundExtends = true;\n                extend = extendList[j];\n                extend.findSelfSelectors(selectorPath);\n                extend.ruleset = rulesetNode;\n                if (j === 0) { extend.firstExtendOnThisSelectorPath = true; }\n                this.allExtendsStack[this.allExtendsStack.length - 1].push(extend);\n            }\n        }\n\n        this.contexts.push(rulesetNode.selectors);\n    },\n    visitRulesetOut: function (rulesetNode) {\n        if (!rulesetNode.root) {\n            this.contexts.length = this.contexts.length - 1;\n        }\n    },\n    visitMedia: function (mediaNode, visitArgs) {\n        mediaNode.allExtends = [];\n        this.allExtendsStack.push(mediaNode.allExtends);\n    },\n    visitMediaOut: function (mediaNode) {\n        this.allExtendsStack.length = this.allExtendsStack.length - 1;\n    },\n    visitDirective: function (directiveNode, visitArgs) {\n        directiveNode.allExtends = [];\n        this.allExtendsStack.push(directiveNode.allExtends);\n    },\n    visitDirectiveOut: function (directiveNode) {\n        this.allExtendsStack.length = this.allExtendsStack.length - 1;\n    }\n};\n\nvar ProcessExtendsVisitor = function() {\n    this._visitor = new Visitor(this);\n};\n\nProcessExtendsVisitor.prototype = {\n    run: function(root) {\n        var extendFinder = new ExtendFinderVisitor();\n        this.extendIndices = {};\n        extendFinder.run(root);\n        if (!extendFinder.foundExtends) { return root; }\n        root.allExtends = root.allExtends.concat(this.doExtendChaining(root.allExtends, root.allExtends));\n        this.allExtendsStack = [root.allExtends];\n        var newRoot = this._visitor.visit(root);\n        this.checkExtendsForNonMatched(root.allExtends);\n        return newRoot;\n    },\n    checkExtendsForNonMatched: function(extendList) {\n        var indices = this.extendIndices;\n        extendList.filter(function(extend) {\n            return !extend.hasFoundMatches && extend.parent_ids.length == 1;\n        }).forEach(function(extend) {\n                var selector = \"_unknown_\";\n                try {\n                    selector = extend.selector.toCSS({});\n                }\n                catch(_) {}\n\n                if (!indices[extend.index + ' ' + selector]) {\n                    indices[extend.index + ' ' + selector] = true;\n                    logger.warn(\"extend '\" + selector + \"' has no matches\");\n                }\n            });\n    },\n    doExtendChaining: function (extendsList, extendsListTarget, iterationCount) {\n        //\n        // chaining is different from normal extension.. if we extend an extend then we are not just copying, altering\n        // and pasting the selector we would do normally, but we are also adding an extend with the same target selector\n        // this means this new extend can then go and alter other extends\n        //\n        // this method deals with all the chaining work - without it, extend is flat and doesn't work on other extend selectors\n        // this is also the most expensive.. and a match on one selector can cause an extension of a selector we had already\n        // processed if we look at each selector at a time, as is done in visitRuleset\n\n        var extendIndex, targetExtendIndex, matches, extendsToAdd = [], newSelector, extendVisitor = this, selectorPath,\n            extend, targetExtend, newExtend;\n\n        iterationCount = iterationCount || 0;\n\n        //loop through comparing every extend with every target extend.\n        // a target extend is the one on the ruleset we are looking at copy/edit/pasting in place\n        // e.g.  .a:extend(.b) {}  and .b:extend(.c) {} then the first extend extends the second one\n        // and the second is the target.\n        // the separation into two lists allows us to process a subset of chains with a bigger set, as is the\n        // case when processing media queries\n        for (extendIndex = 0; extendIndex < extendsList.length; extendIndex++) {\n            for (targetExtendIndex = 0; targetExtendIndex < extendsListTarget.length; targetExtendIndex++) {\n\n                extend = extendsList[extendIndex];\n                targetExtend = extendsListTarget[targetExtendIndex];\n\n                // look for circular references\n                if ( extend.parent_ids.indexOf( targetExtend.object_id ) >= 0 ) { continue; }\n\n                // find a match in the target extends self selector (the bit before :extend)\n                selectorPath = [targetExtend.selfSelectors[0]];\n                matches = extendVisitor.findMatch(extend, selectorPath);\n\n                if (matches.length) {\n                    extend.hasFoundMatches = true;\n\n                    // we found a match, so for each self selector..\n                    extend.selfSelectors.forEach(function(selfSelector) {\n                        var info = targetExtend.visibilityInfo();\n\n                        // process the extend as usual\n                        newSelector = extendVisitor.extendSelector(matches, selectorPath, selfSelector, extend.isVisible());\n\n                        // but now we create a new extend from it\n                        newExtend = new(tree.Extend)(targetExtend.selector, targetExtend.option, 0, targetExtend.currentFileInfo, info);\n                        newExtend.selfSelectors = newSelector;\n\n                        // add the extend onto the list of extends for that selector\n                        newSelector[newSelector.length - 1].extendList = [newExtend];\n\n                        // record that we need to add it.\n                        extendsToAdd.push(newExtend);\n                        newExtend.ruleset = targetExtend.ruleset;\n\n                        //remember its parents for circular references\n                        newExtend.parent_ids = newExtend.parent_ids.concat(targetExtend.parent_ids, extend.parent_ids);\n\n                        // only process the selector once.. if we have :extend(.a,.b) then multiple\n                        // extends will look at the same selector path, so when extending\n                        // we know that any others will be duplicates in terms of what is added to the css\n                        if (targetExtend.firstExtendOnThisSelectorPath) {\n                            newExtend.firstExtendOnThisSelectorPath = true;\n                            targetExtend.ruleset.paths.push(newSelector);\n                        }\n                    });\n                }\n            }\n        }\n\n        if (extendsToAdd.length) {\n            // try to detect circular references to stop a stack overflow.\n            // may no longer be needed.\n            this.extendChainCount++;\n            if (iterationCount > 100) {\n                var selectorOne = \"{unable to calculate}\";\n                var selectorTwo = \"{unable to calculate}\";\n                try {\n                    selectorOne = extendsToAdd[0].selfSelectors[0].toCSS();\n                    selectorTwo = extendsToAdd[0].selector.toCSS();\n                }\n                catch(e) {}\n                throw { message: \"extend circular reference detected. One of the circular extends is currently:\" +\n                    selectorOne + \":extend(\" + selectorTwo + \")\"};\n            }\n\n            // now process the new extends on the existing rules so that we can handle a extending b extending c extending\n            // d extending e...\n            return extendsToAdd.concat(extendVisitor.doExtendChaining(extendsToAdd, extendsListTarget, iterationCount + 1));\n        } else {\n            return extendsToAdd;\n        }\n    },\n    visitRule: function (ruleNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    },\n    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    },\n    visitSelector: function (selectorNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    },\n    visitRuleset: function (rulesetNode, visitArgs) {\n        if (rulesetNode.root) {\n            return;\n        }\n        var matches, pathIndex, extendIndex, allExtends = this.allExtendsStack[this.allExtendsStack.length - 1],\n            selectorsToAdd = [], extendVisitor = this, selectorPath;\n\n        // look at each selector path in the ruleset, find any extend matches and then copy, find and replace\n\n        for (extendIndex = 0; extendIndex < allExtends.length; extendIndex++) {\n            for (pathIndex = 0; pathIndex < rulesetNode.paths.length; pathIndex++) {\n                selectorPath = rulesetNode.paths[pathIndex];\n\n                // extending extends happens initially, before the main pass\n                if (rulesetNode.extendOnEveryPath) { continue; }\n                var extendList = selectorPath[selectorPath.length - 1].extendList;\n                if (extendList && extendList.length) { continue; }\n\n                matches = this.findMatch(allExtends[extendIndex], selectorPath);\n\n                if (matches.length) {\n                    allExtends[extendIndex].hasFoundMatches = true;\n\n                    allExtends[extendIndex].selfSelectors.forEach(function(selfSelector) {\n                        var extendedSelectors;\n                        extendedSelectors = extendVisitor.extendSelector(matches, selectorPath, selfSelector, allExtends[extendIndex].isVisible());\n                        selectorsToAdd.push(extendedSelectors);\n                    });\n                }\n            }\n        }\n        rulesetNode.paths = rulesetNode.paths.concat(selectorsToAdd);\n    },\n    findMatch: function (extend, haystackSelectorPath) {\n        //\n        // look through the haystack selector path to try and find the needle - extend.selector\n        // returns an array of selector matches that can then be replaced\n        //\n        var haystackSelectorIndex, hackstackSelector, hackstackElementIndex, haystackElement,\n            targetCombinator, i,\n            extendVisitor = this,\n            needleElements = extend.selector.elements,\n            potentialMatches = [], potentialMatch, matches = [];\n\n        // loop through the haystack elements\n        for (haystackSelectorIndex = 0; haystackSelectorIndex < haystackSelectorPath.length; haystackSelectorIndex++) {\n            hackstackSelector = haystackSelectorPath[haystackSelectorIndex];\n\n            for (hackstackElementIndex = 0; hackstackElementIndex < hackstackSelector.elements.length; hackstackElementIndex++) {\n\n                haystackElement = hackstackSelector.elements[hackstackElementIndex];\n\n                // if we allow elements before our match we can add a potential match every time. otherwise only at the first element.\n                if (extend.allowBefore || (haystackSelectorIndex === 0 && hackstackElementIndex === 0)) {\n                    potentialMatches.push({pathIndex: haystackSelectorIndex, index: hackstackElementIndex, matched: 0,\n                        initialCombinator: haystackElement.combinator});\n                }\n\n                for (i = 0; i < potentialMatches.length; i++) {\n                    potentialMatch = potentialMatches[i];\n\n                    // selectors add \" \" onto the first element. When we use & it joins the selectors together, but if we don't\n                    // then each selector in haystackSelectorPath has a space before it added in the toCSS phase. so we need to\n                    // work out what the resulting combinator will be\n                    targetCombinator = haystackElement.combinator.value;\n                    if (targetCombinator === '' && hackstackElementIndex === 0) {\n                        targetCombinator = ' ';\n                    }\n\n                    // if we don't match, null our match to indicate failure\n                    if (!extendVisitor.isElementValuesEqual(needleElements[potentialMatch.matched].value, haystackElement.value) ||\n                        (potentialMatch.matched > 0 && needleElements[potentialMatch.matched].combinator.value !== targetCombinator)) {\n                        potentialMatch = null;\n                    } else {\n                        potentialMatch.matched++;\n                    }\n\n                    // if we are still valid and have finished, test whether we have elements after and whether these are allowed\n                    if (potentialMatch) {\n                        potentialMatch.finished = potentialMatch.matched === needleElements.length;\n                        if (potentialMatch.finished &&\n                            (!extend.allowAfter &&\n                                (hackstackElementIndex + 1 < hackstackSelector.elements.length || haystackSelectorIndex + 1 < haystackSelectorPath.length))) {\n                            potentialMatch = null;\n                        }\n                    }\n                    // if null we remove, if not, we are still valid, so either push as a valid match or continue\n                    if (potentialMatch) {\n                        if (potentialMatch.finished) {\n                            potentialMatch.length = needleElements.length;\n                            potentialMatch.endPathIndex = haystackSelectorIndex;\n                            potentialMatch.endPathElementIndex = hackstackElementIndex + 1; // index after end of match\n                            potentialMatches.length = 0; // we don't allow matches to overlap, so start matching again\n                            matches.push(potentialMatch);\n                        }\n                    } else {\n                        potentialMatches.splice(i, 1);\n                        i--;\n                    }\n                }\n            }\n        }\n        return matches;\n    },\n    isElementValuesEqual: function(elementValue1, elementValue2) {\n        if (typeof elementValue1 === \"string\" || typeof elementValue2 === \"string\") {\n            return elementValue1 === elementValue2;\n        }\n        if (elementValue1 instanceof tree.Attribute) {\n            if (elementValue1.op !== elementValue2.op || elementValue1.key !== elementValue2.key) {\n                return false;\n            }\n            if (!elementValue1.value || !elementValue2.value) {\n                if (elementValue1.value || elementValue2.value) {\n                    return false;\n                }\n                return true;\n            }\n            elementValue1 = elementValue1.value.value || elementValue1.value;\n            elementValue2 = elementValue2.value.value || elementValue2.value;\n            return elementValue1 === elementValue2;\n        }\n        elementValue1 = elementValue1.value;\n        elementValue2 = elementValue2.value;\n        if (elementValue1 instanceof tree.Selector) {\n            if (!(elementValue2 instanceof tree.Selector) || elementValue1.elements.length !== elementValue2.elements.length) {\n                return false;\n            }\n            for (var i = 0; i  < elementValue1.elements.length; i++) {\n                if (elementValue1.elements[i].combinator.value !== elementValue2.elements[i].combinator.value) {\n                    if (i !== 0 || (elementValue1.elements[i].combinator.value || ' ') !== (elementValue2.elements[i].combinator.value || ' ')) {\n                        return false;\n                    }\n                }\n                if (!this.isElementValuesEqual(elementValue1.elements[i].value, elementValue2.elements[i].value)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    },\n    extendSelector:function (matches, selectorPath, replacementSelector, isVisible) {\n\n        //for a set of matches, replace each match with the replacement selector\n\n        var currentSelectorPathIndex = 0,\n            currentSelectorPathElementIndex = 0,\n            path = [],\n            matchIndex,\n            selector,\n            firstElement,\n            match,\n            newElements;\n\n        for (matchIndex = 0; matchIndex < matches.length; matchIndex++) {\n            match = matches[matchIndex];\n            selector = selectorPath[match.pathIndex];\n            firstElement = new tree.Element(\n                match.initialCombinator,\n                replacementSelector.elements[0].value,\n                replacementSelector.elements[0].index,\n                replacementSelector.elements[0].currentFileInfo\n            );\n\n            if (match.pathIndex > currentSelectorPathIndex && currentSelectorPathElementIndex > 0) {\n                path[path.length - 1].elements = path[path.length - 1]\n                    .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));\n                currentSelectorPathElementIndex = 0;\n                currentSelectorPathIndex++;\n            }\n\n            newElements = selector.elements\n                .slice(currentSelectorPathElementIndex, match.index)\n                .concat([firstElement])\n                .concat(replacementSelector.elements.slice(1));\n\n            if (currentSelectorPathIndex === match.pathIndex && matchIndex > 0) {\n                path[path.length - 1].elements =\n                    path[path.length - 1].elements.concat(newElements);\n            } else {\n                path = path.concat(selectorPath.slice(currentSelectorPathIndex, match.pathIndex));\n\n                path.push(new tree.Selector(\n                    newElements\n                ));\n            }\n            currentSelectorPathIndex = match.endPathIndex;\n            currentSelectorPathElementIndex = match.endPathElementIndex;\n            if (currentSelectorPathElementIndex >= selectorPath[currentSelectorPathIndex].elements.length) {\n                currentSelectorPathElementIndex = 0;\n                currentSelectorPathIndex++;\n            }\n        }\n\n        if (currentSelectorPathIndex < selectorPath.length && currentSelectorPathElementIndex > 0) {\n            path[path.length - 1].elements = path[path.length - 1]\n                .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));\n            currentSelectorPathIndex++;\n        }\n\n        path = path.concat(selectorPath.slice(currentSelectorPathIndex, selectorPath.length));\n        path = path.map(function (currentValue) {\n            // we can re-use elements here, because the visibility property matters only for selectors\n            var derived = currentValue.createDerived(currentValue.elements);\n            if (isVisible) {\n                derived.ensureVisibility();\n            } else {\n                derived.ensureInvisibility();\n            }\n            return derived;\n        });\n        return path;\n    },\n    visitMedia: function (mediaNode, visitArgs) {\n        var newAllExtends = mediaNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);\n        newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, mediaNode.allExtends));\n        this.allExtendsStack.push(newAllExtends);\n    },\n    visitMediaOut: function (mediaNode) {\n        var lastIndex = this.allExtendsStack.length - 1;\n        this.allExtendsStack.length = lastIndex;\n    },\n    visitDirective: function (directiveNode, visitArgs) {\n        var newAllExtends = directiveNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);\n        newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, directiveNode.allExtends));\n        this.allExtendsStack.push(newAllExtends);\n    },\n    visitDirectiveOut: function (directiveNode) {\n        var lastIndex = this.allExtendsStack.length - 1;\n        this.allExtendsStack.length = lastIndex;\n    }\n};\n\nmodule.exports = ProcessExtendsVisitor;\n\n},{\"../logger\":33,\"../tree\":62,\"./visitor\":91}],85:[function(require,module,exports){\nfunction ImportSequencer(onSequencerEmpty) {\n    this.imports = [];\n    this.variableImports = [];\n    this._onSequencerEmpty = onSequencerEmpty;\n    this._currentDepth = 0;\n}\n\nImportSequencer.prototype.addImport = function(callback) {\n    var importSequencer = this,\n        importItem = {\n            callback: callback,\n            args: null,\n            isReady: false\n        };\n    this.imports.push(importItem);\n    return function() {\n        importItem.args = Array.prototype.slice.call(arguments, 0);\n        importItem.isReady = true;\n        importSequencer.tryRun();\n    };\n};\n\nImportSequencer.prototype.addVariableImport = function(callback) {\n    this.variableImports.push(callback);\n};\n\nImportSequencer.prototype.tryRun = function() {\n    this._currentDepth++;\n    try {\n        while (true) {\n            while (this.imports.length > 0) {\n                var importItem = this.imports[0];\n                if (!importItem.isReady) {\n                    return;\n                }\n                this.imports = this.imports.slice(1);\n                importItem.callback.apply(null, importItem.args);\n            }\n            if (this.variableImports.length === 0) {\n                break;\n            }\n            var variableImport = this.variableImports[0];\n            this.variableImports = this.variableImports.slice(1);\n            variableImport();\n        }\n    } finally {\n        this._currentDepth--;\n    }\n    if (this._currentDepth === 0 && this._onSequencerEmpty) {\n        this._onSequencerEmpty();\n    }\n};\n\nmodule.exports = ImportSequencer;\n\n},{}],86:[function(require,module,exports){\nvar contexts = require(\"../contexts\"),\n    Visitor = require(\"./visitor\"),\n    ImportSequencer = require(\"./import-sequencer\");\n\nvar ImportVisitor = function(importer, finish) {\n\n    this._visitor = new Visitor(this);\n    this._importer = importer;\n    this._finish = finish;\n    this.context = new contexts.Eval();\n    this.importCount = 0;\n    this.onceFileDetectionMap = {};\n    this.recursionDetector = {};\n    this._sequencer = new ImportSequencer(this._onSequencerEmpty.bind(this));\n};\n\nImportVisitor.prototype = {\n    isReplacing: false,\n    run: function (root) {\n        try {\n            // process the contents\n            this._visitor.visit(root);\n        }\n        catch(e) {\n            this.error = e;\n        }\n\n        this.isFinished = true;\n        this._sequencer.tryRun();\n    },\n    _onSequencerEmpty: function() {\n        if (!this.isFinished) {\n            return;\n        }\n        this._finish(this.error);\n    },\n    visitImport: function (importNode, visitArgs) {\n        var inlineCSS = importNode.options.inline;\n\n        if (!importNode.css || inlineCSS) {\n\n            var context = new contexts.Eval(this.context, this.context.frames.slice(0));\n            var importParent = context.frames[0];\n\n            this.importCount++;\n            if (importNode.isVariableImport()) {\n                this._sequencer.addVariableImport(this.processImportNode.bind(this, importNode, context, importParent));\n            } else {\n                this.processImportNode(importNode, context, importParent);\n            }\n        }\n        visitArgs.visitDeeper = false;\n    },\n    processImportNode: function(importNode, context, importParent) {\n        var evaldImportNode,\n            inlineCSS = importNode.options.inline;\n\n        try {\n            evaldImportNode = importNode.evalForImport(context);\n        } catch(e) {\n            if (!e.filename) { e.index = importNode.index; e.filename = importNode.currentFileInfo.filename; }\n            // attempt to eval properly and treat as css\n            importNode.css = true;\n            // if that fails, this error will be thrown\n            importNode.error = e;\n        }\n\n        if (evaldImportNode && (!evaldImportNode.css || inlineCSS)) {\n\n            if (evaldImportNode.options.multiple) {\n                context.importMultiple = true;\n            }\n\n            // try appending if we haven't determined if it is css or not\n            var tryAppendLessExtension = evaldImportNode.css === undefined;\n\n            for (var i = 0; i < importParent.rules.length; i++) {\n                if (importParent.rules[i] === importNode) {\n                    importParent.rules[i] = evaldImportNode;\n                    break;\n                }\n            }\n\n            var onImported = this.onImported.bind(this, evaldImportNode, context),\n                sequencedOnImported = this._sequencer.addImport(onImported);\n\n            this._importer.push(evaldImportNode.getPath(), tryAppendLessExtension, evaldImportNode.currentFileInfo,\n                evaldImportNode.options, sequencedOnImported);\n        } else {\n            this.importCount--;\n            if (this.isFinished) {\n                this._sequencer.tryRun();\n            }\n        }\n    },\n    onImported: function (importNode, context, e, root, importedAtRoot, fullPath) {\n        if (e) {\n            if (!e.filename) {\n                e.index = importNode.index; e.filename = importNode.currentFileInfo.filename;\n            }\n            this.error = e;\n        }\n\n        var importVisitor = this,\n            inlineCSS = importNode.options.inline,\n            isPlugin = importNode.options.plugin,\n            isOptional = importNode.options.optional,\n            duplicateImport = importedAtRoot || fullPath in importVisitor.recursionDetector;\n\n        if (!context.importMultiple) {\n            if (duplicateImport) {\n                importNode.skip = true;\n            } else {\n                importNode.skip = function() {\n                    if (fullPath in importVisitor.onceFileDetectionMap) {\n                        return true;\n                    }\n                    importVisitor.onceFileDetectionMap[fullPath] = true;\n                    return false;\n                };\n            }\n        }\n\n        if (!fullPath && isOptional) {\n            importNode.skip = true;\n        }\n\n        if (root) {\n            importNode.root = root;\n            importNode.importedFilename = fullPath;\n\n            if (!inlineCSS && !isPlugin && (context.importMultiple || !duplicateImport)) {\n                importVisitor.recursionDetector[fullPath] = true;\n\n                var oldContext = this.context;\n                this.context = context;\n                try {\n                    this._visitor.visit(root);\n                } catch (e) {\n                    this.error = e;\n                }\n                this.context = oldContext;\n            }\n        }\n\n        importVisitor.importCount--;\n\n        if (importVisitor.isFinished) {\n            importVisitor._sequencer.tryRun();\n        }\n    },\n    visitRule: function (ruleNode, visitArgs) {\n        if (ruleNode.value.type === \"DetachedRuleset\") {\n            this.context.frames.unshift(ruleNode);\n        } else {\n            visitArgs.visitDeeper = false;\n        }\n    },\n    visitRuleOut : function(ruleNode) {\n        if (ruleNode.value.type === \"DetachedRuleset\") {\n            this.context.frames.shift();\n        }\n    },\n    visitDirective: function (directiveNode, visitArgs) {\n        this.context.frames.unshift(directiveNode);\n    },\n    visitDirectiveOut: function (directiveNode) {\n        this.context.frames.shift();\n    },\n    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {\n        this.context.frames.unshift(mixinDefinitionNode);\n    },\n    visitMixinDefinitionOut: function (mixinDefinitionNode) {\n        this.context.frames.shift();\n    },\n    visitRuleset: function (rulesetNode, visitArgs) {\n        this.context.frames.unshift(rulesetNode);\n    },\n    visitRulesetOut: function (rulesetNode) {\n        this.context.frames.shift();\n    },\n    visitMedia: function (mediaNode, visitArgs) {\n        this.context.frames.unshift(mediaNode.rules[0]);\n    },\n    visitMediaOut: function (mediaNode) {\n        this.context.frames.shift();\n    }\n};\nmodule.exports = ImportVisitor;\n\n},{\"../contexts\":11,\"./import-sequencer\":85,\"./visitor\":91}],87:[function(require,module,exports){\nvar visitors = {\n    Visitor: require(\"./visitor\"),\n    ImportVisitor: require('./import-visitor'),\n    MarkVisibleSelectorsVisitor: require(\"./set-tree-visibility-visitor\"),\n    ExtendVisitor: require('./extend-visitor'),\n    JoinSelectorVisitor: require('./join-selector-visitor'),\n    ToCSSVisitor: require('./to-css-visitor')\n};\n\nmodule.exports = visitors;\n\n},{\"./extend-visitor\":84,\"./import-visitor\":86,\"./join-selector-visitor\":88,\"./set-tree-visibility-visitor\":89,\"./to-css-visitor\":90,\"./visitor\":91}],88:[function(require,module,exports){\nvar Visitor = require(\"./visitor\");\n\nvar JoinSelectorVisitor = function() {\n    this.contexts = [[]];\n    this._visitor = new Visitor(this);\n};\n\nJoinSelectorVisitor.prototype = {\n    run: function (root) {\n        return this._visitor.visit(root);\n    },\n    visitRule: function (ruleNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    },\n    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    },\n\n    visitRuleset: function (rulesetNode, visitArgs) {\n        var context = this.contexts[this.contexts.length - 1],\n            paths = [], selectors;\n\n        this.contexts.push(paths);\n\n        if (! rulesetNode.root) {\n            selectors = rulesetNode.selectors;\n            if (selectors) {\n                selectors = selectors.filter(function(selector) { return selector.getIsOutput(); });\n                rulesetNode.selectors = selectors.length ? selectors : (selectors = null);\n                if (selectors) { rulesetNode.joinSelectors(paths, context, selectors); }\n            }\n            if (!selectors) { rulesetNode.rules = null; }\n            rulesetNode.paths = paths;\n        }\n    },\n    visitRulesetOut: function (rulesetNode) {\n        this.contexts.length = this.contexts.length - 1;\n    },\n    visitMedia: function (mediaNode, visitArgs) {\n        var context = this.contexts[this.contexts.length - 1];\n        mediaNode.rules[0].root = (context.length === 0 || context[0].multiMedia);\n    },\n    visitDirective: function (directiveNode, visitArgs) {\n        var context = this.contexts[this.contexts.length - 1];\n        if (directiveNode.rules && directiveNode.rules.length) {\n            directiveNode.rules[0].root = (directiveNode.isRooted || context.length === 0 || null);\n        }\n    }\n};\n\nmodule.exports = JoinSelectorVisitor;\n\n},{\"./visitor\":91}],89:[function(require,module,exports){\nvar SetTreeVisibilityVisitor = function(visible) {\n    this.visible = visible;\n};\nSetTreeVisibilityVisitor.prototype.run = function(root) {\n    this.visit(root);\n};\nSetTreeVisibilityVisitor.prototype.visitArray = function(nodes) {\n    if (!nodes) {\n        return nodes;\n    }\n\n    var cnt = nodes.length, i;\n    for (i = 0; i < cnt; i++) {\n        this.visit(nodes[i]);\n    }\n    return nodes;\n};\nSetTreeVisibilityVisitor.prototype.visit = function(node) {\n    if (!node) {\n        return node;\n    }\n    if (node.constructor === Array) {\n        return this.visitArray(node);\n    }\n\n    if (!node.blocksVisibility || node.blocksVisibility()) {\n        return node;\n    }\n    if (this.visible) {\n        node.ensureVisibility();\n    } else {\n        node.ensureInvisibility();\n    }\n\n    node.accept(this);\n    return node;\n};\nmodule.exports = SetTreeVisibilityVisitor;\n},{}],90:[function(require,module,exports){\nvar tree = require(\"../tree\"),\n    Visitor = require(\"./visitor\");\n\nvar CSSVisitorUtils = function(context) {\n    this._visitor = new Visitor(this);\n    this._context = context;\n};\n\nCSSVisitorUtils.prototype = {\n    containsSilentNonBlockedChild: function(bodyRules) {\n        var rule;\n        if (bodyRules == null) {\n            return false;\n        }\n        for (var r = 0; r < bodyRules.length; r++) {\n            rule = bodyRules[r];\n            if (rule.isSilent && rule.isSilent(this._context) && !rule.blocksVisibility()) {\n                //the directive contains something that was referenced (likely by extend)\n                //therefore it needs to be shown in output too\n                return true;\n            }\n        }\n        return false;\n    },\n\n    keepOnlyVisibleChilds: function(owner) {\n        if (owner == null || owner.rules == null) {\n            return ;\n        }\n\n        owner.rules = owner.rules.filter(function(thing) {\n                return thing.isVisible();\n            }\n        );\n    },\n\n    isEmpty: function(owner) {\n        if (owner == null || owner.rules == null) {\n            return true;\n        }\n        return owner.rules.length === 0;\n    },\n\n    hasVisibleSelector: function(rulesetNode) {\n        if (rulesetNode == null || rulesetNode.paths == null) {\n            return false;\n        }\n        return rulesetNode.paths.length > 0;\n    },\n\n    resolveVisibility: function (node, originalRules) {\n        if (!node.blocksVisibility()) {\n            if (this.isEmpty(node) && !this.containsSilentNonBlockedChild(originalRules)) {\n                return ;\n            }\n\n            return node;\n        }\n\n        var compiledRulesBody = node.rules[0];\n        this.keepOnlyVisibleChilds(compiledRulesBody);\n\n        if (this.isEmpty(compiledRulesBody)) {\n            return ;\n        }\n\n        node.ensureVisibility();\n        node.removeVisibilityBlock();\n\n        return node;\n    },\n\n    isVisibleRuleset: function(rulesetNode) {\n        if (rulesetNode.firstRoot) {\n            return true;\n        }\n\n        if (this.isEmpty(rulesetNode)) {\n            return false;\n        }\n\n        if (!rulesetNode.root && !this.hasVisibleSelector(rulesetNode)) {\n            return false;\n        }\n\n        return true;\n    }\n\n};\n\nvar ToCSSVisitor = function(context) {\n    this._visitor = new Visitor(this);\n    this._context = context;\n    this.utils = new CSSVisitorUtils(context);\n};\n\nToCSSVisitor.prototype = {\n    isReplacing: true,\n    run: function (root) {\n        return this._visitor.visit(root);\n    },\n\n    visitRule: function (ruleNode, visitArgs) {\n        if (ruleNode.blocksVisibility() || ruleNode.variable) {\n            return;\n        }\n        return ruleNode;\n    },\n\n    visitMixinDefinition: function (mixinNode, visitArgs) {\n        // mixin definitions do not get eval'd - this means they keep state\n        // so we have to clear that state here so it isn't used if toCSS is called twice\n        mixinNode.frames = [];\n    },\n\n    visitExtend: function (extendNode, visitArgs) {\n    },\n\n    visitComment: function (commentNode, visitArgs) {\n        if (commentNode.blocksVisibility() || commentNode.isSilent(this._context)) {\n            return;\n        }\n        return commentNode;\n    },\n\n    visitMedia: function(mediaNode, visitArgs) {\n        var originalRules = mediaNode.rules[0].rules;\n        mediaNode.accept(this._visitor);\n        visitArgs.visitDeeper = false;\n\n        return this.utils.resolveVisibility(mediaNode, originalRules);\n    },\n\n    visitImport: function (importNode, visitArgs) {\n        if (importNode.blocksVisibility()) {\n            return ;\n        }\n        return importNode;\n    },\n\n    visitDirective: function(directiveNode, visitArgs) {\n        if (directiveNode.rules && directiveNode.rules.length) {\n            return this.visitDirectiveWithBody(directiveNode, visitArgs);\n        } else {\n            return this.visitDirectiveWithoutBody(directiveNode, visitArgs);\n        }\n    },\n\n    visitDirectiveWithBody: function(directiveNode, visitArgs) {\n        //if there is only one nested ruleset and that one has no path, then it is\n        //just fake ruleset\n        function hasFakeRuleset(directiveNode) {\n            var bodyRules = directiveNode.rules;\n            return bodyRules.length === 1 && (!bodyRules[0].paths || bodyRules[0].paths.length === 0);\n        }\n        function getBodyRules(directiveNode) {\n            var nodeRules = directiveNode.rules;\n            if (hasFakeRuleset(directiveNode)) {\n                return nodeRules[0].rules;\n            }\n\n            return nodeRules;\n        }\n        //it is still true that it is only one ruleset in array\n        //this is last such moment\n        //process childs\n        var originalRules = getBodyRules(directiveNode);\n        directiveNode.accept(this._visitor);\n        visitArgs.visitDeeper = false;\n\n        if (!this.utils.isEmpty(directiveNode)) {\n            this._mergeRules(directiveNode.rules[0].rules);\n        }\n\n        return this.utils.resolveVisibility(directiveNode, originalRules);\n    },\n\n    visitDirectiveWithoutBody: function(directiveNode, visitArgs) {\n        if (directiveNode.blocksVisibility()) {\n            return;\n        }\n\n        if (directiveNode.name === \"@charset\") {\n            // Only output the debug info together with subsequent @charset definitions\n            // a comment (or @media statement) before the actual @charset directive would\n            // be considered illegal css as it has to be on the first line\n            if (this.charset) {\n                if (directiveNode.debugInfo) {\n                    var comment = new tree.Comment(\"/* \" + directiveNode.toCSS(this._context).replace(/\\n/g, \"\") + \" */\\n\");\n                    comment.debugInfo = directiveNode.debugInfo;\n                    return this._visitor.visit(comment);\n                }\n                return;\n            }\n            this.charset = true;\n        }\n\n        return directiveNode;\n    },\n\n    checkValidNodes: function(rules, isRoot) {\n        if (!rules) {\n            return;\n        }\n\n        for (var i = 0; i < rules.length; i++) {\n            var ruleNode = rules[i];\n            if (isRoot && ruleNode instanceof tree.Rule && !ruleNode.variable) {\n                throw { message: \"Properties must be inside selector blocks. They cannot be in the root\",\n                    index: ruleNode.index, filename: ruleNode.currentFileInfo && ruleNode.currentFileInfo.filename};\n            }\n            if (ruleNode instanceof tree.Call) {\n                throw { message: \"Function '\" + ruleNode.name + \"' is undefined\",\n                    index: ruleNode.index, filename: ruleNode.currentFileInfo && ruleNode.currentFileInfo.filename};\n            }\n            if (ruleNode.type && !ruleNode.allowRoot) {\n                throw { message: ruleNode.type + \" node returned by a function is not valid here\",\n                    index: ruleNode.index, filename: ruleNode.currentFileInfo && ruleNode.currentFileInfo.filename};\n            }\n        }\n    },\n\n    visitRuleset: function (rulesetNode, visitArgs) {\n        //at this point rulesets are nested into each other\n        var rule, rulesets = [];\n\n        this.checkValidNodes(rulesetNode.rules, rulesetNode.firstRoot);\n\n        if (! rulesetNode.root) {\n            //remove invisible paths\n            this._compileRulesetPaths(rulesetNode);\n\n            // remove rulesets from this ruleset body and compile them separately\n            var nodeRules = rulesetNode.rules, nodeRuleCnt = nodeRules ? nodeRules.length : 0;\n            for (var i = 0; i < nodeRuleCnt; ) {\n                rule = nodeRules[i];\n                if (rule && rule.rules) {\n                    // visit because we are moving them out from being a child\n                    rulesets.push(this._visitor.visit(rule));\n                    nodeRules.splice(i, 1);\n                    nodeRuleCnt--;\n                    continue;\n                }\n                i++;\n            }\n            // accept the visitor to remove rules and refactor itself\n            // then we can decide nogw whether we want it or not\n            // compile body\n            if (nodeRuleCnt > 0) {\n                rulesetNode.accept(this._visitor);\n            } else {\n                rulesetNode.rules = null;\n            }\n            visitArgs.visitDeeper = false;\n\n        } else { //if (! rulesetNode.root) {\n            rulesetNode.accept(this._visitor);\n            visitArgs.visitDeeper = false;\n        }\n\n        if (rulesetNode.rules) {\n            this._mergeRules(rulesetNode.rules);\n            this._removeDuplicateRules(rulesetNode.rules);\n        }\n\n        //now decide whether we keep the ruleset\n        if (this.utils.isVisibleRuleset(rulesetNode)) {\n            rulesetNode.ensureVisibility();\n            rulesets.splice(0, 0, rulesetNode);\n        }\n\n        if (rulesets.length === 1) {\n            return rulesets[0];\n        }\n        return rulesets;\n    },\n\n    _compileRulesetPaths: function(rulesetNode) {\n        if (rulesetNode.paths) {\n            rulesetNode.paths = rulesetNode.paths\n                .filter(function(p) {\n                    var i;\n                    if (p[0].elements[0].combinator.value === ' ') {\n                        p[0].elements[0].combinator = new(tree.Combinator)('');\n                    }\n                    for (i = 0; i < p.length; i++) {\n                        if (p[i].isVisible() && p[i].getIsOutput()) {\n                            return true;\n                        }\n                    }\n                    return false;\n                });\n        }\n    },\n\n    _removeDuplicateRules: function(rules) {\n        if (!rules) { return; }\n\n        // remove duplicates\n        var ruleCache = {},\n            ruleList, rule, i;\n\n        for (i = rules.length - 1; i >= 0 ; i--) {\n            rule = rules[i];\n            if (rule instanceof tree.Rule) {\n                if (!ruleCache[rule.name]) {\n                    ruleCache[rule.name] = rule;\n                } else {\n                    ruleList = ruleCache[rule.name];\n                    if (ruleList instanceof tree.Rule) {\n                        ruleList = ruleCache[rule.name] = [ruleCache[rule.name].toCSS(this._context)];\n                    }\n                    var ruleCSS = rule.toCSS(this._context);\n                    if (ruleList.indexOf(ruleCSS) !== -1) {\n                        rules.splice(i, 1);\n                    } else {\n                        ruleList.push(ruleCSS);\n                    }\n                }\n            }\n        }\n    },\n\n    _mergeRules: function (rules) {\n        if (!rules) { return; }\n\n        var groups = {},\n            parts,\n            rule,\n            key;\n\n        for (var i = 0; i < rules.length; i++) {\n            rule = rules[i];\n\n            if ((rule instanceof tree.Rule) && rule.merge) {\n                key = [rule.name,\n                    rule.important ? \"!\" : \"\"].join(\",\");\n\n                if (!groups[key]) {\n                    groups[key] = [];\n                } else {\n                    rules.splice(i--, 1);\n                }\n\n                groups[key].push(rule);\n            }\n        }\n\n        Object.keys(groups).map(function (k) {\n\n            function toExpression(values) {\n                return new (tree.Expression)(values.map(function (p) {\n                    return p.value;\n                }));\n            }\n\n            function toValue(values) {\n                return new (tree.Value)(values.map(function (p) {\n                    return p;\n                }));\n            }\n\n            parts = groups[k];\n\n            if (parts.length > 1) {\n                rule = parts[0];\n                var spacedGroups = [];\n                var lastSpacedGroup = [];\n                parts.map(function (p) {\n                    if (p.merge === \"+\") {\n                        if (lastSpacedGroup.length > 0) {\n                            spacedGroups.push(toExpression(lastSpacedGroup));\n                        }\n                        lastSpacedGroup = [];\n                    }\n                    lastSpacedGroup.push(p);\n                });\n                spacedGroups.push(toExpression(lastSpacedGroup));\n                rule.value = toValue(spacedGroups);\n            }\n        });\n    },\n\n    visitAnonymous: function(anonymousNode, visitArgs) {\n        if (anonymousNode.blocksVisibility()) {\n            return ;\n        }\n        anonymousNode.accept(this._visitor);\n        return anonymousNode;\n    }\n};\n\nmodule.exports = ToCSSVisitor;\n\n},{\"../tree\":62,\"./visitor\":91}],91:[function(require,module,exports){\nvar tree = require(\"../tree\");\n\nvar _visitArgs = { visitDeeper: true },\n    _hasIndexed = false;\n\nfunction _noop(node) {\n    return node;\n}\n\nfunction indexNodeTypes(parent, ticker) {\n    // add .typeIndex to tree node types for lookup table\n    var key, child;\n    for (key in parent) {\n        if (parent.hasOwnProperty(key)) {\n            child = parent[key];\n            switch (typeof child) {\n                case \"function\":\n                    // ignore bound functions directly on tree which do not have a prototype\n                    // or aren't nodes\n                    if (child.prototype && child.prototype.type) {\n                        child.prototype.typeIndex = ticker++;\n                    }\n                    break;\n                case \"object\":\n                    ticker = indexNodeTypes(child, ticker);\n                    break;\n            }\n        }\n    }\n    return ticker;\n}\n\nvar Visitor = function(implementation) {\n    this._implementation = implementation;\n    this._visitFnCache = [];\n\n    if (!_hasIndexed) {\n        indexNodeTypes(tree, 1);\n        _hasIndexed = true;\n    }\n};\n\nVisitor.prototype = {\n    visit: function(node) {\n        if (!node) {\n            return node;\n        }\n\n        var nodeTypeIndex = node.typeIndex;\n        if (!nodeTypeIndex) {\n            return node;\n        }\n\n        var visitFnCache = this._visitFnCache,\n            impl = this._implementation,\n            aryIndx = nodeTypeIndex << 1,\n            outAryIndex = aryIndx | 1,\n            func = visitFnCache[aryIndx],\n            funcOut = visitFnCache[outAryIndex],\n            visitArgs = _visitArgs,\n            fnName;\n\n        visitArgs.visitDeeper = true;\n\n        if (!func) {\n            fnName = \"visit\" + node.type;\n            func = impl[fnName] || _noop;\n            funcOut = impl[fnName + \"Out\"] || _noop;\n            visitFnCache[aryIndx] = func;\n            visitFnCache[outAryIndex] = funcOut;\n        }\n\n        if (func !== _noop) {\n            var newNode = func.call(impl, node, visitArgs);\n            if (impl.isReplacing) {\n                node = newNode;\n            }\n        }\n\n        if (visitArgs.visitDeeper && node && node.accept) {\n            node.accept(this);\n        }\n\n        if (funcOut != _noop) {\n            funcOut.call(impl, node);\n        }\n\n        return node;\n    },\n    visitArray: function(nodes, nonReplacing) {\n        if (!nodes) {\n            return nodes;\n        }\n\n        var cnt = nodes.length, i;\n\n        // Non-replacing\n        if (nonReplacing || !this._implementation.isReplacing) {\n            for (i = 0; i < cnt; i++) {\n                this.visit(nodes[i]);\n            }\n            return nodes;\n        }\n\n        // Replacing\n        var out = [];\n        for (i = 0; i < cnt; i++) {\n            var evald = this.visit(nodes[i]);\n            if (evald === undefined) { continue; }\n            if (!evald.splice) {\n                out.push(evald);\n            } else if (evald.length) {\n                this.flatten(evald, out);\n            }\n        }\n        return out;\n    },\n    flatten: function(arr, out) {\n        if (!out) {\n            out = [];\n        }\n\n        var cnt, i, item,\n            nestedCnt, j, nestedItem;\n\n        for (i = 0, cnt = arr.length; i < cnt; i++) {\n            item = arr[i];\n            if (item === undefined) {\n                continue;\n            }\n            if (!item.splice) {\n                out.push(item);\n                continue;\n            }\n\n            for (j = 0, nestedCnt = item.length; j < nestedCnt; j++) {\n                nestedItem = item[j];\n                if (nestedItem === undefined) {\n                    continue;\n                }\n                if (!nestedItem.splice) {\n                    out.push(nestedItem);\n                } else if (nestedItem.length) {\n                    this.flatten(nestedItem, out);\n                }\n            }\n        }\n\n        return out;\n    }\n};\nmodule.exports = Visitor;\n\n},{\"../tree\":62}],92:[function(require,module,exports){\n\"use strict\";\n\n// rawAsap provides everything we need except exception management.\nvar rawAsap = require(\"./raw\");\n// RawTasks are recycled to reduce GC churn.\nvar freeTasks = [];\n// We queue errors to ensure they are thrown in right order (FIFO).\n// Array-as-queue is good enough here, since we are just dealing with exceptions.\nvar pendingErrors = [];\nvar requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);\n\nfunction throwFirstError() {\n    if (pendingErrors.length) {\n        throw pendingErrors.shift();\n    }\n}\n\n/**\n * Calls a task as soon as possible after returning, in its own event, with priority\n * over other events like animation, reflow, and repaint. An error thrown from an\n * event will not interrupt, nor even substantially slow down the processing of\n * other events, but will be rather postponed to a lower priority event.\n * @param {{call}} task A callable object, typically a function that takes no\n * arguments.\n */\nmodule.exports = asap;\nfunction asap(task) {\n    var rawTask;\n    if (freeTasks.length) {\n        rawTask = freeTasks.pop();\n    } else {\n        rawTask = new RawTask();\n    }\n    rawTask.task = task;\n    rawAsap(rawTask);\n}\n\n// We wrap tasks with recyclable task objects.  A task object implements\n// `call`, just like a function.\nfunction RawTask() {\n    this.task = null;\n}\n\n// The sole purpose of wrapping the task is to catch the exception and recycle\n// the task object after its single use.\nRawTask.prototype.call = function () {\n    try {\n        this.task.call();\n    } catch (error) {\n        if (asap.onerror) {\n            // This hook exists purely for testing purposes.\n            // Its name will be periodically randomized to break any code that\n            // depends on its existence.\n            asap.onerror(error);\n        } else {\n            // In a web browser, exceptions are not fatal. However, to avoid\n            // slowing down the queue of pending tasks, we rethrow the error in a\n            // lower priority turn.\n            pendingErrors.push(error);\n            requestErrorThrow();\n        }\n    } finally {\n        this.task = null;\n        freeTasks[freeTasks.length] = this;\n    }\n};\n\n},{\"./raw\":93}],93:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\nvar BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.js’s\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],94:[function(require,module,exports){\n'use strict';\n\nvar asap = require('asap/raw');\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n},{\"asap/raw\":93}],95:[function(require,module,exports){\n'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n},{\"./core.js\":94}],96:[function(require,module,exports){\n// should work in any browser without browserify\n\nif (typeof Promise.prototype.done !== 'function') {\n  Promise.prototype.done = function (onFulfilled, onRejected) {\n    var self = arguments.length ? this.then.apply(this, arguments) : this\n    self.then(null, function (err) {\n      setTimeout(function () {\n        throw err\n      }, 0)\n    })\n  }\n}\n},{}],97:[function(require,module,exports){\n// not \"use strict\" so we can declare global \"Promise\"\n\nvar asap = require('asap');\n\nif (typeof Promise === 'undefined') {\n  Promise = require('./lib/core.js')\n  require('./lib/es6-extensions.js')\n}\n\nrequire('./polyfill-done.js');\n\n},{\"./lib/core.js\":94,\"./lib/es6-extensions.js\":95,\"./polyfill-done.js\":96,\"asap\":92}]},{},[2])(2)\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLl9sZXNzQDIuNy4yQGxlc3MvZGlzdC9sZXNzLmpzPzkxYmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjBEQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLFNBQTJELG1CQUFtQixnREFBZ0QsYUFBYSxLQUFLLE1BQU0sZ0NBQWdDLFNBQVMscUNBQXFDLFNBQVMsbUNBQW1DLE9BQU8sS0FBSyxPQUFPLGNBQWMsYUFBYSwwQkFBMEIsMEJBQTBCLGdCQUFnQixVQUFVLFVBQVUsMENBQTBDLDhCQUF3QixvQkFBb0IsOENBQThDLGtDQUFrQyxZQUFZLFlBQVksbUNBQW1DLGlCQUFpQixnQkFBZ0Isc0JBQXNCLG9CQUFvQiwwQ0FBMEMsWUFBWSxXQUFXLFlBQVksU0FBUyxHQUFHO0FBQ3h5QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSwyQkFBMkI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLCtEQUErRDtBQUNsRTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLHNDQUFzQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLHNFQUFzRSxPQUFPO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUNBQW1DO0FBQ2xEO0FBQ0E7QUFDQSxlQUFlLCtCQUErQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxFQUFFO0FBQzdDO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLGVBQWU7QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSw0Q0FBNEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQThDLHVCQUF1QixFQUFFO0FBQ3ZFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsc0JBQXNCOztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCLEVBQUUsVUFBVSxFQUFFO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsOEdBQThHO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWUsUUFBUTtBQUNuRDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBLENBQUMsRUFBRSw2RUFBNkU7QUFDaEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsRUFBRSw4Q0FBOEM7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUMsRUFBRSxlQUFlO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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LHVCQUF1QixPQUFPO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7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LDRDQUE0QztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRDQUE0QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsWUFBWTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsWUFBWTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsWUFBWTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsWUFBWTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3QkFBd0IsRUFBRTtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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LEdBQUc7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsNkJBQTZCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0Q0FBNEM7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLG1FQUFtRTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDLEtBQUs7QUFDTCxzQkFBc0I7QUFDdEI7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSwyQ0FBMkM7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsMkNBQTJDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLENBQUMsRUFBRSx3Q0FBd0M7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLDRCQUE0QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSxrRkFBa0Y7QUFDckY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsNkZBQTZGO0FBQ2hHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsOENBQThDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLDJDQUEyQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFD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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELGVBQWU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSxhQUFhO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSxXQUFXO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7QUFDdEksQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQsY0FBYztBQUNuRTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSxjQUFjO0FBQ2pCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSxlQUFlO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxrRkFBa0YsRUFBRSxHQUFHO0FBQzFGLENBQUMsRSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBMZXNzIC0gTGVhbmVyIENTUyB2Mi43LjJcbiAqIGh0dHA6Ly9sZXNzY3NzLm9yZ1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDE3LCBBbGV4aXMgU2VsbGllciA8c2VsZkBjbG91ZGhlYWQubmV0PlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgTGljZW5zZS5cbiAqXG4gKi9cblxuIC8qKiAqIEBsaWNlbnNlIEFwYWNoZS0yLjBcbiAqL1xuXG4oZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5sZXNzID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGFkZERhdGFBdHRyID0gcmVxdWlyZShcIi4vdXRpbHNcIikuYWRkRGF0YUF0dHIsXG4gICAgYnJvd3NlciA9IHJlcXVpcmUoXCIuL2Jyb3dzZXJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24od2luZG93LCBvcHRpb25zKSB7XG5cbiAgICAvLyB1c2Ugb3B0aW9ucyBmcm9tIHRoZSBjdXJyZW50IHNjcmlwdCB0YWcgZGF0YSBhdHRyaWJ1ZXNcbiAgICBhZGREYXRhQXR0cihvcHRpb25zLCBicm93c2VyLmN1cnJlbnRTY3JpcHQod2luZG93KSk7XG5cbiAgICBpZiAob3B0aW9ucy5pc0ZpbGVQcm90b2NvbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuaXNGaWxlUHJvdG9jb2wgPSAvXihmaWxlfChjaHJvbWV8c2FmYXJpKSgtZXh0ZW5zaW9uKT98cmVzb3VyY2V8cXJjfGFwcCk6Ly50ZXN0KHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCk7XG4gICAgfVxuXG4gICAgLy8gTG9hZCBzdHlsZXMgYXN5bmNocm9ub3VzbHkgKGRlZmF1bHQ6IGZhbHNlKVxuICAgIC8vXG4gICAgLy8gVGhpcyBpcyBzZXQgdG8gYGZhbHNlYCBieSBkZWZhdWx0LCBzbyB0aGF0IHRoZSBib2R5XG4gICAgLy8gZG9lc24ndCBzdGFydCBsb2FkaW5nIGJlZm9yZSB0aGUgc3R5bGVzaGVldHMgYXJlIHBhcnNlZC5cbiAgICAvLyBTZXR0aW5nIHRoaXMgdG8gYHRydWVgIGNhbiByZXN1bHQgaW4gZmxpY2tlcmluZy5cbiAgICAvL1xuICAgIG9wdGlvbnMuYXN5bmMgPSBvcHRpb25zLmFzeW5jIHx8IGZhbHNlO1xuICAgIG9wdGlvbnMuZmlsZUFzeW5jID0gb3B0aW9ucy5maWxlQXN5bmMgfHwgZmFsc2U7XG5cbiAgICAvLyBJbnRlcnZhbCBiZXR3ZWVuIHdhdGNoIHBvbGxzXG4gICAgb3B0aW9ucy5wb2xsID0gb3B0aW9ucy5wb2xsIHx8IChvcHRpb25zLmlzRmlsZVByb3RvY29sID8gMTAwMCA6IDE1MDApO1xuXG4gICAgb3B0aW9ucy5lbnYgPSBvcHRpb25zLmVudiB8fCAod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lID09ICcxMjcuMC4wLjEnIHx8XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PSAnMC4wLjAuMCcgICB8fFxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT0gJ2xvY2FsaG9zdCcgfHxcbiAgICAgICAgKHdpbmRvdy5sb2NhdGlvbi5wb3J0ICYmXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucG9ydC5sZW5ndGggPiAwKSAgICAgIHx8XG4gICAgICAgIG9wdGlvbnMuaXNGaWxlUHJvdG9jb2wgICAgICAgICAgICAgICAgICAgPyAnZGV2ZWxvcG1lbnQnXG4gICAgICAgIDogJ3Byb2R1Y3Rpb24nKTtcblxuICAgIHZhciBkdW1wTGluZU51bWJlcnMgPSAvIWR1bXBMaW5lTnVtYmVyczooY29tbWVudHN8bWVkaWFxdWVyeXxhbGwpLy5leGVjKHdpbmRvdy5sb2NhdGlvbi5oYXNoKTtcbiAgICBpZiAoZHVtcExpbmVOdW1iZXJzKSB7XG4gICAgICAgIG9wdGlvbnMuZHVtcExpbmVOdW1iZXJzID0gZHVtcExpbmVOdW1iZXJzWzFdO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVzZUZpbGVDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMudXNlRmlsZUNhY2hlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5vblJlYWR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5vblJlYWR5ID0gdHJ1ZTtcbiAgICB9XG5cbn07XG5cbn0se1wiLi9icm93c2VyXCI6MyxcIi4vdXRpbHNcIjoxMH1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBLaWNrcyBvZmYgbGVzcyBhbmQgY29tcGlsZXMgYW55IHN0eWxlc2hlZXRzXG4gKiB1c2VkIGluIHRoZSBicm93c2VyIGRpc3RyaWJ1dGVkIHZlcnNpb24gb2YgbGVzc1xuICogdG8ga2ljay1zdGFydCBsZXNzIHVzaW5nIHRoZSBicm93c2VyIGFwaVxuICovXG4vKmdsb2JhbCB3aW5kb3csIGRvY3VtZW50ICovXG5cbi8vIHNoaW0gUHJvbWlzZSBpZiByZXF1aXJlZFxucmVxdWlyZSgncHJvbWlzZS9wb2x5ZmlsbC5qcycpO1xuXG52YXIgb3B0aW9ucyA9IHdpbmRvdy5sZXNzIHx8IHt9O1xucmVxdWlyZShcIi4vYWRkLWRlZmF1bHQtb3B0aW9uc1wiKSh3aW5kb3csIG9wdGlvbnMpO1xuXG52YXIgbGVzcyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaW5kZXhcIikod2luZG93LCBvcHRpb25zKTtcblxud2luZG93Lmxlc3MgPSBsZXNzO1xuXG52YXIgY3NzLCBoZWFkLCBzdHlsZTtcblxuLy8gQWx3YXlzIHJlc3RvcmUgcGFnZSB2aXNpYmlsaXR5XG5mdW5jdGlvbiByZXNvbHZlT3JSZWplY3QoZGF0YSkge1xuICAgIGlmIChkYXRhLmZpbGVuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihkYXRhKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmFzeW5jKSB7XG4gICAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuICAgIH1cbn1cblxuaWYgKG9wdGlvbnMub25SZWFkeSkge1xuICAgIGlmICgvIXdhdGNoLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5oYXNoKSkge1xuICAgICAgICBsZXNzLndhdGNoKCk7XG4gICAgfVxuICAgIC8vIFNpbXVsYXRlIHN5bmNocm9ub3VzIHN0eWxlc2hlZXQgbG9hZGluZyBieSBibG9ja2luZyBwYWdlIHJlbmRlcmluZ1xuICAgIGlmICghb3B0aW9ucy5hc3luYykge1xuICAgICAgICBjc3MgPSAnYm9keSB7IGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudCB9JztcbiAgICAgICAgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXG4gICAgICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gICAgbGVzcy5yZWdpc3RlclN0eWxlc2hlZXRzSW1tZWRpYXRlbHkoKTtcbiAgICBsZXNzLnBhZ2VMb2FkRmluaXNoZWQgPSBsZXNzLnJlZnJlc2gobGVzcy5lbnYgPT09ICdkZXZlbG9wbWVudCcpLnRoZW4ocmVzb2x2ZU9yUmVqZWN0LCByZXNvbHZlT3JSZWplY3QpO1xufVxuXG59LHtcIi4vYWRkLWRlZmF1bHQtb3B0aW9uc1wiOjEsXCIuL2luZGV4XCI6OCxcInByb21pc2UvcG9seWZpbGwuanNcIjo5N31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjcmVhdGVDU1M6IGZ1bmN0aW9uIChkb2N1bWVudCwgc3R5bGVzLCBzaGVldCkge1xuICAgICAgICAvLyBTdHJpcCB0aGUgcXVlcnktc3RyaW5nXG4gICAgICAgIHZhciBocmVmID0gc2hlZXQuaHJlZiB8fCAnJztcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyB0aXRsZSBzZXQsIHVzZSB0aGUgZmlsZW5hbWUsIG1pbnVzIHRoZSBleHRlbnNpb25cbiAgICAgICAgdmFyIGlkID0gJ2xlc3M6JyArIChzaGVldC50aXRsZSB8fCB1dGlscy5leHRyYWN0SWQoaHJlZikpO1xuXG4gICAgICAgIC8vIElmIHRoaXMgaGFzIGFscmVhZHkgYmVlbiBpbnNlcnRlZCBpbnRvIHRoZSBET00sIHdlIG1heSBuZWVkIHRvIHJlcGxhY2UgaXRcbiAgICAgICAgdmFyIG9sZFN0eWxlTm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgdmFyIGtlZXBPbGRTdHlsZU5vZGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgc3R5bGVzaGVldCBub2RlIGZvciBpbnNlcnRpb24gb3IgKGlmIG5lY2Vzc2FyeSkgcmVwbGFjZW1lbnRcbiAgICAgICAgdmFyIHN0eWxlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAgICAgaWYgKHNoZWV0Lm1lZGlhKSB7XG4gICAgICAgICAgICBzdHlsZU5vZGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIHNoZWV0Lm1lZGlhKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZU5vZGUuaWQgPSBpZDtcblxuICAgICAgICBpZiAoIXN0eWxlTm9kZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICBzdHlsZU5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3R5bGVzKSk7XG5cbiAgICAgICAgICAgIC8vIElmIG5ldyBjb250ZW50cyBtYXRjaCBjb250ZW50cyBvZiBvbGRTdHlsZU5vZGUsIGRvbid0IHJlcGxhY2Ugb2xkU3R5bGVOb2RlXG4gICAgICAgICAgICBrZWVwT2xkU3R5bGVOb2RlID0gKG9sZFN0eWxlTm9kZSAhPT0gbnVsbCAmJiBvbGRTdHlsZU5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwICYmIHN0eWxlTm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBvbGRTdHlsZU5vZGUuZmlyc3RDaGlsZC5ub2RlVmFsdWUgPT09IHN0eWxlTm9kZS5maXJzdENoaWxkLm5vZGVWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gb2xkU3R5bGVOb2RlLCBqdXN0IGFwcGVuZDsgb3RoZXJ3aXNlLCBvbmx5IGFwcGVuZCBpZiB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIHJlcGxhY2Ugb2xkU3R5bGVOb2RlIHdpdGggYW4gdXBkYXRlZCBzdHlsZXNoZWV0XG4gICAgICAgIGlmIChvbGRTdHlsZU5vZGUgPT09IG51bGwgfHwga2VlcE9sZFN0eWxlTm9kZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBuZXh0RWwgPSBzaGVldCAmJiBzaGVldC5uZXh0U2libGluZyB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKG5leHRFbCkge1xuICAgICAgICAgICAgICAgIG5leHRFbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzdHlsZU5vZGUsIG5leHRFbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkU3R5bGVOb2RlICYmIGtlZXBPbGRTdHlsZU5vZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvbGRTdHlsZU5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvbGRTdHlsZU5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIElFLlxuICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGhhcHBlbiAqYWZ0ZXIqIHRoZSBzdHlsZSBlbGVtZW50IGlzIGFkZGVkIHRvIHRoZSBET00sIG90aGVyd2lzZSBJRSA3IGFuZCA4IG1heSBjcmFzaC5cbiAgICAgICAgLy8gU2VlIGh0dHA6Ly9zb2NpYWwubXNkbi5taWNyb3NvZnQuY29tL0ZvcnVtcy9lbi1VUy83ZTA4MWI2NS04NzhhLTRjMjItOGU2OC1jMTBkMzljMmVkMzIvaW50ZXJuZXQtZXhwbG9yZXItY3Jhc2hlcy1hcHBlbmRpbmctc3R5bGUtZWxlbWVudC10by1oZWFkXG4gICAgICAgIGlmIChzdHlsZU5vZGUuc3R5bGVTaGVldCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdHlsZU5vZGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gc3R5bGVzO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IHJlYXNzaWduIHN0eWxlU2hlZXQuY3NzVGV4dC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGN1cnJlbnRTY3JpcHQ6IGZ1bmN0aW9uKHdpbmRvdykge1xuICAgICAgICB2YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0IHx8IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9KSgpO1xuICAgIH1cbn07XG5cbn0se1wiLi91dGlsc1wiOjEwfV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDYWNoZSBzeXN0ZW0gaXMgYSBiaXQgb3V0ZGF0ZWQgYW5kIGNvdWxkIGRvIHdpdGggd29ya1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHdpbmRvdywgb3B0aW9ucywgbG9nZ2VyKSB7XG4gICAgdmFyIGNhY2hlID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy5lbnYgIT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhY2hlID0gKHR5cGVvZiB3aW5kb3cubG9jYWxTdG9yYWdlID09PSAndW5kZWZpbmVkJykgPyBudWxsIDogd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2V0Q1NTOiBmdW5jdGlvbihwYXRoLCBsYXN0TW9kaWZpZWQsIG1vZGlmeVZhcnMsIHN0eWxlcykge1xuICAgICAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oJ3NhdmluZyAnICsgcGF0aCArICcgdG8gY2FjaGUuJyk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0SXRlbShwYXRoLCBzdHlsZXMpO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXRJdGVtKHBhdGggKyAnOnRpbWVzdGFtcCcsIGxhc3RNb2RpZmllZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZnlWYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXRJdGVtKHBhdGggKyAnOnZhcnMnLCBKU09OLnN0cmluZ2lmeShtb2RpZnlWYXJzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIC0gY291bGQgZG8gd2l0aCBhZGRpbmcgbW9yZSByb2J1c3QgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdmYWlsZWQgdG8gc2F2ZSBcIicgKyBwYXRoICsgJ1wiIHRvIGxvY2FsIHN0b3JhZ2UgZm9yIGNhY2hpbmcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRDU1M6IGZ1bmN0aW9uKHBhdGgsIHdlYkluZm8sIG1vZGlmeVZhcnMpIHtcbiAgICAgICAgICAgIHZhciBjc3MgICAgICAgPSBjYWNoZSAmJiBjYWNoZS5nZXRJdGVtKHBhdGgpLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IGNhY2hlICYmIGNhY2hlLmdldEl0ZW0ocGF0aCArICc6dGltZXN0YW1wJyksXG4gICAgICAgICAgICAgICAgdmFycyAgICAgID0gY2FjaGUgJiYgY2FjaGUuZ2V0SXRlbShwYXRoICsgJzp2YXJzJyk7XG5cbiAgICAgICAgICAgIG1vZGlmeVZhcnMgPSBtb2RpZnlWYXJzIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAodGltZXN0YW1wICYmIHdlYkluZm8ubGFzdE1vZGlmaWVkICYmXG4gICAgICAgICAgICAgICAgKG5ldyBEYXRlKHdlYkluZm8ubGFzdE1vZGlmaWVkKS52YWx1ZU9mKCkgPT09XG4gICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKHRpbWVzdGFtcCkudmFsdWVPZigpKSAmJlxuICAgICAgICAgICAgICAgICghbW9kaWZ5VmFycyAmJiAhdmFycyB8fCBKU09OLnN0cmluZ2lmeShtb2RpZnlWYXJzKSA9PT0gdmFycykpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgbG9jYWwgY29weVxuICAgICAgICAgICAgICAgIHJldHVybiBjc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxufSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKSxcbiAgICBicm93c2VyID0gcmVxdWlyZShcIi4vYnJvd3NlclwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih3aW5kb3csIGxlc3MsIG9wdGlvbnMpIHtcblxuICAgIGZ1bmN0aW9uIGVycm9ySFRNTChlLCByb290SHJlZikge1xuICAgICAgICB2YXIgaWQgPSAnbGVzcy1lcnJvci1tZXNzYWdlOicgKyB1dGlscy5leHRyYWN0SWQocm9vdEhyZWYgfHwgXCJcIik7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9ICc8bGk+PGxhYmVsPntsaW5lfTwvbGFiZWw+PHByZSBjbGFzcz1cIntjbGFzc31cIj57Y29udGVudH08L3ByZT48L2xpPic7XG4gICAgICAgIHZhciBlbGVtID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCB0aW1lciwgY29udGVudCwgZXJyb3JzID0gW107XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IGUuZmlsZW5hbWUgfHwgcm9vdEhyZWY7XG4gICAgICAgIHZhciBmaWxlbmFtZU5vUGF0aCA9IGZpbGVuYW1lLm1hdGNoKC8oW15cXC9dKyhcXD8uKik/KSQvKVsxXTtcblxuICAgICAgICBlbGVtLmlkICAgICAgICA9IGlkO1xuICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IFwibGVzcy1lcnJvci1tZXNzYWdlXCI7XG5cbiAgICAgICAgY29udGVudCA9ICc8aDM+JyAgKyAoZS50eXBlIHx8IFwiU3ludGF4XCIpICsgXCJFcnJvcjogXCIgKyAoZS5tZXNzYWdlIHx8ICdUaGVyZSBpcyBhbiBlcnJvciBpbiB5b3VyIC5sZXNzIGZpbGUnKSArXG4gICAgICAgICAgICAnPC9oMz4nICsgJzxwPmluIDxhIGhyZWY9XCInICsgZmlsZW5hbWUgICArICdcIj4nICsgZmlsZW5hbWVOb1BhdGggKyBcIjwvYT4gXCI7XG5cbiAgICAgICAgdmFyIGVycm9ybGluZSA9IGZ1bmN0aW9uIChlLCBpLCBjbGFzc25hbWUpIHtcbiAgICAgICAgICAgIGlmIChlLmV4dHJhY3RbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRlbXBsYXRlLnJlcGxhY2UoL1xce2xpbmVcXH0vLCAocGFyc2VJbnQoZS5saW5lLCAxMCkgfHwgMCkgKyAoaSAtIDEpKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx7Y2xhc3NcXH0vLCBjbGFzc25hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHtjb250ZW50XFx9LywgZS5leHRyYWN0W2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGUuZXh0cmFjdCkge1xuICAgICAgICAgICAgZXJyb3JsaW5lKGUsIDAsICcnKTtcbiAgICAgICAgICAgIGVycm9ybGluZShlLCAxLCAnbGluZScpO1xuICAgICAgICAgICAgZXJyb3JsaW5lKGUsIDIsICcnKTtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gJ29uIGxpbmUgJyArIGUubGluZSArICcsIGNvbHVtbiAnICsgKGUuY29sdW1uICsgMSkgKyAnOjwvcD4nICtcbiAgICAgICAgICAgICAgICAnPHVsPicgKyBlcnJvcnMuam9pbignJykgKyAnPC91bD4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLnN0YWNrICYmIChlLmV4dHJhY3QgfHwgb3B0aW9ucy5sb2dMZXZlbCA+PSA0KSkge1xuICAgICAgICAgICAgY29udGVudCArPSAnPGJyLz5TdGFjayBUcmFjZTwvYnIgLz4nICsgZS5zdGFjay5zcGxpdCgnXFxuJykuc2xpY2UoMSkuam9pbignPGJyLz4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtLmlubmVySFRNTCA9IGNvbnRlbnQ7XG5cbiAgICAgICAgLy8gQ1NTIGZvciBlcnJvciBtZXNzYWdlc1xuICAgICAgICBicm93c2VyLmNyZWF0ZUNTUyh3aW5kb3cuZG9jdW1lbnQsIFtcbiAgICAgICAgICAgICcubGVzcy1lcnJvci1tZXNzYWdlIHVsLCAubGVzcy1lcnJvci1tZXNzYWdlIGxpIHsnLFxuICAgICAgICAgICAgJ2xpc3Qtc3R5bGUtdHlwZTogbm9uZTsnLFxuICAgICAgICAgICAgJ21hcmdpbi1yaWdodDogMTVweDsnLFxuICAgICAgICAgICAgJ3BhZGRpbmc6IDRweCAwOycsXG4gICAgICAgICAgICAnbWFyZ2luOiAwOycsXG4gICAgICAgICAgICAnfScsXG4gICAgICAgICAgICAnLmxlc3MtZXJyb3ItbWVzc2FnZSBsYWJlbCB7JyxcbiAgICAgICAgICAgICdmb250LXNpemU6IDEycHg7JyxcbiAgICAgICAgICAgICdtYXJnaW4tcmlnaHQ6IDE1cHg7JyxcbiAgICAgICAgICAgICdwYWRkaW5nOiA0cHggMDsnLFxuICAgICAgICAgICAgJ2NvbG9yOiAjY2M3Nzc3OycsXG4gICAgICAgICAgICAnfScsXG4gICAgICAgICAgICAnLmxlc3MtZXJyb3ItbWVzc2FnZSBwcmUgeycsXG4gICAgICAgICAgICAnY29sb3I6ICNkZDY2NjY7JyxcbiAgICAgICAgICAgICdwYWRkaW5nOiA0cHggMDsnLFxuICAgICAgICAgICAgJ21hcmdpbjogMDsnLFxuICAgICAgICAgICAgJ2Rpc3BsYXk6IGlubGluZS1ibG9jazsnLFxuICAgICAgICAgICAgJ30nLFxuICAgICAgICAgICAgJy5sZXNzLWVycm9yLW1lc3NhZ2UgcHJlLmxpbmUgeycsXG4gICAgICAgICAgICAnY29sb3I6ICNmZjAwMDA7JyxcbiAgICAgICAgICAgICd9JyxcbiAgICAgICAgICAgICcubGVzcy1lcnJvci1tZXNzYWdlIGgzIHsnLFxuICAgICAgICAgICAgJ2ZvbnQtc2l6ZTogMjBweDsnLFxuICAgICAgICAgICAgJ2ZvbnQtd2VpZ2h0OiBib2xkOycsXG4gICAgICAgICAgICAncGFkZGluZzogMTVweCAwIDVweCAwOycsXG4gICAgICAgICAgICAnbWFyZ2luOiAwOycsXG4gICAgICAgICAgICAnfScsXG4gICAgICAgICAgICAnLmxlc3MtZXJyb3ItbWVzc2FnZSBhIHsnLFxuICAgICAgICAgICAgJ2NvbG9yOiAjMTBhJyxcbiAgICAgICAgICAgICd9JyxcbiAgICAgICAgICAgICcubGVzcy1lcnJvci1tZXNzYWdlIC5lcnJvciB7JyxcbiAgICAgICAgICAgICdjb2xvcjogcmVkOycsXG4gICAgICAgICAgICAnZm9udC13ZWlnaHQ6IGJvbGQ7JyxcbiAgICAgICAgICAgICdwYWRkaW5nLWJvdHRvbTogMnB4OycsXG4gICAgICAgICAgICAnYm9yZGVyLWJvdHRvbTogMXB4IGRhc2hlZCByZWQ7JyxcbiAgICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLCB7IHRpdGxlOiAnZXJyb3ItbWVzc2FnZScgfSk7XG5cbiAgICAgICAgZWxlbS5zdHlsZS5jc3NUZXh0ID0gW1xuICAgICAgICAgICAgXCJmb250LWZhbWlseTogQXJpYWwsIHNhbnMtc2VyaWZcIixcbiAgICAgICAgICAgIFwiYm9yZGVyOiAxcHggc29saWQgI2UwMFwiLFxuICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlXCIsXG4gICAgICAgICAgICBcImJvcmRlci1yYWRpdXM6IDVweFwiLFxuICAgICAgICAgICAgXCItd2Via2l0LWJvcmRlci1yYWRpdXM6IDVweFwiLFxuICAgICAgICAgICAgXCItbW96LWJvcmRlci1yYWRpdXM6IDVweFwiLFxuICAgICAgICAgICAgXCJjb2xvcjogI2UwMFwiLFxuICAgICAgICAgICAgXCJwYWRkaW5nOiAxNXB4XCIsXG4gICAgICAgICAgICBcIm1hcmdpbi1ib3R0b206IDE1cHhcIlxuICAgICAgICBdLmpvaW4oJzsnKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5lbnYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5yZXBsYWNlQ2hpbGQoZWxlbSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuaW5zZXJ0QmVmb3JlKGVsZW0sIGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRXJyb3JIVE1MKHBhdGgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xlc3MtZXJyb3ItbWVzc2FnZTonICsgdXRpbHMuZXh0cmFjdElkKHBhdGgpKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUVycm9yQ29uc29sZShwYXRoKSB7XG4gICAgICAgIC8vbm8gYWN0aW9uXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRXJyb3IocGF0aCkge1xuICAgICAgICBpZiAoIW9wdGlvbnMuZXJyb3JSZXBvcnRpbmcgfHwgb3B0aW9ucy5lcnJvclJlcG9ydGluZyA9PT0gXCJodG1sXCIpIHtcbiAgICAgICAgICAgIHJlbW92ZUVycm9ySFRNTChwYXRoKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmVycm9yUmVwb3J0aW5nID09PSBcImNvbnNvbGVcIikge1xuICAgICAgICAgICAgcmVtb3ZlRXJyb3JDb25zb2xlKHBhdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmVycm9yUmVwb3J0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcHRpb25zLmVycm9yUmVwb3J0aW5nKFwicmVtb3ZlXCIsIHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJyb3JDb25zb2xlKGUsIHJvb3RIcmVmKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9ICd7bGluZX0ge2NvbnRlbnR9JztcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gZS5maWxlbmFtZSB8fCByb290SHJlZjtcbiAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgY29udGVudCA9IChlLnR5cGUgfHwgXCJTeW50YXhcIikgKyBcIkVycm9yOiBcIiArIChlLm1lc3NhZ2UgfHwgJ1RoZXJlIGlzIGFuIGVycm9yIGluIHlvdXIgLmxlc3MgZmlsZScpICtcbiAgICAgICAgICAgIFwiIGluIFwiICsgZmlsZW5hbWUgKyBcIiBcIjtcblxuICAgICAgICB2YXIgZXJyb3JsaW5lID0gZnVuY3Rpb24gKGUsIGksIGNsYXNzbmFtZSkge1xuICAgICAgICAgICAgaWYgKGUuZXh0cmFjdFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGVtcGxhdGUucmVwbGFjZSgvXFx7bGluZVxcfS8sIChwYXJzZUludChlLmxpbmUsIDEwKSB8fCAwKSArIChpIC0gMSkpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHtjbGFzc1xcfS8sIGNsYXNzbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xce2NvbnRlbnRcXH0vLCBlLmV4dHJhY3RbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZS5leHRyYWN0KSB7XG4gICAgICAgICAgICBlcnJvcmxpbmUoZSwgMCwgJycpO1xuICAgICAgICAgICAgZXJyb3JsaW5lKGUsIDEsICdsaW5lJyk7XG4gICAgICAgICAgICBlcnJvcmxpbmUoZSwgMiwgJycpO1xuICAgICAgICAgICAgY29udGVudCArPSAnb24gbGluZSAnICsgZS5saW5lICsgJywgY29sdW1uICcgKyAoZS5jb2x1bW4gKyAxKSArICc6XFxuJyArXG4gICAgICAgICAgICAgICAgZXJyb3JzLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLnN0YWNrICYmIChlLmV4dHJhY3QgfHwgb3B0aW9ucy5sb2dMZXZlbCA+PSA0KSkge1xuICAgICAgICAgICAgY29udGVudCArPSAnXFxuU3RhY2sgVHJhY2VcXG4nICsgZS5zdGFjaztcbiAgICAgICAgfVxuICAgICAgICBsZXNzLmxvZ2dlci5lcnJvcihjb250ZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvcihlLCByb290SHJlZikge1xuICAgICAgICBpZiAoIW9wdGlvbnMuZXJyb3JSZXBvcnRpbmcgfHwgb3B0aW9ucy5lcnJvclJlcG9ydGluZyA9PT0gXCJodG1sXCIpIHtcbiAgICAgICAgICAgIGVycm9ySFRNTChlLCByb290SHJlZik7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lcnJvclJlcG9ydGluZyA9PT0gXCJjb25zb2xlXCIpIHtcbiAgICAgICAgICAgIGVycm9yQ29uc29sZShlLCByb290SHJlZik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZXJyb3JSZXBvcnRpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JSZXBvcnRpbmcoXCJhZGRcIiwgZSwgcm9vdEhyZWYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkOiBlcnJvcixcbiAgICAgICAgcmVtb3ZlOiByZW1vdmVFcnJvclxuICAgIH07XG59O1xuXG59LHtcIi4vYnJvd3NlclwiOjMsXCIuL3V0aWxzXCI6MTB9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qZ2xvYmFsIHdpbmRvdywgWE1MSHR0cFJlcXVlc3QgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zLCBsb2dnZXIpIHtcblxuICAgIHZhciBBYnN0cmFjdEZpbGVNYW5hZ2VyID0gcmVxdWlyZShcIi4uL2xlc3MvZW52aXJvbm1lbnQvYWJzdHJhY3QtZmlsZS1tYW5hZ2VyLmpzXCIpO1xuXG4gICAgdmFyIGZpbGVDYWNoZSA9IHt9O1xuXG4gICAgLy9UT0RPUyAtIG1vdmUgbG9nIHNvbWV3aGVyZS4gcGF0aERpZmYgYW5kIGRvaW5nIHNvbWV0aGluZyBzaW1pbGFyIGluIG5vZGUuIHVzZSBwYXRoRGlmZiBpbiB0aGUgb3RoZXIgYnJvd3NlciBmaWxlIGZvciB0aGUgaW5pdGlhbCBsb2FkXG5cbiAgICBmdW5jdGlvbiBnZXRYTUxIdHRwUmVxdWVzdCgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sICE9PSBcImZpbGU6XCIgfHwgIShcIkFjdGl2ZVhPYmplY3RcIiBpbiB3aW5kb3cpKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvKmdsb2JhbCBBY3RpdmVYT2JqZWN0ICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgQUpBWC5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgRmlsZU1hbmFnZXIgPSBmdW5jdGlvbigpIHtcbiAgICB9O1xuXG4gICAgRmlsZU1hbmFnZXIucHJvdG90eXBlID0gbmV3IEFic3RyYWN0RmlsZU1hbmFnZXIoKTtcblxuICAgIEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5hbHdheXNNYWtlUGF0aHNBYnNvbHV0ZSA9IGZ1bmN0aW9uIGFsd2F5c01ha2VQYXRoc0Fic29sdXRlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihiYXNlUGF0aCwgbGF0ZXJQYXRoKSB7XG4gICAgICAgIGlmICghYmFzZVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXRlclBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdFVybFBhcnRzKGxhdGVyUGF0aCwgYmFzZVBhdGgpLnBhdGg7XG4gICAgfTtcbiAgICBGaWxlTWFuYWdlci5wcm90b3R5cGUuZG9YSFIgPSBmdW5jdGlvbiBkb1hIUih1cmwsIHR5cGUsIGNhbGxiYWNrLCBlcnJiYWNrKSB7XG5cbiAgICAgICAgdmFyIHhociA9IGdldFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHZhciBhc3luYyA9IG9wdGlvbnMuaXNGaWxlUHJvdG9jb2wgPyBvcHRpb25zLmZpbGVBc3luYyA6IHRydWU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4aHIub3ZlcnJpZGVNaW1lVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvY3NzJyk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiWEhSOiBHZXR0aW5nICdcIiArIHVybCArIFwiJ1wiKTtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgYXN5bmMpO1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgdHlwZSB8fCAndGV4dC94LWxlc3MsIHRleHQvY3NzOyBxPTAuOSwgKi8qOyBxPTAuNScpO1xuICAgICAgICB4aHIuc2VuZChudWxsKTtcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZSh4aHIsIGNhbGxiYWNrLCBlcnJiYWNrKSB7XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhoci5yZXNwb25zZVRleHQsXG4gICAgICAgICAgICAgICAgICAgIHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXJyYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVycmJhY2soeGhyLnN0YXR1cywgdXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmlzRmlsZVByb3RvY29sICYmICFvcHRpb25zLmZpbGVBc3luYykge1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDAgfHwgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycmJhY2soeGhyLnN0YXR1cywgdXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhc3luYykge1xuICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVSZXNwb25zZSh4aHIsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlUmVzcG9uc2UoeGhyLCBjYWxsYmFjaywgZXJyYmFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uKGZpbGVuYW1lLCBjdXJyZW50RGlyZWN0b3J5LCBvcHRpb25zLCBlbnZpcm9ubWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgRmlsZU1hbmFnZXIucHJvdG90eXBlLmNsZWFyRmlsZUNhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZpbGVDYWNoZSA9IHt9O1xuICAgIH07XG5cbiAgICBGaWxlTWFuYWdlci5wcm90b3R5cGUubG9hZEZpbGUgPSBmdW5jdGlvbiBsb2FkRmlsZShmaWxlbmFtZSwgY3VycmVudERpcmVjdG9yeSwgb3B0aW9ucywgZW52aXJvbm1lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjdXJyZW50RGlyZWN0b3J5ICYmICF0aGlzLmlzUGF0aEFic29sdXRlKGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgZmlsZW5hbWUgPSBjdXJyZW50RGlyZWN0b3J5ICsgZmlsZW5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvLyBzaGVldCBtYXkgYmUgc2V0IHRvIHRoZSBzdHlsZXNoZWV0IGZvciB0aGUgaW5pdGlhbCBsb2FkIG9yIGEgY29sbGVjdGlvbiBvZiBwcm9wZXJ0aWVzIGluY2x1ZGluZ1xuICAgICAgICAvLyBzb21lIGNvbnRleHQgdmFyaWFibGVzIGZvciBpbXBvcnRzXG4gICAgICAgIHZhciBocmVmUGFydHMgPSB0aGlzLmV4dHJhY3RVcmxQYXJ0cyhmaWxlbmFtZSwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICB2YXIgaHJlZiAgICAgID0gaHJlZlBhcnRzLnVybDtcblxuICAgICAgICBpZiAob3B0aW9ucy51c2VGaWxlQ2FjaGUgJiYgZmlsZUNhY2hlW2hyZWZdKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBsZXNzVGV4dCA9IGZpbGVDYWNoZVtocmVmXTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IGNvbnRlbnRzOiBsZXNzVGV4dCwgZmlsZW5hbWU6IGhyZWYsIHdlYkluZm86IHsgbGFzdE1vZGlmaWVkOiBuZXcgRGF0ZSgpIH19KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh7ZmlsZW5hbWU6IGhyZWYsIG1lc3NhZ2U6IFwiRXJyb3IgbG9hZGluZyBmaWxlIFwiICsgaHJlZiArIFwiIGVycm9yIHdhcyBcIiArIGUubWVzc2FnZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kb1hIUihocmVmLCBvcHRpb25zLm1pbWUsIGZ1bmN0aW9uIGRvWEhSQ2FsbGJhY2soZGF0YSwgbGFzdE1vZGlmaWVkKSB7XG4gICAgICAgICAgICAvLyBwZXIgZmlsZSBjYWNoZVxuICAgICAgICAgICAgZmlsZUNhY2hlW2hyZWZdID0gZGF0YTtcblxuICAgICAgICAgICAgLy8gVXNlIHJlbW90ZSBjb3B5IChyZS1wYXJzZSlcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsgY29udGVudHM6IGRhdGEsIGZpbGVuYW1lOiBocmVmLCB3ZWJJbmZvOiB7IGxhc3RNb2RpZmllZDogbGFzdE1vZGlmaWVkIH19KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gZG9YSFJFcnJvcihzdGF0dXMsIHVybCkge1xuICAgICAgICAgICAgY2FsbGJhY2soeyB0eXBlOiAnRmlsZScsIG1lc3NhZ2U6IFwiJ1wiICsgdXJsICsgXCInIHdhc24ndCBmb3VuZCAoXCIgKyBzdGF0dXMgKyBcIilcIiwgaHJlZjogaHJlZiB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBGaWxlTWFuYWdlcjtcbn07XG5cbn0se1wiLi4vbGVzcy9lbnZpcm9ubWVudC9hYnN0cmFjdC1maWxlLW1hbmFnZXIuanNcIjoxNX1dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBmdW5jdGlvblJlZ2lzdHJ5ID0gcmVxdWlyZShcIi4vLi4vbGVzcy9mdW5jdGlvbnMvZnVuY3Rpb24tcmVnaXN0cnlcIik7XG5cbiAgICBmdW5jdGlvbiBpbWFnZVNpemUoKSB7XG4gICAgICAgIHRocm93IHtcbiAgICAgICAgICAgIHR5cGU6IFwiUnVudGltZVwiLFxuICAgICAgICAgICAgbWVzc2FnZTogXCJJbWFnZSBzaXplIGZ1bmN0aW9ucyBhcmUgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2YgbGVzc1wiXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGltYWdlRnVuY3Rpb25zID0ge1xuICAgICAgICBcImltYWdlLXNpemVcIjogZnVuY3Rpb24oZmlsZVBhdGhOb2RlKSB7XG4gICAgICAgICAgICBpbWFnZVNpemUodGhpcywgZmlsZVBhdGhOb2RlKTtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJpbWFnZS13aWR0aFwiOiBmdW5jdGlvbihmaWxlUGF0aE5vZGUpIHtcbiAgICAgICAgICAgIGltYWdlU2l6ZSh0aGlzLCBmaWxlUGF0aE5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9LFxuICAgICAgICBcImltYWdlLWhlaWdodFwiOiBmdW5jdGlvbihmaWxlUGF0aE5vZGUpIHtcbiAgICAgICAgICAgIGltYWdlU2l6ZSh0aGlzLCBmaWxlUGF0aE5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uUmVnaXN0cnkuYWRkTXVsdGlwbGUoaW1hZ2VGdW5jdGlvbnMpO1xufTtcblxufSx7XCIuLy4uL2xlc3MvZnVuY3Rpb25zL2Z1bmN0aW9uLXJlZ2lzdHJ5XCI6MjJ9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vXG4vLyBpbmRleC5qc1xuLy8gU2hvdWxkIGV4cG9zZSB0aGUgYWRkaXRpb25hbCBicm93c2VyIGZ1bmN0aW9ucyBvbiB0byB0aGUgbGVzcyBvYmplY3Rcbi8vXG52YXIgYWRkRGF0YUF0dHIgPSByZXF1aXJlKFwiLi91dGlsc1wiKS5hZGREYXRhQXR0cixcbiAgICBicm93c2VyID0gcmVxdWlyZShcIi4vYnJvd3NlclwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih3aW5kb3csIG9wdGlvbnMpIHtcbiAgICB2YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgdmFyIGxlc3MgPSByZXF1aXJlKCcuLi9sZXNzJykoKTtcblxuICAgIC8vbW9kdWxlLmV4cG9ydHMgPSBsZXNzO1xuICAgIGxlc3Mub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdmFyIGVudmlyb25tZW50ID0gbGVzcy5lbnZpcm9ubWVudCxcbiAgICAgICAgRmlsZU1hbmFnZXIgPSByZXF1aXJlKFwiLi9maWxlLW1hbmFnZXJcIikob3B0aW9ucywgbGVzcy5sb2dnZXIpLFxuICAgICAgICBmaWxlTWFuYWdlciA9IG5ldyBGaWxlTWFuYWdlcigpO1xuICAgIGVudmlyb25tZW50LmFkZEZpbGVNYW5hZ2VyKGZpbGVNYW5hZ2VyKTtcbiAgICBsZXNzLkZpbGVNYW5hZ2VyID0gRmlsZU1hbmFnZXI7XG5cbiAgICByZXF1aXJlKFwiLi9sb2ctbGlzdGVuZXJcIikobGVzcywgb3B0aW9ucyk7XG4gICAgdmFyIGVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9yLXJlcG9ydGluZ1wiKSh3aW5kb3csIGxlc3MsIG9wdGlvbnMpO1xuICAgIHZhciBjYWNoZSA9IGxlc3MuY2FjaGUgPSBvcHRpb25zLmNhY2hlIHx8IHJlcXVpcmUoXCIuL2NhY2hlXCIpKHdpbmRvdywgb3B0aW9ucywgbGVzcy5sb2dnZXIpO1xuICAgIHJlcXVpcmUoJy4vaW1hZ2Utc2l6ZScpKGxlc3MuZW52aXJvbm1lbnQpO1xuXG4gICAgLy9TZXR1cCB1c2VyIGZ1bmN0aW9uc1xuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9ucykge1xuICAgICAgICBsZXNzLmZ1bmN0aW9ucy5mdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKG9wdGlvbnMuZnVuY3Rpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZVBhdHRlcm4gPSAvXnRleHRcXC8oeC0pP2xlc3MkLztcblxuICAgIGZ1bmN0aW9uIHBvc3RQcm9jZXNzQ1NTKHN0eWxlcykgeyAvLyBkZXByZWNhdGVkLCB1c2UgYSBwbHVnaW4gZm9yIHBvc3Rwcm9jZXNzdGFza3NcbiAgICAgICAgaWYgKG9wdGlvbnMucG9zdFByb2Nlc3NvciAmJiB0eXBlb2Ygb3B0aW9ucy5wb3N0UHJvY2Vzc29yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdHlsZXMgPSBvcHRpb25zLnBvc3RQcm9jZXNzb3IuY2FsbChzdHlsZXMsIHN0eWxlcykgfHwgc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgICAgIHZhciBjbG9uZWQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBjbG9uZWRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG5cbiAgICAvLyBvbmx5IHJlYWxseSBuZWVkZWQgZm9yIHBoYW50b21cbiAgICBmdW5jdGlvbiBiaW5kKGZ1bmMsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIGN1cnJ5QXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gY3VycnlBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRTdHlsZXMobW9kaWZ5VmFycykge1xuICAgICAgICB2YXIgc3R5bGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0eWxlJyksXG4gICAgICAgICAgICBzdHlsZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbaV07XG4gICAgICAgICAgICBpZiAoc3R5bGUudHlwZS5tYXRjaCh0eXBlUGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VPcHRpb25zID0gY2xvbmUob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VPcHRpb25zLm1vZGlmeVZhcnMgPSBtb2RpZnlWYXJzO1xuICAgICAgICAgICAgICAgIHZhciBsZXNzVGV4dCA9IHN0eWxlLmlubmVySFRNTCB8fCAnJztcbiAgICAgICAgICAgICAgICBpbnN0YW5jZU9wdGlvbnMuZmlsZW5hbWUgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyMuKiQvLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvKmpzaGludCBsb29wZnVuYzp0cnVlICovXG4gICAgICAgICAgICAgICAgLy8gdXNlIGNsb3N1cmUgdG8gc3RvcmUgY3VycmVudCBzdHlsZVxuICAgICAgICAgICAgICAgIGxlc3MucmVuZGVyKGxlc3NUZXh0LCBpbnN0YW5jZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kKGZ1bmN0aW9uKHN0eWxlLCBlLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMuYWRkKGUsIFwiaW5saW5lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVzdWx0LmNzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLmlubmVySFRNTCA9IHJlc3VsdC5jc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBudWxsLCBzdHlsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZFN0eWxlU2hlZXQoc2hlZXQsIGNhbGxiYWNrLCByZWxvYWQsIHJlbWFpbmluZywgbW9kaWZ5VmFycykge1xuXG4gICAgICAgIHZhciBpbnN0YW5jZU9wdGlvbnMgPSBjbG9uZShvcHRpb25zKTtcbiAgICAgICAgYWRkRGF0YUF0dHIoaW5zdGFuY2VPcHRpb25zLCBzaGVldCk7XG4gICAgICAgIGluc3RhbmNlT3B0aW9ucy5taW1lID0gc2hlZXQudHlwZTtcblxuICAgICAgICBpZiAobW9kaWZ5VmFycykge1xuICAgICAgICAgICAgaW5zdGFuY2VPcHRpb25zLm1vZGlmeVZhcnMgPSBtb2RpZnlWYXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbG9hZEluaXRpYWxGaWxlQ2FsbGJhY2sobG9hZGVkRmlsZSkge1xuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGxvYWRlZEZpbGUuY29udGVudHMsXG4gICAgICAgICAgICAgICAgcGF0aCA9IGxvYWRlZEZpbGUuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgd2ViSW5mbyA9IGxvYWRlZEZpbGUud2ViSW5mbztcblxuICAgICAgICAgICAgdmFyIG5ld0ZpbGVJbmZvID0ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnREaXJlY3Rvcnk6IGZpbGVNYW5hZ2VyLmdldFBhdGgocGF0aCksXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHBhdGgsXG4gICAgICAgICAgICAgICAgcm9vdEZpbGVuYW1lOiBwYXRoLFxuICAgICAgICAgICAgICAgIHJlbGF0aXZlVXJsczogaW5zdGFuY2VPcHRpb25zLnJlbGF0aXZlVXJsc307XG5cbiAgICAgICAgICAgIG5ld0ZpbGVJbmZvLmVudHJ5UGF0aCA9IG5ld0ZpbGVJbmZvLmN1cnJlbnREaXJlY3Rvcnk7XG4gICAgICAgICAgICBuZXdGaWxlSW5mby5yb290cGF0aCA9IGluc3RhbmNlT3B0aW9ucy5yb290cGF0aCB8fCBuZXdGaWxlSW5mby5jdXJyZW50RGlyZWN0b3J5O1xuXG4gICAgICAgICAgICBpZiAod2ViSW5mbykge1xuICAgICAgICAgICAgICAgIHdlYkluZm8ucmVtYWluaW5nID0gcmVtYWluaW5nO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNzcyA9IGNhY2hlLmdldENTUyhwYXRoLCB3ZWJJbmZvLCBpbnN0YW5jZU9wdGlvbnMubW9kaWZ5VmFycyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWxvYWQgJiYgY3NzKSB7XG4gICAgICAgICAgICAgICAgICAgIHdlYkluZm8ubG9jYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBjc3MsIGRhdGEsIHNoZWV0LCB3ZWJJbmZvLCBwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1RPRE8gYWRkIHRlc3RzIGFyb3VuZCBob3cgdGhpcyBiZWhhdmVzIHdoZW4gcmVsb2FkaW5nXG4gICAgICAgICAgICBlcnJvcnMucmVtb3ZlKHBhdGgpO1xuXG4gICAgICAgICAgICBpbnN0YW5jZU9wdGlvbnMucm9vdEZpbGVJbmZvID0gbmV3RmlsZUluZm87XG4gICAgICAgICAgICBsZXNzLnJlbmRlcihkYXRhLCBpbnN0YW5jZU9wdGlvbnMsIGZ1bmN0aW9uKGUsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuaHJlZiA9IHBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jc3MgPSBwb3N0UHJvY2Vzc0NTUyhyZXN1bHQuY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0Q1NTKHNoZWV0LmhyZWYsIHdlYkluZm8ubGFzdE1vZGlmaWVkLCBpbnN0YW5jZU9wdGlvbnMubW9kaWZ5VmFycywgcmVzdWx0LmNzcyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdC5jc3MsIGRhdGEsIHNoZWV0LCB3ZWJJbmZvLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbGVNYW5hZ2VyLmxvYWRGaWxlKHNoZWV0LmhyZWYsIG51bGwsIGluc3RhbmNlT3B0aW9ucywgZW52aXJvbm1lbnQsIGZ1bmN0aW9uKGUsIGxvYWRlZEZpbGUpIHtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9hZEluaXRpYWxGaWxlQ2FsbGJhY2sobG9hZGVkRmlsZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRTdHlsZVNoZWV0cyhjYWxsYmFjaywgcmVsb2FkLCBtb2RpZnlWYXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVzcy5zaGVldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxvYWRTdHlsZVNoZWV0KGxlc3Muc2hlZXRzW2ldLCBjYWxsYmFjaywgcmVsb2FkLCBsZXNzLnNoZWV0cy5sZW5ndGggLSAoaSArIDEpLCBtb2RpZnlWYXJzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRSdW5uaW5nTW9kZSgpIHtcbiAgICAgICAgaWYgKGxlc3MuZW52ID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBsZXNzLndhdGNoVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlc3Mud2F0Y2hNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVNYW5hZ2VyLmNsZWFyRmlsZUNhY2hlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRTdHlsZVNoZWV0cyhmdW5jdGlvbiAoZSwgY3NzLCBfLCBzaGVldCwgd2ViSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMuYWRkKGUsIGUuaHJlZiB8fCBzaGVldC5ocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5jcmVhdGVDU1Mod2luZG93LmRvY3VtZW50LCBjc3MsIHNoZWV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgb3B0aW9ucy5wb2xsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gV2F0Y2ggbW9kZVxuICAgIC8vXG4gICAgbGVzcy53YXRjaCAgID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWxlc3Mud2F0Y2hNb2RlICkge1xuICAgICAgICAgICAgbGVzcy5lbnYgPSAnZGV2ZWxvcG1lbnQnO1xuICAgICAgICAgICAgaW5pdFJ1bm5pbmdNb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXRjaE1vZGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgbGVzcy51bndhdGNoID0gZnVuY3Rpb24gKCkge2NsZWFySW50ZXJ2YWwobGVzcy53YXRjaFRpbWVyKTsgdGhpcy53YXRjaE1vZGUgPSBmYWxzZTsgcmV0dXJuIGZhbHNlOyB9O1xuXG4gICAgLy9cbiAgICAvLyBTeW5jaHJvbm91c2x5IGdldCBhbGwgPGxpbms+IHRhZ3Mgd2l0aCB0aGUgJ3JlbCcgYXR0cmlidXRlIHNldCB0b1xuICAgIC8vIFwic3R5bGVzaGVldC9sZXNzXCIuXG4gICAgLy9cbiAgICBsZXNzLnJlZ2lzdGVyU3R5bGVzaGVldHNJbW1lZGlhdGVseSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGlua3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGluaycpO1xuICAgICAgICBsZXNzLnNoZWV0cyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5rc1tpXS5yZWwgPT09ICdzdHlsZXNoZWV0L2xlc3MnIHx8IChsaW5rc1tpXS5yZWwubWF0Y2goL3N0eWxlc2hlZXQvKSAmJlxuICAgICAgICAgICAgICAgIChsaW5rc1tpXS50eXBlLm1hdGNoKHR5cGVQYXR0ZXJuKSkpKSB7XG4gICAgICAgICAgICAgICAgbGVzcy5zaGVldHMucHVzaChsaW5rc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9cbiAgICAvLyBBc3luY2hyb25vdXNseSBnZXQgYWxsIDxsaW5rPiB0YWdzIHdpdGggdGhlICdyZWwnIGF0dHJpYnV0ZSBzZXQgdG9cbiAgICAvLyBcInN0eWxlc2hlZXQvbGVzc1wiLCByZXR1cm5pbmcgYSBQcm9taXNlLlxuICAgIC8vXG4gICAgbGVzcy5yZWdpc3RlclN0eWxlc2hlZXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGxlc3MucmVnaXN0ZXJTdHlsZXNoZWV0c0ltbWVkaWF0ZWx5KCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIFdpdGggdGhpcyBmdW5jdGlvbiwgaXQncyBwb3NzaWJsZSB0byBhbHRlciB2YXJpYWJsZXMgYW5kIHJlLXJlbmRlclxuICAgIC8vIENTUyB3aXRob3V0IHJlbG9hZGluZyBsZXNzLWZpbGVzXG4gICAgLy9cbiAgICBsZXNzLm1vZGlmeVZhcnMgPSBmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIGxlc3MucmVmcmVzaCh0cnVlLCByZWNvcmQsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgbGVzcy5yZWZyZXNoID0gZnVuY3Rpb24gKHJlbG9hZCwgbW9kaWZ5VmFycywgY2xlYXJGaWxlQ2FjaGUpIHtcbiAgICAgICAgaWYgKChyZWxvYWQgfHwgY2xlYXJGaWxlQ2FjaGUpICYmIGNsZWFyRmlsZUNhY2hlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZmlsZU1hbmFnZXIuY2xlYXJGaWxlQ2FjaGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0VGltZSwgZW5kVGltZSwgdG90YWxNaWxsaXNlY29uZHMsIHJlbWFpbmluZ1NoZWV0cztcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IGVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBTZXQgY291bnRlciBmb3IgcmVtYWluaW5nIHVucHJvY2Vzc2VkIHNoZWV0c1xuICAgICAgICAgICAgcmVtYWluaW5nU2hlZXRzID0gbGVzcy5zaGVldHMubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAocmVtYWluaW5nU2hlZXRzID09PSAwKSB7XG5cbiAgICAgICAgICAgICAgICBlbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICB0b3RhbE1pbGxpc2Vjb25kcyA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgbGVzcy5sb2dnZXIuaW5mbyhcIkxlc3MgaGFzIGZpbmlzaGVkIGFuZCBubyBzaGVldHMgd2VyZSBsb2FkZWQuXCIpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kVGltZTogZW5kVGltZSxcbiAgICAgICAgICAgICAgICAgICAgdG90YWxNaWxsaXNlY29uZHM6IHRvdGFsTWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgICAgICBzaGVldHM6IGxlc3Muc2hlZXRzLmxlbmd0aFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlbGllcyBvbiBsZXNzLnNoZWV0cyBhcnJheSwgY2FsbGJhY2sgc2VlbXMgdG8gYmUgZ3VhcmFudGVlZCB0byBiZSBjYWxsZWQgZm9yIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIGFycmF5XG4gICAgICAgICAgICAgICAgbG9hZFN0eWxlU2hlZXRzKGZ1bmN0aW9uIChlLCBjc3MsIF8sIHNoZWV0LCB3ZWJJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMuYWRkKGUsIGUuaHJlZiB8fCBzaGVldC5ocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAod2ViSW5mby5sb2NhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVzcy5sb2dnZXIuaW5mbyhcIkxvYWRpbmcgXCIgKyBzaGVldC5ocmVmICsgXCIgZnJvbSBjYWNoZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXNzLmxvZ2dlci5pbmZvKFwiUmVuZGVyZWQgXCIgKyBzaGVldC5ocmVmICsgXCIgc3VjY2Vzc2Z1bGx5LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicm93c2VyLmNyZWF0ZUNTUyh3aW5kb3cuZG9jdW1lbnQsIGNzcywgc2hlZXQpO1xuICAgICAgICAgICAgICAgICAgICBsZXNzLmxvZ2dlci5pbmZvKFwiQ1NTIGZvciBcIiArIHNoZWV0LmhyZWYgKyBcIiBnZW5lcmF0ZWQgaW4gXCIgKyAobmV3IERhdGUoKSAtIGVuZFRpbWUpICsgJ21zJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ291bnQgY29tcGxldGVkIHNoZWV0XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ1NoZWV0cy0tO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBsYXN0IHJlbWFpbmluZyBzaGVldCB3YXMgcHJvY2Vzc2VkIGFuZCB0aGVuIGNhbGwgdGhlIHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZ1NoZWV0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxNaWxsaXNlY29uZHMgPSBuZXcgRGF0ZSgpIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVzcy5sb2dnZXIuaW5mbyhcIkxlc3MgaGFzIGZpbmlzaGVkLiBDU1MgZ2VuZXJhdGVkIGluIFwiICsgdG90YWxNaWxsaXNlY29uZHMgKyAnbXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFRpbWU6IGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxNaWxsaXNlY29uZHM6IHRvdGFsTWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoZWV0czogbGVzcy5zaGVldHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICB9LCByZWxvYWQsIG1vZGlmeVZhcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb2FkU3R5bGVzKG1vZGlmeVZhcnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgbGVzcy5yZWZyZXNoU3R5bGVzID0gbG9hZFN0eWxlcztcbiAgICByZXR1cm4gbGVzcztcbn07XG5cbn0se1wiLi4vbGVzc1wiOjMxLFwiLi9icm93c2VyXCI6MyxcIi4vY2FjaGVcIjo0LFwiLi9lcnJvci1yZXBvcnRpbmdcIjo1LFwiLi9maWxlLW1hbmFnZXJcIjo2LFwiLi9pbWFnZS1zaXplXCI6NyxcIi4vbG9nLWxpc3RlbmVyXCI6OSxcIi4vdXRpbHNcIjoxMH1dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsZXNzLCBvcHRpb25zKSB7XG5cbiAgICB2YXIgbG9nTGV2ZWxfZGVidWcgPSA0LFxuICAgICAgICBsb2dMZXZlbF9pbmZvID0gMyxcbiAgICAgICAgbG9nTGV2ZWxfd2FybiA9IDIsXG4gICAgICAgIGxvZ0xldmVsX2Vycm9yID0gMTtcblxuICAgIC8vIFRoZSBhbW91bnQgb2YgbG9nZ2luZyBpbiB0aGUgamF2YXNjcmlwdCBjb25zb2xlLlxuICAgIC8vIDMgLSBEZWJ1ZywgaW5mb3JtYXRpb24gYW5kIGVycm9yc1xuICAgIC8vIDIgLSBJbmZvcm1hdGlvbiBhbmQgZXJyb3JzXG4gICAgLy8gMSAtIEVycm9yc1xuICAgIC8vIDAgLSBOb25lXG4gICAgLy8gRGVmYXVsdHMgdG8gMlxuICAgIG9wdGlvbnMubG9nTGV2ZWwgPSB0eXBlb2Ygb3B0aW9ucy5sb2dMZXZlbCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmxvZ0xldmVsIDogKG9wdGlvbnMuZW52ID09PSAnZGV2ZWxvcG1lbnQnID8gIGxvZ0xldmVsX2luZm8gOiBsb2dMZXZlbF9lcnJvcik7XG5cbiAgICBpZiAoIW9wdGlvbnMubG9nZ2Vycykge1xuICAgICAgICBvcHRpb25zLmxvZ2dlcnMgPSBbe1xuICAgICAgICAgICAgZGVidWc6IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxvZ0xldmVsID49IGxvZ0xldmVsX2RlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluZm86IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxvZ0xldmVsID49IGxvZ0xldmVsX2luZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2FybjogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9nTGV2ZWwgPj0gbG9nTGV2ZWxfd2Fybikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxvZ0xldmVsID49IGxvZ0xldmVsX2Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1dO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubG9nZ2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXNzLmxvZ2dlci5hZGRMaXN0ZW5lcihvcHRpb25zLmxvZ2dlcnNbaV0pO1xuICAgIH1cbn07XG5cbn0se31dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGV4dHJhY3RJZDogZnVuY3Rpb24oaHJlZikge1xuICAgICAgICByZXR1cm4gaHJlZi5yZXBsYWNlKC9eW2Etei1dKzpcXC8rP1teXFwvXSsvLCAnJykgIC8vIFJlbW92ZSBwcm90b2NvbCAmIGRvbWFpblxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXD9cXCZdbGl2ZXJlbG9hZD1cXHcrLywgJycpICAgICAgICAvLyBSZW1vdmUgTGl2ZVJlbG9hZCBjYWNoZWJ1c3RlclxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXC8vLCAnJykgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHJvb3QgL1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcLlthLXpBLVpdKyQvLCAnJykgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHNpbXBsZSBleHRlbnNpb25cbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXlxcLlxcdy1dKy9nLCAnLScpICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGlsbGVnYWwgY2hhcmFjdGVyc1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcLi9nLCAnOicpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBkb3RzIHdpdGggY29sb25zKGZvciB2YWxpZCBpZClcbiAgICB9LFxuICAgIGFkZERhdGFBdHRyOiBmdW5jdGlvbihvcHRpb25zLCB0YWcpIHtcbiAgICAgICAgZm9yICh2YXIgb3B0IGluIHRhZy5kYXRhc2V0KSB7XG4gICAgICAgICAgICBpZiAodGFnLmRhdGFzZXQuaGFzT3duUHJvcGVydHkob3B0KSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHQgPT09IFwiZW52XCIgfHwgb3B0ID09PSBcImR1bXBMaW5lTnVtYmVyc1wiIHx8IG9wdCA9PT0gXCJyb290cGF0aFwiIHx8IG9wdCA9PT0gXCJlcnJvclJlcG9ydGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbb3B0XSA9IHRhZy5kYXRhc2V0W29wdF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbb3B0XSA9IEpTT04ucGFyc2UodGFnLmRhdGFzZXRbb3B0XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2goXykge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG59LHt9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgY29udGV4dHMgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gY29udGV4dHM7XG5cbnZhciBjb3B5RnJvbU9yaWdpbmFsID0gZnVuY3Rpb24gY29weUZyb21PcmlnaW5hbChvcmlnaW5hbCwgZGVzdGluYXRpb24sIHByb3BlcnRpZXNUb0NvcHkpIHtcbiAgICBpZiAoIW9yaWdpbmFsKSB7IHJldHVybjsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzVG9Db3B5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0aWVzVG9Db3B5W2ldKSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydGllc1RvQ29weVtpXV0gPSBvcmlnaW5hbFtwcm9wZXJ0aWVzVG9Db3B5W2ldXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qXG4gcGFyc2UgaXMgdXNlZCB3aGlsc3QgcGFyc2luZ1xuICovXG52YXIgcGFyc2VDb3B5UHJvcGVydGllcyA9IFtcbiAgICAvLyBvcHRpb25zXG4gICAgJ3BhdGhzJywgICAgICAgICAgICAvLyBvcHRpb24gLSB1bm1vZGlmaWVkIC0gcGF0aHMgdG8gc2VhcmNoIGZvciBpbXBvcnRzIG9uXG4gICAgJ3JlbGF0aXZlVXJscycsICAgICAvLyBvcHRpb24gLSB3aGV0aGVyIHRvIGFkanVzdCBVUkwncyB0byBiZSByZWxhdGl2ZVxuICAgICdyb290cGF0aCcsICAgICAgICAgLy8gb3B0aW9uIC0gcm9vdHBhdGggdG8gYXBwZW5kIHRvIFVSTCdzXG4gICAgJ3N0cmljdEltcG9ydHMnLCAgICAvLyBvcHRpb24gLVxuICAgICdpbnNlY3VyZScsICAgICAgICAgLy8gb3B0aW9uIC0gd2hldGhlciB0byBhbGxvdyBpbXBvcnRzIGZyb20gaW5zZWN1cmUgc3NsIGhvc3RzXG4gICAgJ2R1bXBMaW5lTnVtYmVycycsICAvLyBvcHRpb24gLSB3aGV0aGVyIHRvIGR1bXAgbGluZSBudW1iZXJzXG4gICAgJ2NvbXByZXNzJywgICAgICAgICAvLyBvcHRpb24gLSB3aGV0aGVyIHRvIGNvbXByZXNzXG4gICAgJ3N5bmNJbXBvcnQnLCAgICAgICAvLyBvcHRpb24gLSB3aGV0aGVyIHRvIGltcG9ydCBzeW5jaHJvbm91c2x5XG4gICAgJ2NodW5rSW5wdXQnLCAgICAgICAvLyBvcHRpb24gLSB3aGV0aGVyIHRvIGNodW5rIGlucHV0LiBtb3JlIHBlcmZvcm1hbnQgYnV0IGNhdXNlcyBwYXJzZSBpc3N1ZXMuXG4gICAgJ21pbWUnLCAgICAgICAgICAgICAvLyBicm93c2VyIG9ubHkgLSBtaW1lIHR5cGUgZm9yIHNoZWV0IGltcG9ydFxuICAgICd1c2VGaWxlQ2FjaGUnLCAgICAgLy8gYnJvd3NlciBvbmx5IC0gd2hldGhlciB0byB1c2UgdGhlIHBlciBmaWxlIHNlc3Npb24gY2FjaGVcbiAgICAvLyBjb250ZXh0XG4gICAgJ3Byb2Nlc3NJbXBvcnRzJywgICAvLyBvcHRpb24gJiBjb250ZXh0IC0gd2hldGhlciB0byBwcm9jZXNzIGltcG9ydHMuIGlmIGZhbHNlIHRoZW4gaW1wb3J0cyB3aWxsIG5vdCBiZSBpbXBvcnRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZWQgYnkgdGhlIGltcG9ydCBtYW5hZ2VyIHRvIHN0b3AgbXVsdGlwbGUgaW1wb3J0IHZpc2l0b3JzIGJlaW5nIGNyZWF0ZWQuXG4gICAgJ3BsdWdpbk1hbmFnZXInICAgICAvLyBVc2VkIGFzIHRoZSBwbHVnaW4gbWFuYWdlciBmb3IgdGhlIHNlc3Npb25cbl07XG5cbmNvbnRleHRzLlBhcnNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGNvcHlGcm9tT3JpZ2luYWwob3B0aW9ucywgdGhpcywgcGFyc2VDb3B5UHJvcGVydGllcyk7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMucGF0aHMgPT09IFwic3RyaW5nXCIpIHsgdGhpcy5wYXRocyA9IFt0aGlzLnBhdGhzXTsgfVxufTtcblxudmFyIGV2YWxDb3B5UHJvcGVydGllcyA9IFtcbiAgICAncGF0aHMnLCAgICAgICAgICAvLyBhZGRpdGlvbmFsIGluY2x1ZGUgcGF0aHNcbiAgICAnY29tcHJlc3MnLCAgICAgICAvLyB3aGV0aGVyIHRvIGNvbXByZXNzXG4gICAgJ2llQ29tcGF0JywgICAgICAgLy8gd2hldGhlciB0byBlbmZvcmNlIElFIGNvbXBhdGliaWxpdHkgKElFOCBkYXRhLXVyaSlcbiAgICAnc3RyaWN0TWF0aCcsICAgICAvLyB3aGV0aGVyIG1hdGggaGFzIHRvIGJlIHdpdGhpbiBwYXJlbnRoZXNpc1xuICAgICdzdHJpY3RVbml0cycsICAgIC8vIHdoZXRoZXIgdW5pdHMgbmVlZCB0byBldmFsdWF0ZSBjb3JyZWN0bHlcbiAgICAnc291cmNlTWFwJywgICAgICAvLyB3aGV0aGVyIHRvIG91dHB1dCBhIHNvdXJjZSBtYXBcbiAgICAnaW1wb3J0TXVsdGlwbGUnLCAvLyB3aGV0aGVyIHdlIGFyZSBjdXJyZW50bHkgaW1wb3J0aW5nIG11bHRpcGxlIGNvcGllc1xuICAgICd1cmxBcmdzJywgICAgICAgIC8vIHdoZXRoZXIgdG8gYWRkIGFyZ3MgaW50byB1cmwgdG9rZW5zXG4gICAgJ2phdmFzY3JpcHRFbmFibGVkJywvLyBvcHRpb24gLSB3aGV0aGVyIEphdmFTY3JpcHQgaXMgZW5hYmxlZC4gaWYgdW5kZWZpbmVkLCBkZWZhdWx0cyB0byB0cnVlXG4gICAgJ3BsdWdpbk1hbmFnZXInLCAgLy8gVXNlZCBhcyB0aGUgcGx1Z2luIG1hbmFnZXIgZm9yIHRoZSBzZXNzaW9uXG4gICAgJ2ltcG9ydGFudFNjb3BlJyAgLy8gdXNlZCB0byBidWJibGUgdXAgIWltcG9ydGFudCBzdGF0ZW1lbnRzXG4gICAgXTtcblxuY29udGV4dHMuRXZhbCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGZyYW1lcykge1xuICAgIGNvcHlGcm9tT3JpZ2luYWwob3B0aW9ucywgdGhpcywgZXZhbENvcHlQcm9wZXJ0aWVzKTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5wYXRocyA9PT0gXCJzdHJpbmdcIikgeyB0aGlzLnBhdGhzID0gW3RoaXMucGF0aHNdOyB9XG5cbiAgICB0aGlzLmZyYW1lcyA9IGZyYW1lcyB8fCBbXTtcbiAgICB0aGlzLmltcG9ydGFudFNjb3BlID0gdGhpcy5pbXBvcnRhbnRTY29wZSB8fCBbXTtcbn07XG5cbmNvbnRleHRzLkV2YWwucHJvdG90eXBlLmluUGFyZW50aGVzaXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVuc1N0YWNrKSB7XG4gICAgICAgIHRoaXMucGFyZW5zU3RhY2sgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnNTdGFjay5wdXNoKHRydWUpO1xufTtcblxuY29udGV4dHMuRXZhbC5wcm90b3R5cGUub3V0T2ZQYXJlbnRoZXNpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBhcmVuc1N0YWNrLnBvcCgpO1xufTtcblxuY29udGV4dHMuRXZhbC5wcm90b3R5cGUuaXNNYXRoT24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaWN0TWF0aCA/ICh0aGlzLnBhcmVuc1N0YWNrICYmIHRoaXMucGFyZW5zU3RhY2subGVuZ3RoKSA6IHRydWU7XG59O1xuXG5jb250ZXh0cy5FdmFsLnByb3RvdHlwZS5pc1BhdGhSZWxhdGl2ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuICEvXig/OlthLXotXSs6fFxcL3wjKS9pLnRlc3QocGF0aCk7XG59O1xuXG5jb250ZXh0cy5FdmFsLnByb3RvdHlwZS5ub3JtYWxpemVQYXRoID0gZnVuY3Rpb24oIHBhdGggKSB7XG4gICAgdmFyXG4gICAgICBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpLnJldmVyc2UoKSxcbiAgICAgIHNlZ21lbnQ7XG5cbiAgICBwYXRoID0gW107XG4gICAgd2hpbGUgKHNlZ21lbnRzLmxlbmd0aCAhPT0gMCApIHtcbiAgICAgICAgc2VnbWVudCA9IHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICBzd2l0Y2goIHNlZ21lbnQgKSB7XG4gICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIi4uXCI6XG4gICAgICAgICAgICAgICAgaWYgKChwYXRoLmxlbmd0aCA9PT0gMCkgfHwgKHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gXCIuLlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2goIHNlZ21lbnQgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKCBzZWdtZW50ICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aC5qb2luKFwiL1wiKTtcbn07XG5cbi8vdG9kbyAtIGRvIHRoZSBzYW1lIGZvciB0aGUgdG9DU1MgP1xuXG59LHt9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnYWxpY2VibHVlJzonI2YwZjhmZicsXG4gICAgJ2FudGlxdWV3aGl0ZSc6JyNmYWViZDcnLFxuICAgICdhcXVhJzonIzAwZmZmZicsXG4gICAgJ2FxdWFtYXJpbmUnOicjN2ZmZmQ0JyxcbiAgICAnYXp1cmUnOicjZjBmZmZmJyxcbiAgICAnYmVpZ2UnOicjZjVmNWRjJyxcbiAgICAnYmlzcXVlJzonI2ZmZTRjNCcsXG4gICAgJ2JsYWNrJzonIzAwMDAwMCcsXG4gICAgJ2JsYW5jaGVkYWxtb25kJzonI2ZmZWJjZCcsXG4gICAgJ2JsdWUnOicjMDAwMGZmJyxcbiAgICAnYmx1ZXZpb2xldCc6JyM4YTJiZTInLFxuICAgICdicm93bic6JyNhNTJhMmEnLFxuICAgICdidXJseXdvb2QnOicjZGViODg3JyxcbiAgICAnY2FkZXRibHVlJzonIzVmOWVhMCcsXG4gICAgJ2NoYXJ0cmV1c2UnOicjN2ZmZjAwJyxcbiAgICAnY2hvY29sYXRlJzonI2QyNjkxZScsXG4gICAgJ2NvcmFsJzonI2ZmN2Y1MCcsXG4gICAgJ2Nvcm5mbG93ZXJibHVlJzonIzY0OTVlZCcsXG4gICAgJ2Nvcm5zaWxrJzonI2ZmZjhkYycsXG4gICAgJ2NyaW1zb24nOicjZGMxNDNjJyxcbiAgICAnY3lhbic6JyMwMGZmZmYnLFxuICAgICdkYXJrYmx1ZSc6JyMwMDAwOGInLFxuICAgICdkYXJrY3lhbic6JyMwMDhiOGInLFxuICAgICdkYXJrZ29sZGVucm9kJzonI2I4ODYwYicsXG4gICAgJ2RhcmtncmF5JzonI2E5YTlhOScsXG4gICAgJ2RhcmtncmV5JzonI2E5YTlhOScsXG4gICAgJ2RhcmtncmVlbic6JyMwMDY0MDAnLFxuICAgICdkYXJra2hha2knOicjYmRiNzZiJyxcbiAgICAnZGFya21hZ2VudGEnOicjOGIwMDhiJyxcbiAgICAnZGFya29saXZlZ3JlZW4nOicjNTU2YjJmJyxcbiAgICAnZGFya29yYW5nZSc6JyNmZjhjMDAnLFxuICAgICdkYXJrb3JjaGlkJzonIzk5MzJjYycsXG4gICAgJ2RhcmtyZWQnOicjOGIwMDAwJyxcbiAgICAnZGFya3NhbG1vbic6JyNlOTk2N2EnLFxuICAgICdkYXJrc2VhZ3JlZW4nOicjOGZiYzhmJyxcbiAgICAnZGFya3NsYXRlYmx1ZSc6JyM0ODNkOGInLFxuICAgICdkYXJrc2xhdGVncmF5JzonIzJmNGY0ZicsXG4gICAgJ2RhcmtzbGF0ZWdyZXknOicjMmY0ZjRmJyxcbiAgICAnZGFya3R1cnF1b2lzZSc6JyMwMGNlZDEnLFxuICAgICdkYXJrdmlvbGV0JzonIzk0MDBkMycsXG4gICAgJ2RlZXBwaW5rJzonI2ZmMTQ5MycsXG4gICAgJ2RlZXBza3libHVlJzonIzAwYmZmZicsXG4gICAgJ2RpbWdyYXknOicjNjk2OTY5JyxcbiAgICAnZGltZ3JleSc6JyM2OTY5NjknLFxuICAgICdkb2RnZXJibHVlJzonIzFlOTBmZicsXG4gICAgJ2ZpcmVicmljayc6JyNiMjIyMjInLFxuICAgICdmbG9yYWx3aGl0ZSc6JyNmZmZhZjAnLFxuICAgICdmb3Jlc3RncmVlbic6JyMyMjhiMjInLFxuICAgICdmdWNoc2lhJzonI2ZmMDBmZicsXG4gICAgJ2dhaW5zYm9ybyc6JyNkY2RjZGMnLFxuICAgICdnaG9zdHdoaXRlJzonI2Y4ZjhmZicsXG4gICAgJ2dvbGQnOicjZmZkNzAwJyxcbiAgICAnZ29sZGVucm9kJzonI2RhYTUyMCcsXG4gICAgJ2dyYXknOicjODA4MDgwJyxcbiAgICAnZ3JleSc6JyM4MDgwODAnLFxuICAgICdncmVlbic6JyMwMDgwMDAnLFxuICAgICdncmVlbnllbGxvdyc6JyNhZGZmMmYnLFxuICAgICdob25leWRldyc6JyNmMGZmZjAnLFxuICAgICdob3RwaW5rJzonI2ZmNjliNCcsXG4gICAgJ2luZGlhbnJlZCc6JyNjZDVjNWMnLFxuICAgICdpbmRpZ28nOicjNGIwMDgyJyxcbiAgICAnaXZvcnknOicjZmZmZmYwJyxcbiAgICAna2hha2knOicjZjBlNjhjJyxcbiAgICAnbGF2ZW5kZXInOicjZTZlNmZhJyxcbiAgICAnbGF2ZW5kZXJibHVzaCc6JyNmZmYwZjUnLFxuICAgICdsYXduZ3JlZW4nOicjN2NmYzAwJyxcbiAgICAnbGVtb25jaGlmZm9uJzonI2ZmZmFjZCcsXG4gICAgJ2xpZ2h0Ymx1ZSc6JyNhZGQ4ZTYnLFxuICAgICdsaWdodGNvcmFsJzonI2YwODA4MCcsXG4gICAgJ2xpZ2h0Y3lhbic6JyNlMGZmZmYnLFxuICAgICdsaWdodGdvbGRlbnJvZHllbGxvdyc6JyNmYWZhZDInLFxuICAgICdsaWdodGdyYXknOicjZDNkM2QzJyxcbiAgICAnbGlnaHRncmV5JzonI2QzZDNkMycsXG4gICAgJ2xpZ2h0Z3JlZW4nOicjOTBlZTkwJyxcbiAgICAnbGlnaHRwaW5rJzonI2ZmYjZjMScsXG4gICAgJ2xpZ2h0c2FsbW9uJzonI2ZmYTA3YScsXG4gICAgJ2xpZ2h0c2VhZ3JlZW4nOicjMjBiMmFhJyxcbiAgICAnbGlnaHRza3libHVlJzonIzg3Y2VmYScsXG4gICAgJ2xpZ2h0c2xhdGVncmF5JzonIzc3ODg5OScsXG4gICAgJ2xpZ2h0c2xhdGVncmV5JzonIzc3ODg5OScsXG4gICAgJ2xpZ2h0c3RlZWxibHVlJzonI2IwYzRkZScsXG4gICAgJ2xpZ2h0eWVsbG93JzonI2ZmZmZlMCcsXG4gICAgJ2xpbWUnOicjMDBmZjAwJyxcbiAgICAnbGltZWdyZWVuJzonIzMyY2QzMicsXG4gICAgJ2xpbmVuJzonI2ZhZjBlNicsXG4gICAgJ21hZ2VudGEnOicjZmYwMGZmJyxcbiAgICAnbWFyb29uJzonIzgwMDAwMCcsXG4gICAgJ21lZGl1bWFxdWFtYXJpbmUnOicjNjZjZGFhJyxcbiAgICAnbWVkaXVtYmx1ZSc6JyMwMDAwY2QnLFxuICAgICdtZWRpdW1vcmNoaWQnOicjYmE1NWQzJyxcbiAgICAnbWVkaXVtcHVycGxlJzonIzkzNzBkOCcsXG4gICAgJ21lZGl1bXNlYWdyZWVuJzonIzNjYjM3MScsXG4gICAgJ21lZGl1bXNsYXRlYmx1ZSc6JyM3YjY4ZWUnLFxuICAgICdtZWRpdW1zcHJpbmdncmVlbic6JyMwMGZhOWEnLFxuICAgICdtZWRpdW10dXJxdW9pc2UnOicjNDhkMWNjJyxcbiAgICAnbWVkaXVtdmlvbGV0cmVkJzonI2M3MTU4NScsXG4gICAgJ21pZG5pZ2h0Ymx1ZSc6JyMxOTE5NzAnLFxuICAgICdtaW50Y3JlYW0nOicjZjVmZmZhJyxcbiAgICAnbWlzdHlyb3NlJzonI2ZmZTRlMScsXG4gICAgJ21vY2Nhc2luJzonI2ZmZTRiNScsXG4gICAgJ25hdmFqb3doaXRlJzonI2ZmZGVhZCcsXG4gICAgJ25hdnknOicjMDAwMDgwJyxcbiAgICAnb2xkbGFjZSc6JyNmZGY1ZTYnLFxuICAgICdvbGl2ZSc6JyM4MDgwMDAnLFxuICAgICdvbGl2ZWRyYWInOicjNmI4ZTIzJyxcbiAgICAnb3JhbmdlJzonI2ZmYTUwMCcsXG4gICAgJ29yYW5nZXJlZCc6JyNmZjQ1MDAnLFxuICAgICdvcmNoaWQnOicjZGE3MGQ2JyxcbiAgICAncGFsZWdvbGRlbnJvZCc6JyNlZWU4YWEnLFxuICAgICdwYWxlZ3JlZW4nOicjOThmYjk4JyxcbiAgICAncGFsZXR1cnF1b2lzZSc6JyNhZmVlZWUnLFxuICAgICdwYWxldmlvbGV0cmVkJzonI2Q4NzA5MycsXG4gICAgJ3BhcGF5YXdoaXAnOicjZmZlZmQ1JyxcbiAgICAncGVhY2hwdWZmJzonI2ZmZGFiOScsXG4gICAgJ3BlcnUnOicjY2Q4NTNmJyxcbiAgICAncGluayc6JyNmZmMwY2InLFxuICAgICdwbHVtJzonI2RkYTBkZCcsXG4gICAgJ3Bvd2RlcmJsdWUnOicjYjBlMGU2JyxcbiAgICAncHVycGxlJzonIzgwMDA4MCcsXG4gICAgJ3JlYmVjY2FwdXJwbGUnOicjNjYzMzk5JyxcbiAgICAncmVkJzonI2ZmMDAwMCcsXG4gICAgJ3Jvc3licm93bic6JyNiYzhmOGYnLFxuICAgICdyb3lhbGJsdWUnOicjNDE2OWUxJyxcbiAgICAnc2FkZGxlYnJvd24nOicjOGI0NTEzJyxcbiAgICAnc2FsbW9uJzonI2ZhODA3MicsXG4gICAgJ3NhbmR5YnJvd24nOicjZjRhNDYwJyxcbiAgICAnc2VhZ3JlZW4nOicjMmU4YjU3JyxcbiAgICAnc2Vhc2hlbGwnOicjZmZmNWVlJyxcbiAgICAnc2llbm5hJzonI2EwNTIyZCcsXG4gICAgJ3NpbHZlcic6JyNjMGMwYzAnLFxuICAgICdza3libHVlJzonIzg3Y2VlYicsXG4gICAgJ3NsYXRlYmx1ZSc6JyM2YTVhY2QnLFxuICAgICdzbGF0ZWdyYXknOicjNzA4MDkwJyxcbiAgICAnc2xhdGVncmV5JzonIzcwODA5MCcsXG4gICAgJ3Nub3cnOicjZmZmYWZhJyxcbiAgICAnc3ByaW5nZ3JlZW4nOicjMDBmZjdmJyxcbiAgICAnc3RlZWxibHVlJzonIzQ2ODJiNCcsXG4gICAgJ3Rhbic6JyNkMmI0OGMnLFxuICAgICd0ZWFsJzonIzAwODA4MCcsXG4gICAgJ3RoaXN0bGUnOicjZDhiZmQ4JyxcbiAgICAndG9tYXRvJzonI2ZmNjM0NycsXG4gICAgJ3R1cnF1b2lzZSc6JyM0MGUwZDAnLFxuICAgICd2aW9sZXQnOicjZWU4MmVlJyxcbiAgICAnd2hlYXQnOicjZjVkZWIzJyxcbiAgICAnd2hpdGUnOicjZmZmZmZmJyxcbiAgICAnd2hpdGVzbW9rZSc6JyNmNWY1ZjUnLFxuICAgICd5ZWxsb3cnOicjZmZmZjAwJyxcbiAgICAneWVsbG93Z3JlZW4nOicjOWFjZDMyJ1xufTtcbn0se31dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvbG9yczogcmVxdWlyZShcIi4vY29sb3JzXCIpLFxuICAgIHVuaXRDb252ZXJzaW9uczogcmVxdWlyZShcIi4vdW5pdC1jb252ZXJzaW9uc1wiKVxufTtcblxufSx7XCIuL2NvbG9yc1wiOjEyLFwiLi91bml0LWNvbnZlcnNpb25zXCI6MTR9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBsZW5ndGg6IHtcbiAgICAgICAgJ20nOiAxLFxuICAgICAgICAnY20nOiAwLjAxLFxuICAgICAgICAnbW0nOiAwLjAwMSxcbiAgICAgICAgJ2luJzogMC4wMjU0LFxuICAgICAgICAncHgnOiAwLjAyNTQgLyA5NixcbiAgICAgICAgJ3B0JzogMC4wMjU0IC8gNzIsXG4gICAgICAgICdwYyc6IDAuMDI1NCAvIDcyICogMTJcbiAgICB9LFxuICAgIGR1cmF0aW9uOiB7XG4gICAgICAgICdzJzogMSxcbiAgICAgICAgJ21zJzogMC4wMDFcbiAgICB9LFxuICAgIGFuZ2xlOiB7XG4gICAgICAgICdyYWQnOiAxIC8gKDIgKiBNYXRoLlBJKSxcbiAgICAgICAgJ2RlZyc6IDEgLyAzNjAsXG4gICAgICAgICdncmFkJzogMSAvIDQwMCxcbiAgICAgICAgJ3R1cm4nOiAxXG4gICAgfVxufTtcbn0se31dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBhYnN0cmFjdEZpbGVNYW5hZ2VyID0gZnVuY3Rpb24oKSB7XG59O1xuXG5hYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG4gICAgdmFyIGogPSBmaWxlbmFtZS5sYXN0SW5kZXhPZignPycpO1xuICAgIGlmIChqID4gMCkge1xuICAgICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnNsaWNlKDAsIGopO1xuICAgIH1cbiAgICBqID0gZmlsZW5hbWUubGFzdEluZGV4T2YoJy8nKTtcbiAgICBpZiAoaiA8IDApIHtcbiAgICAgICAgaiA9IGZpbGVuYW1lLmxhc3RJbmRleE9mKCdcXFxcJyk7XG4gICAgfVxuICAgIGlmIChqIDwgMCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGVuYW1lLnNsaWNlKDAsIGogKyAxKTtcbn07XG5cbmFic3RyYWN0RmlsZU1hbmFnZXIucHJvdG90eXBlLnRyeUFwcGVuZEV4dGVuc2lvbiA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICAgIHJldHVybiAvKFxcLlthLXpdKiQpfChbXFw/O10uKikkLy50ZXN0KHBhdGgpID8gcGF0aCA6IHBhdGggKyBleHQ7XG59O1xuXG5hYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS50cnlBcHBlbmRMZXNzRXh0ZW5zaW9uID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHJldHVybiB0aGlzLnRyeUFwcGVuZEV4dGVuc2lvbihwYXRoLCAnLmxlc3MnKTtcbn07XG5cbmFic3RyYWN0RmlsZU1hbmFnZXIucHJvdG90eXBlLnN1cHBvcnRzU3luYyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmFic3RyYWN0RmlsZU1hbmFnZXIucHJvdG90eXBlLmFsd2F5c01ha2VQYXRoc0Fic29sdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuYWJzdHJhY3RGaWxlTWFuYWdlci5wcm90b3R5cGUuaXNQYXRoQWJzb2x1dGUgPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICAgIHJldHVybiAoL14oPzpbYS16LV0rOnxcXC98XFxcXHwjKS9pKS50ZXN0KGZpbGVuYW1lKTtcbn07XG5cbmFic3RyYWN0RmlsZU1hbmFnZXIucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbihiYXNlUGF0aCwgbGF0ZXJQYXRoKSB7XG4gICAgaWYgKCFiYXNlUGF0aCkge1xuICAgICAgICByZXR1cm4gbGF0ZXJQYXRoO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZVBhdGggKyBsYXRlclBhdGg7XG59O1xuYWJzdHJhY3RGaWxlTWFuYWdlci5wcm90b3R5cGUucGF0aERpZmYgPSBmdW5jdGlvbiBwYXRoRGlmZih1cmwsIGJhc2VVcmwpIHtcbiAgICAvLyBkaWZmIGJldHdlZW4gdHdvIHBhdGhzIHRvIGNyZWF0ZSBhIHJlbGF0aXZlIHBhdGhcblxuICAgIHZhciB1cmxQYXJ0cyA9IHRoaXMuZXh0cmFjdFVybFBhcnRzKHVybCksXG4gICAgICAgIGJhc2VVcmxQYXJ0cyA9IHRoaXMuZXh0cmFjdFVybFBhcnRzKGJhc2VVcmwpLFxuICAgICAgICBpLCBtYXgsIHVybERpcmVjdG9yaWVzLCBiYXNlVXJsRGlyZWN0b3JpZXMsIGRpZmYgPSBcIlwiO1xuICAgIGlmICh1cmxQYXJ0cy5ob3N0UGFydCAhPT0gYmFzZVVybFBhcnRzLmhvc3RQYXJ0KSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBtYXggPSBNYXRoLm1heChiYXNlVXJsUGFydHMuZGlyZWN0b3JpZXMubGVuZ3RoLCB1cmxQYXJ0cy5kaXJlY3Rvcmllcy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICBpZiAoYmFzZVVybFBhcnRzLmRpcmVjdG9yaWVzW2ldICE9PSB1cmxQYXJ0cy5kaXJlY3Rvcmllc1tpXSkgeyBicmVhazsgfVxuICAgIH1cbiAgICBiYXNlVXJsRGlyZWN0b3JpZXMgPSBiYXNlVXJsUGFydHMuZGlyZWN0b3JpZXMuc2xpY2UoaSk7XG4gICAgdXJsRGlyZWN0b3JpZXMgPSB1cmxQYXJ0cy5kaXJlY3Rvcmllcy5zbGljZShpKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYmFzZVVybERpcmVjdG9yaWVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBkaWZmICs9IFwiLi4vXCI7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB1cmxEaXJlY3Rvcmllcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgZGlmZiArPSB1cmxEaXJlY3Rvcmllc1tpXSArIFwiL1wiO1xuICAgIH1cbiAgICByZXR1cm4gZGlmZjtcbn07XG4vLyBoZWxwZXIgZnVuY3Rpb24sIG5vdCBwYXJ0IG9mIEFQSVxuYWJzdHJhY3RGaWxlTWFuYWdlci5wcm90b3R5cGUuZXh0cmFjdFVybFBhcnRzID0gZnVuY3Rpb24gZXh0cmFjdFVybFBhcnRzKHVybCwgYmFzZVVybCkge1xuICAgIC8vIHVybFBhcnRzWzFdID0gcHJvdG9jb2w6Ly9ob3N0bmFtZS8gT1IgL1xuICAgIC8vIHVybFBhcnRzWzJdID0gLyBpZiBwYXRoIHJlbGF0aXZlIHRvIGhvc3QgYmFzZVxuICAgIC8vIHVybFBhcnRzWzNdID0gZGlyZWN0b3JpZXNcbiAgICAvLyB1cmxQYXJ0c1s0XSA9IGZpbGVuYW1lXG4gICAgLy8gdXJsUGFydHNbNV0gPSBwYXJhbWV0ZXJzXG5cbiAgICB2YXIgdXJsUGFydHNSZWdleCA9IC9eKCg/OlthLXotXSs6KT9cXC97Mn0oPzpbXlxcL1xcPyNdKlxcLyl8KFtcXC9cXFxcXSkpPygoPzpbXlxcL1xcXFxcXD8jXSpbXFwvXFxcXF0pKikoW15cXC9cXFxcXFw/I10qKShbI1xcP10uKik/JC9pLFxuICAgICAgICB1cmxQYXJ0cyA9IHVybC5tYXRjaCh1cmxQYXJ0c1JlZ2V4KSxcbiAgICAgICAgcmV0dXJuZXIgPSB7fSwgZGlyZWN0b3JpZXMgPSBbXSwgaSwgYmFzZVVybFBhcnRzO1xuXG4gICAgaWYgKCF1cmxQYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2Ugc2hlZXQgaHJlZiAtICdcIiArIHVybCArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICAvLyBTdHlsZXNoZWV0cyBpbiBJRSBkb24ndCBhbHdheXMgcmV0dXJuIHRoZSBmdWxsIHBhdGhcbiAgICBpZiAoYmFzZVVybCAmJiAoIXVybFBhcnRzWzFdIHx8IHVybFBhcnRzWzJdKSkge1xuICAgICAgICBiYXNlVXJsUGFydHMgPSBiYXNlVXJsLm1hdGNoKHVybFBhcnRzUmVnZXgpO1xuICAgICAgICBpZiAoIWJhc2VVcmxQYXJ0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlIHBhZ2UgdXJsIC0gJ1wiICsgYmFzZVVybCArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB1cmxQYXJ0c1sxXSA9IHVybFBhcnRzWzFdIHx8IGJhc2VVcmxQYXJ0c1sxXSB8fCBcIlwiO1xuICAgICAgICBpZiAoIXVybFBhcnRzWzJdKSB7XG4gICAgICAgICAgICB1cmxQYXJ0c1szXSA9IGJhc2VVcmxQYXJ0c1szXSArIHVybFBhcnRzWzNdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVybFBhcnRzWzNdKSB7XG4gICAgICAgIGRpcmVjdG9yaWVzID0gdXJsUGFydHNbM10ucmVwbGFjZSgvXFxcXC9nLCBcIi9cIikuc3BsaXQoXCIvXCIpO1xuXG4gICAgICAgIC8vIGV4dHJhY3Qgb3V0IC4gYmVmb3JlIC4uIHNvIC4uIGRvZXNuJ3QgYWJzb3JiIGEgbm9uLWRpcmVjdG9yeVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGlyZWN0b3JpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rvcmllc1tpXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rvcmllcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRpcmVjdG9yaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0b3JpZXNbaV0gPT09IFwiLi5cIiAmJiBpID4gMCkge1xuICAgICAgICAgICAgICAgIGRpcmVjdG9yaWVzLnNwbGljZShpIC0gMSwgMik7XG4gICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuZXIuaG9zdFBhcnQgPSB1cmxQYXJ0c1sxXTtcbiAgICByZXR1cm5lci5kaXJlY3RvcmllcyA9IGRpcmVjdG9yaWVzO1xuICAgIHJldHVybmVyLnBhdGggPSAodXJsUGFydHNbMV0gfHwgXCJcIikgKyBkaXJlY3Rvcmllcy5qb2luKFwiL1wiKTtcbiAgICByZXR1cm5lci5maWxlVXJsID0gcmV0dXJuZXIucGF0aCArICh1cmxQYXJ0c1s0XSB8fCBcIlwiKTtcbiAgICByZXR1cm5lci51cmwgPSByZXR1cm5lci5maWxlVXJsICsgKHVybFBhcnRzWzVdIHx8IFwiXCIpO1xuICAgIHJldHVybiByZXR1cm5lcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYWJzdHJhY3RGaWxlTWFuYWdlcjtcblxufSx7fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGxvZ2dlciA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XG52YXIgZW52aXJvbm1lbnQgPSBmdW5jdGlvbihleHRlcm5hbEVudmlyb25tZW50LCBmaWxlTWFuYWdlcnMpIHtcbiAgICB0aGlzLmZpbGVNYW5hZ2VycyA9IGZpbGVNYW5hZ2VycyB8fCBbXTtcbiAgICBleHRlcm5hbEVudmlyb25tZW50ID0gZXh0ZXJuYWxFbnZpcm9ubWVudCB8fCB7fTtcblxuICAgIHZhciBvcHRpb25hbEZ1bmN0aW9ucyA9IFtcImVuY29kZUJhc2U2NFwiLCBcIm1pbWVMb29rdXBcIiwgXCJjaGFyc2V0TG9va3VwXCIsIFwiZ2V0U291cmNlTWFwR2VuZXJhdG9yXCJdLFxuICAgICAgICByZXF1aXJlZEZ1bmN0aW9ucyA9IFtdLFxuICAgICAgICBmdW5jdGlvbnMgPSByZXF1aXJlZEZ1bmN0aW9ucy5jb25jYXQob3B0aW9uYWxGdW5jdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gZnVuY3Rpb25zW2ldLFxuICAgICAgICAgICAgZW52aXJvbm1lbnRGdW5jID0gZXh0ZXJuYWxFbnZpcm9ubWVudFtwcm9wTmFtZV07XG4gICAgICAgIGlmIChlbnZpcm9ubWVudEZ1bmMpIHtcbiAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID0gZW52aXJvbm1lbnRGdW5jLmJpbmQoZXh0ZXJuYWxFbnZpcm9ubWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA8IHJlcXVpcmVkRnVuY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy53YXJuKFwibWlzc2luZyByZXF1aXJlZCBmdW5jdGlvbiBpbiBlbnZpcm9ubWVudCAtIFwiICsgcHJvcE5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZW52aXJvbm1lbnQucHJvdG90eXBlLmdldEZpbGVNYW5hZ2VyID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBjdXJyZW50RGlyZWN0b3J5LCBvcHRpb25zLCBlbnZpcm9ubWVudCwgaXNTeW5jKSB7XG5cbiAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiZ2V0RmlsZU1hbmFnZXIgY2FsbGVkIHdpdGggbm8gZmlsZW5hbWUuLiBQbGVhc2UgcmVwb3J0IHRoaXMgaXNzdWUuIGNvbnRpbnVpbmcuXCIpO1xuICAgIH1cbiAgICBpZiAoY3VycmVudERpcmVjdG9yeSA9PSBudWxsKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiZ2V0RmlsZU1hbmFnZXIgY2FsbGVkIHdpdGggbnVsbCBkaXJlY3RvcnkuLiBQbGVhc2UgcmVwb3J0IHRoaXMgaXNzdWUuIGNvbnRpbnVpbmcuXCIpO1xuICAgIH1cblxuICAgIHZhciBmaWxlTWFuYWdlcnMgPSB0aGlzLmZpbGVNYW5hZ2VycztcbiAgICBpZiAob3B0aW9ucy5wbHVnaW5NYW5hZ2VyKSB7XG4gICAgICAgIGZpbGVNYW5hZ2VycyA9IFtdLmNvbmNhdChmaWxlTWFuYWdlcnMpLmNvbmNhdChvcHRpb25zLnBsdWdpbk1hbmFnZXIuZ2V0RmlsZU1hbmFnZXJzKCkpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gZmlsZU1hbmFnZXJzLmxlbmd0aCAtIDE7IGkgPj0gMCA7IGktLSkge1xuICAgICAgICB2YXIgZmlsZU1hbmFnZXIgPSBmaWxlTWFuYWdlcnNbaV07XG4gICAgICAgIGlmIChmaWxlTWFuYWdlcltpc1N5bmMgPyBcInN1cHBvcnRzU3luY1wiIDogXCJzdXBwb3J0c1wiXShmaWxlbmFtZSwgY3VycmVudERpcmVjdG9yeSwgb3B0aW9ucywgZW52aXJvbm1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZU1hbmFnZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5lbnZpcm9ubWVudC5wcm90b3R5cGUuYWRkRmlsZU1hbmFnZXIgPSBmdW5jdGlvbiAoZmlsZU1hbmFnZXIpIHtcbiAgICB0aGlzLmZpbGVNYW5hZ2Vycy5wdXNoKGZpbGVNYW5hZ2VyKTtcbn07XG5cbmVudmlyb25tZW50LnByb3RvdHlwZS5jbGVhckZpbGVNYW5hZ2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbGVNYW5hZ2VycyA9IFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnZpcm9ubWVudDtcblxufSx7XCIuLi9sb2dnZXJcIjozM31dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDb2xvciA9IHJlcXVpcmUoXCIuLi90cmVlL2NvbG9yXCIpLFxuICAgIGZ1bmN0aW9uUmVnaXN0cnkgPSByZXF1aXJlKFwiLi9mdW5jdGlvbi1yZWdpc3RyeVwiKTtcblxuLy8gQ29sb3IgQmxlbmRpbmdcbi8vIHJlZjogaHR0cDovL3d3dy53My5vcmcvVFIvY29tcG9zaXRpbmctMVxuXG5mdW5jdGlvbiBjb2xvckJsZW5kKG1vZGUsIGNvbG9yMSwgY29sb3IyKSB7XG4gICAgdmFyIGFiID0gY29sb3IxLmFscGhhLCBjYiwgLy8gYmFja2Ryb3BcbiAgICAgICAgYXMgPSBjb2xvcjIuYWxwaGEsIGNzLCAvLyBzb3VyY2VcbiAgICAgICAgYXIsIGNyLCByID0gW107ICAgICAgICAvLyByZXN1bHRcblxuICAgIGFyID0gYXMgKyBhYiAqICgxIC0gYXMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGNiID0gY29sb3IxLnJnYltpXSAvIDI1NTtcbiAgICAgICAgY3MgPSBjb2xvcjIucmdiW2ldIC8gMjU1O1xuICAgICAgICBjciA9IG1vZGUoY2IsIGNzKTtcbiAgICAgICAgaWYgKGFyKSB7XG4gICAgICAgICAgICBjciA9IChhcyAqIGNzICsgYWIgKiAoY2IgLVxuICAgICAgICAgICAgICAgICAgYXMgKiAoY2IgKyBjcyAtIGNyKSkpIC8gYXI7XG4gICAgICAgIH1cbiAgICAgICAgcltpXSA9IGNyICogMjU1O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29sb3IociwgYXIpO1xufVxuXG52YXIgY29sb3JCbGVuZE1vZGVGdW5jdGlvbnMgPSB7XG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uKGNiLCBjcykge1xuICAgICAgICByZXR1cm4gY2IgKiBjcztcbiAgICB9LFxuICAgIHNjcmVlbjogZnVuY3Rpb24oY2IsIGNzKSB7XG4gICAgICAgIHJldHVybiBjYiArIGNzIC0gY2IgKiBjcztcbiAgICB9LFxuICAgIG92ZXJsYXk6IGZ1bmN0aW9uKGNiLCBjcykge1xuICAgICAgICBjYiAqPSAyO1xuICAgICAgICByZXR1cm4gKGNiIDw9IDEpID9cbiAgICAgICAgICAgIGNvbG9yQmxlbmRNb2RlRnVuY3Rpb25zLm11bHRpcGx5KGNiLCBjcykgOlxuICAgICAgICAgICAgY29sb3JCbGVuZE1vZGVGdW5jdGlvbnMuc2NyZWVuKGNiIC0gMSwgY3MpO1xuICAgIH0sXG4gICAgc29mdGxpZ2h0OiBmdW5jdGlvbihjYiwgY3MpIHtcbiAgICAgICAgdmFyIGQgPSAxLCBlID0gY2I7XG4gICAgICAgIGlmIChjcyA+IDAuNSkge1xuICAgICAgICAgICAgZSA9IDE7XG4gICAgICAgICAgICBkID0gKGNiID4gMC4yNSkgPyBNYXRoLnNxcnQoY2IpXG4gICAgICAgICAgICAgICAgOiAoKDE2ICogY2IgLSAxMikgKiBjYiArIDQpICogY2I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNiIC0gKDEgLSAyICogY3MpICogZSAqIChkIC0gY2IpO1xuICAgIH0sXG4gICAgaGFyZGxpZ2h0OiBmdW5jdGlvbihjYiwgY3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yQmxlbmRNb2RlRnVuY3Rpb25zLm92ZXJsYXkoY3MsIGNiKTtcbiAgICB9LFxuICAgIGRpZmZlcmVuY2U6IGZ1bmN0aW9uKGNiLCBjcykge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoY2IgLSBjcyk7XG4gICAgfSxcbiAgICBleGNsdXNpb246IGZ1bmN0aW9uKGNiLCBjcykge1xuICAgICAgICByZXR1cm4gY2IgKyBjcyAtIDIgKiBjYiAqIGNzO1xuICAgIH0sXG5cbiAgICAvLyBub24tdzNjIGZ1bmN0aW9uczpcbiAgICBhdmVyYWdlOiBmdW5jdGlvbihjYiwgY3MpIHtcbiAgICAgICAgcmV0dXJuIChjYiArIGNzKSAvIDI7XG4gICAgfSxcbiAgICBuZWdhdGlvbjogZnVuY3Rpb24oY2IsIGNzKSB7XG4gICAgICAgIHJldHVybiAxIC0gTWF0aC5hYnMoY2IgKyBjcyAtIDEpO1xuICAgIH1cbn07XG5cbmZvciAodmFyIGYgaW4gY29sb3JCbGVuZE1vZGVGdW5jdGlvbnMpIHtcbiAgICBpZiAoY29sb3JCbGVuZE1vZGVGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkoZikpIHtcbiAgICAgICAgY29sb3JCbGVuZFtmXSA9IGNvbG9yQmxlbmQuYmluZChudWxsLCBjb2xvckJsZW5kTW9kZUZ1bmN0aW9uc1tmXSk7XG4gICAgfVxufVxuXG5mdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKGNvbG9yQmxlbmQpO1xuXG59LHtcIi4uL3RyZWUvY29sb3JcIjo1MCxcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIjoyMn1dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBEaW1lbnNpb24gPSByZXF1aXJlKFwiLi4vdHJlZS9kaW1lbnNpb25cIiksXG4gICAgQ29sb3IgPSByZXF1aXJlKFwiLi4vdHJlZS9jb2xvclwiKSxcbiAgICBRdW90ZWQgPSByZXF1aXJlKFwiLi4vdHJlZS9xdW90ZWRcIiksXG4gICAgQW5vbnltb3VzID0gcmVxdWlyZShcIi4uL3RyZWUvYW5vbnltb3VzXCIpLFxuICAgIGZ1bmN0aW9uUmVnaXN0cnkgPSByZXF1aXJlKFwiLi9mdW5jdGlvbi1yZWdpc3RyeVwiKSxcbiAgICBjb2xvckZ1bmN0aW9ucztcblxuZnVuY3Rpb24gY2xhbXAodmFsKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKDEsIE1hdGgubWF4KDAsIHZhbCkpO1xufVxuZnVuY3Rpb24gaHNsYShjb2xvcikge1xuICAgIHJldHVybiBjb2xvckZ1bmN0aW9ucy5oc2xhKGNvbG9yLmgsIGNvbG9yLnMsIGNvbG9yLmwsIGNvbG9yLmEpO1xufVxuZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAobiBpbnN0YW5jZW9mIERpbWVuc2lvbikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChuLnVuaXQuaXMoJyUnKSA/IG4udmFsdWUgLyAxMDAgOiBuLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBuID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICB0eXBlOiBcIkFyZ3VtZW50XCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcImNvbG9yIGZ1bmN0aW9ucyB0YWtlIG51bWJlcnMgYXMgcGFyYW1ldGVyc1wiXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gc2NhbGVkKG4sIHNpemUpIHtcbiAgICBpZiAobiBpbnN0YW5jZW9mIERpbWVuc2lvbiAmJiBuLnVuaXQuaXMoJyUnKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChuLnZhbHVlICogc2l6ZSAvIDEwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bWJlcihuKTtcbiAgICB9XG59XG5jb2xvckZ1bmN0aW9ucyA9IHtcbiAgICByZ2I6IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgICAgIHJldHVybiBjb2xvckZ1bmN0aW9ucy5yZ2JhKHIsIGcsIGIsIDEuMCk7XG4gICAgfSxcbiAgICByZ2JhOiBmdW5jdGlvbiAociwgZywgYiwgYSkge1xuICAgICAgICB2YXIgcmdiID0gW3IsIGcsIGJdLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gc2NhbGVkKGMsIDI1NSk7IH0pO1xuICAgICAgICBhID0gbnVtYmVyKGEpO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yKHJnYiwgYSk7XG4gICAgfSxcbiAgICBoc2w6IGZ1bmN0aW9uIChoLCBzLCBsKSB7XG4gICAgICAgIHJldHVybiBjb2xvckZ1bmN0aW9ucy5oc2xhKGgsIHMsIGwsIDEuMCk7XG4gICAgfSxcbiAgICBoc2xhOiBmdW5jdGlvbiAoaCwgcywgbCwgYSkge1xuXG4gICAgICAgIHZhciBtMSwgbTI7XG5cbiAgICAgICAgZnVuY3Rpb24gaHVlKGgpIHtcbiAgICAgICAgICAgIGggPSBoIDwgMCA/IGggKyAxIDogKGggPiAxID8gaCAtIDEgOiBoKTtcbiAgICAgICAgICAgIGlmIChoICogNiA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGggKiAyIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGggKiAzIDwgMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyIC8gMyAtIGgpICogNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGggPSAobnVtYmVyKGgpICUgMzYwKSAvIDM2MDtcbiAgICAgICAgcyA9IGNsYW1wKG51bWJlcihzKSk7IGwgPSBjbGFtcChudW1iZXIobCkpOyBhID0gY2xhbXAobnVtYmVyKGEpKTtcblxuICAgICAgICBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICBtMSA9IGwgKiAyIC0gbTI7XG5cbiAgICAgICAgcmV0dXJuIGNvbG9yRnVuY3Rpb25zLnJnYmEoaHVlKGggKyAxIC8gMykgKiAyNTUsXG4gICAgICAgICAgICBodWUoaCkgICAgICAgKiAyNTUsXG4gICAgICAgICAgICBodWUoaCAtIDEgLyAzKSAqIDI1NSxcbiAgICAgICAgICAgIGEpO1xuICAgIH0sXG5cbiAgICBoc3Y6IGZ1bmN0aW9uKGgsIHMsIHYpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yRnVuY3Rpb25zLmhzdmEoaCwgcywgdiwgMS4wKTtcbiAgICB9LFxuXG4gICAgaHN2YTogZnVuY3Rpb24oaCwgcywgdiwgYSkge1xuICAgICAgICBoID0gKChudW1iZXIoaCkgJSAzNjApIC8gMzYwKSAqIDM2MDtcbiAgICAgICAgcyA9IG51bWJlcihzKTsgdiA9IG51bWJlcih2KTsgYSA9IG51bWJlcihhKTtcblxuICAgICAgICB2YXIgaSwgZjtcbiAgICAgICAgaSA9IE1hdGguZmxvb3IoKGggLyA2MCkgJSA2KTtcbiAgICAgICAgZiA9IChoIC8gNjApIC0gaTtcblxuICAgICAgICB2YXIgdnMgPSBbdixcbiAgICAgICAgICAgIHYgKiAoMSAtIHMpLFxuICAgICAgICAgICAgdiAqICgxIC0gZiAqIHMpLFxuICAgICAgICAgICAgdiAqICgxIC0gKDEgLSBmKSAqIHMpXTtcbiAgICAgICAgdmFyIHBlcm0gPSBbWzAsIDMsIDFdLFxuICAgICAgICAgICAgWzIsIDAsIDFdLFxuICAgICAgICAgICAgWzEsIDAsIDNdLFxuICAgICAgICAgICAgWzEsIDIsIDBdLFxuICAgICAgICAgICAgWzMsIDEsIDBdLFxuICAgICAgICAgICAgWzAsIDEsIDJdXTtcblxuICAgICAgICByZXR1cm4gY29sb3JGdW5jdGlvbnMucmdiYSh2c1twZXJtW2ldWzBdXSAqIDI1NSxcbiAgICAgICAgICAgIHZzW3Blcm1baV1bMV1dICogMjU1LFxuICAgICAgICAgICAgdnNbcGVybVtpXVsyXV0gKiAyNTUsXG4gICAgICAgICAgICBhKTtcbiAgICB9LFxuXG4gICAgaHVlOiBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oY29sb3IudG9IU0woKS5oKTtcbiAgICB9LFxuICAgIHNhdHVyYXRpb246IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihjb2xvci50b0hTTCgpLnMgKiAxMDAsICclJyk7XG4gICAgfSxcbiAgICBsaWdodG5lc3M6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihjb2xvci50b0hTTCgpLmwgKiAxMDAsICclJyk7XG4gICAgfSxcbiAgICBoc3ZodWU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLnRvSFNWKCkuaCk7XG4gICAgfSxcbiAgICBoc3ZzYXR1cmF0aW9uOiBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oY29sb3IudG9IU1YoKS5zICogMTAwLCAnJScpO1xuICAgIH0sXG4gICAgaHN2dmFsdWU6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihjb2xvci50b0hTVigpLnYgKiAxMDAsICclJyk7XG4gICAgfSxcbiAgICByZWQ6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihjb2xvci5yZ2JbMF0pO1xuICAgIH0sXG4gICAgZ3JlZW46IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihjb2xvci5yZ2JbMV0pO1xuICAgIH0sXG4gICAgYmx1ZTogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLnJnYlsyXSk7XG4gICAgfSxcbiAgICBhbHBoYTogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLnRvSFNMKCkuYSk7XG4gICAgfSxcbiAgICBsdW1hOiBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oY29sb3IubHVtYSgpICogY29sb3IuYWxwaGEgKiAxMDAsICclJyk7XG4gICAgfSxcbiAgICBsdW1pbmFuY2U6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICB2YXIgbHVtaW5hbmNlID1cbiAgICAgICAgICAgICgwLjIxMjYgKiBjb2xvci5yZ2JbMF0gLyAyNTUpICtcbiAgICAgICAgICAgICAgICAoMC43MTUyICogY29sb3IucmdiWzFdIC8gMjU1KSArXG4gICAgICAgICAgICAgICAgKDAuMDcyMiAqIGNvbG9yLnJnYlsyXSAvIDI1NSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24obHVtaW5hbmNlICogY29sb3IuYWxwaGEgKiAxMDAsICclJyk7XG4gICAgfSxcbiAgICBzYXR1cmF0ZTogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQsIG1ldGhvZCkge1xuICAgICAgICAvLyBmaWx0ZXI6IHNhdHVyYXRlKDMuMik7XG4gICAgICAgIC8vIHNob3VsZCBiZSBrZXB0IGFzIGlzLCBzbyBjaGVjayBmb3IgY29sb3JcbiAgICAgICAgaWYgKCFjb2xvci5yZ2IpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoc2wgPSBjb2xvci50b0hTTCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSBcInVuZGVmaW5lZFwiICYmIG1ldGhvZC52YWx1ZSA9PT0gXCJyZWxhdGl2ZVwiKSB7XG4gICAgICAgICAgICBoc2wucyArPSAgaHNsLnMgKiBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoc2wucyArPSBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgaHNsLnMgPSBjbGFtcChoc2wucyk7XG4gICAgICAgIHJldHVybiBoc2xhKGhzbCk7XG4gICAgfSxcbiAgICBkZXNhdHVyYXRlOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCwgbWV0aG9kKSB7XG4gICAgICAgIHZhciBoc2wgPSBjb2xvci50b0hTTCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSBcInVuZGVmaW5lZFwiICYmIG1ldGhvZC52YWx1ZSA9PT0gXCJyZWxhdGl2ZVwiKSB7XG4gICAgICAgICAgICBoc2wucyAtPSAgaHNsLnMgKiBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoc2wucyAtPSBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgaHNsLnMgPSBjbGFtcChoc2wucyk7XG4gICAgICAgIHJldHVybiBoc2xhKGhzbCk7XG4gICAgfSxcbiAgICBsaWdodGVuOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCwgbWV0aG9kKSB7XG4gICAgICAgIHZhciBoc2wgPSBjb2xvci50b0hTTCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSBcInVuZGVmaW5lZFwiICYmIG1ldGhvZC52YWx1ZSA9PT0gXCJyZWxhdGl2ZVwiKSB7XG4gICAgICAgICAgICBoc2wubCArPSAgaHNsLmwgKiBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoc2wubCArPSBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgaHNsLmwgPSBjbGFtcChoc2wubCk7XG4gICAgICAgIHJldHVybiBoc2xhKGhzbCk7XG4gICAgfSxcbiAgICBkYXJrZW46IGZ1bmN0aW9uIChjb2xvciwgYW1vdW50LCBtZXRob2QpIHtcbiAgICAgICAgdmFyIGhzbCA9IGNvbG9yLnRvSFNMKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09IFwidW5kZWZpbmVkXCIgJiYgbWV0aG9kLnZhbHVlID09PSBcInJlbGF0aXZlXCIpIHtcbiAgICAgICAgICAgIGhzbC5sIC09ICBoc2wubCAqIGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhzbC5sIC09IGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBoc2wubCA9IGNsYW1wKGhzbC5sKTtcbiAgICAgICAgcmV0dXJuIGhzbGEoaHNsKTtcbiAgICB9LFxuICAgIGZhZGVpbjogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQsIG1ldGhvZCkge1xuICAgICAgICB2YXIgaHNsID0gY29sb3IudG9IU0woKTtcblxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtZXRob2QudmFsdWUgPT09IFwicmVsYXRpdmVcIikge1xuICAgICAgICAgICAgaHNsLmEgKz0gIGhzbC5hICogYW1vdW50LnZhbHVlIC8gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaHNsLmEgKz0gYW1vdW50LnZhbHVlIC8gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGhzbC5hID0gY2xhbXAoaHNsLmEpO1xuICAgICAgICByZXR1cm4gaHNsYShoc2wpO1xuICAgIH0sXG4gICAgZmFkZW91dDogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQsIG1ldGhvZCkge1xuICAgICAgICB2YXIgaHNsID0gY29sb3IudG9IU0woKTtcblxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtZXRob2QudmFsdWUgPT09IFwicmVsYXRpdmVcIikge1xuICAgICAgICAgICAgaHNsLmEgLT0gIGhzbC5hICogYW1vdW50LnZhbHVlIC8gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaHNsLmEgLT0gYW1vdW50LnZhbHVlIC8gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGhzbC5hID0gY2xhbXAoaHNsLmEpO1xuICAgICAgICByZXR1cm4gaHNsYShoc2wpO1xuICAgIH0sXG4gICAgZmFkZTogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQpIHtcbiAgICAgICAgdmFyIGhzbCA9IGNvbG9yLnRvSFNMKCk7XG5cbiAgICAgICAgaHNsLmEgPSBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIGhzbC5hID0gY2xhbXAoaHNsLmEpO1xuICAgICAgICByZXR1cm4gaHNsYShoc2wpO1xuICAgIH0sXG4gICAgc3BpbjogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQpIHtcbiAgICAgICAgdmFyIGhzbCA9IGNvbG9yLnRvSFNMKCk7XG4gICAgICAgIHZhciBodWUgPSAoaHNsLmggKyBhbW91bnQudmFsdWUpICUgMzYwO1xuXG4gICAgICAgIGhzbC5oID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcblxuICAgICAgICByZXR1cm4gaHNsYShoc2wpO1xuICAgIH0sXG4gICAgLy9cbiAgICAvLyBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBIYW1wdG9uIENhdGxpbiwgTmF0YWxpZSBXZWl6ZW5iYXVtLCBhbmQgQ2hyaXMgRXBwc3RlaW5cbiAgICAvLyBodHRwOi8vc2Fzcy1sYW5nLmNvbVxuICAgIC8vXG4gICAgbWl4OiBmdW5jdGlvbiAoY29sb3IxLCBjb2xvcjIsIHdlaWdodCkge1xuICAgICAgICBpZiAoIWNvbG9yMS50b0hTTCB8fCAhY29sb3IyLnRvSFNMKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhjb2xvcjIudHlwZSk7XG4gICAgICAgICAgICBjb25zb2xlLmRpcihjb2xvcjIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd2VpZ2h0KSB7XG4gICAgICAgICAgICB3ZWlnaHQgPSBuZXcgRGltZW5zaW9uKDUwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IHdlaWdodC52YWx1ZSAvIDEwMC4wO1xuICAgICAgICB2YXIgdyA9IHAgKiAyIC0gMTtcbiAgICAgICAgdmFyIGEgPSBjb2xvcjEudG9IU0woKS5hIC0gY29sb3IyLnRvSFNMKCkuYTtcblxuICAgICAgICB2YXIgdzEgPSAoKCh3ICogYSA9PSAtMSkgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMi4wO1xuICAgICAgICB2YXIgdzIgPSAxIC0gdzE7XG5cbiAgICAgICAgdmFyIHJnYiA9IFtjb2xvcjEucmdiWzBdICogdzEgKyBjb2xvcjIucmdiWzBdICogdzIsXG4gICAgICAgICAgICBjb2xvcjEucmdiWzFdICogdzEgKyBjb2xvcjIucmdiWzFdICogdzIsXG4gICAgICAgICAgICBjb2xvcjEucmdiWzJdICogdzEgKyBjb2xvcjIucmdiWzJdICogdzJdO1xuXG4gICAgICAgIHZhciBhbHBoYSA9IGNvbG9yMS5hbHBoYSAqIHAgKyBjb2xvcjIuYWxwaGEgKiAoMSAtIHApO1xuXG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IocmdiLCBhbHBoYSk7XG4gICAgfSxcbiAgICBncmV5c2NhbGU6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gY29sb3JGdW5jdGlvbnMuZGVzYXR1cmF0ZShjb2xvciwgbmV3IERpbWVuc2lvbigxMDApKTtcbiAgICB9LFxuICAgIGNvbnRyYXN0OiBmdW5jdGlvbiAoY29sb3IsIGRhcmssIGxpZ2h0LCB0aHJlc2hvbGQpIHtcbiAgICAgICAgLy8gZmlsdGVyOiBjb250cmFzdCgzLjIpO1xuICAgICAgICAvLyBzaG91bGQgYmUga2VwdCBhcyBpcywgc28gY2hlY2sgZm9yIGNvbG9yXG4gICAgICAgIGlmICghY29sb3IucmdiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxpZ2h0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbGlnaHQgPSBjb2xvckZ1bmN0aW9ucy5yZ2JhKDI1NSwgMjU1LCAyNTUsIDEuMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXJrID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZGFyayA9IGNvbG9yRnVuY3Rpb25zLnJnYmEoMCwgMCwgMCwgMS4wKTtcbiAgICAgICAgfVxuICAgICAgICAvL0ZpZ3VyZSBvdXQgd2hpY2ggaXMgYWN0dWFsbHkgbGlnaHQgYW5kIGRhcmshXG4gICAgICAgIGlmIChkYXJrLmx1bWEoKSA+IGxpZ2h0Lmx1bWEoKSkge1xuICAgICAgICAgICAgdmFyIHQgPSBsaWdodDtcbiAgICAgICAgICAgIGxpZ2h0ID0gZGFyaztcbiAgICAgICAgICAgIGRhcmsgPSB0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhyZXNob2xkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gMC40MztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IG51bWJlcih0aHJlc2hvbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xvci5sdW1hKCkgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBsaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXJrO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhcmdiOiBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXMoY29sb3IudG9BUkdCKCkpO1xuICAgIH0sXG4gICAgY29sb3I6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgaWYgKChjIGluc3RhbmNlb2YgUXVvdGVkKSAmJlxuICAgICAgICAgICAgKC9eIyhbYS1mMC05XXs2fXxbYS1mMC05XXszfSkkL2kudGVzdChjLnZhbHVlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IoYy52YWx1ZS5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjIGluc3RhbmNlb2YgQ29sb3IpIHx8IChjID0gQ29sb3IuZnJvbUtleXdvcmQoYy52YWx1ZSkpKSB7XG4gICAgICAgICAgICBjLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgdHlwZTogICAgXCJBcmd1bWVudFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogXCJhcmd1bWVudCBtdXN0IGJlIGEgY29sb3Iga2V5d29yZCBvciAzLzYgZGlnaXQgaGV4IGUuZy4gI0ZGRlwiXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0aW50OiBmdW5jdGlvbihjb2xvciwgYW1vdW50KSB7XG4gICAgICAgIHJldHVybiBjb2xvckZ1bmN0aW9ucy5taXgoY29sb3JGdW5jdGlvbnMucmdiKDI1NSwgMjU1LCAyNTUpLCBjb2xvciwgYW1vdW50KTtcbiAgICB9LFxuICAgIHNoYWRlOiBmdW5jdGlvbihjb2xvciwgYW1vdW50KSB7XG4gICAgICAgIHJldHVybiBjb2xvckZ1bmN0aW9ucy5taXgoY29sb3JGdW5jdGlvbnMucmdiKDAsIDAsIDApLCBjb2xvciwgYW1vdW50KTtcbiAgICB9XG59O1xuZnVuY3Rpb25SZWdpc3RyeS5hZGRNdWx0aXBsZShjb2xvckZ1bmN0aW9ucyk7XG5cbn0se1wiLi4vdHJlZS9hbm9ueW1vdXNcIjo0NixcIi4uL3RyZWUvY29sb3JcIjo1MCxcIi4uL3RyZWUvZGltZW5zaW9uXCI6NTYsXCIuLi90cmVlL3F1b3RlZFwiOjczLFwiLi9mdW5jdGlvbi1yZWdpc3RyeVwiOjIyfV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbnZpcm9ubWVudCkge1xuICAgIHZhciBRdW90ZWQgPSByZXF1aXJlKFwiLi4vdHJlZS9xdW90ZWRcIiksXG4gICAgICAgIFVSTCA9IHJlcXVpcmUoXCIuLi90cmVlL3VybFwiKSxcbiAgICAgICAgZnVuY3Rpb25SZWdpc3RyeSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCIpLFxuICAgICAgICBmYWxsYmFjayA9IGZ1bmN0aW9uKGZ1bmN0aW9uVGhpcywgbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwobm9kZSwgZnVuY3Rpb25UaGlzLmluZGV4LCBmdW5jdGlvblRoaXMuY3VycmVudEZpbGVJbmZvKS5ldmFsKGZ1bmN0aW9uVGhpcy5jb250ZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5cbiAgICBmdW5jdGlvblJlZ2lzdHJ5LmFkZChcImRhdGEtdXJpXCIsIGZ1bmN0aW9uKG1pbWV0eXBlTm9kZSwgZmlsZVBhdGhOb2RlKSB7XG5cbiAgICAgICAgaWYgKCFmaWxlUGF0aE5vZGUpIHtcbiAgICAgICAgICAgIGZpbGVQYXRoTm9kZSA9IG1pbWV0eXBlTm9kZTtcbiAgICAgICAgICAgIG1pbWV0eXBlTm9kZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWltZXR5cGUgPSBtaW1ldHlwZU5vZGUgJiYgbWltZXR5cGVOb2RlLnZhbHVlO1xuICAgICAgICB2YXIgZmlsZVBhdGggPSBmaWxlUGF0aE5vZGUudmFsdWU7XG4gICAgICAgIHZhciBjdXJyZW50RmlsZUluZm8gPSB0aGlzLmN1cnJlbnRGaWxlSW5mbztcbiAgICAgICAgdmFyIGN1cnJlbnREaXJlY3RvcnkgPSBjdXJyZW50RmlsZUluZm8ucmVsYXRpdmVVcmxzID9cbiAgICAgICAgICAgIGN1cnJlbnRGaWxlSW5mby5jdXJyZW50RGlyZWN0b3J5IDogY3VycmVudEZpbGVJbmZvLmVudHJ5UGF0aDtcblxuICAgICAgICB2YXIgZnJhZ21lbnRTdGFydCA9IGZpbGVQYXRoLmluZGV4T2YoJyMnKTtcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gJyc7XG4gICAgICAgIGlmIChmcmFnbWVudFN0YXJ0ICE9PSAtMSkge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmaWxlUGF0aC5zbGljZShmcmFnbWVudFN0YXJ0KTtcbiAgICAgICAgICAgIGZpbGVQYXRoID0gZmlsZVBhdGguc2xpY2UoMCwgZnJhZ21lbnRTdGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsZU1hbmFnZXIgPSBlbnZpcm9ubWVudC5nZXRGaWxlTWFuYWdlcihmaWxlUGF0aCwgY3VycmVudERpcmVjdG9yeSwgdGhpcy5jb250ZXh0LCBlbnZpcm9ubWVudCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKCFmaWxlTWFuYWdlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrKHRoaXMsIGZpbGVQYXRoTm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXNlQmFzZTY0ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gZGV0ZWN0IHRoZSBtaW1ldHlwZSBpZiBub3QgZ2l2ZW5cbiAgICAgICAgaWYgKCFtaW1ldHlwZU5vZGUpIHtcblxuICAgICAgICAgICAgbWltZXR5cGUgPSBlbnZpcm9ubWVudC5taW1lTG9va3VwKGZpbGVQYXRoKTtcblxuICAgICAgICAgICAgaWYgKG1pbWV0eXBlID09PSBcImltYWdlL3N2Zyt4bWxcIikge1xuICAgICAgICAgICAgICAgIHVzZUJhc2U2NCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgYmFzZSA2NCB1bmxlc3MgaXQncyBhbiBBU0NJSSBvciBVVEYtOCBmb3JtYXRcbiAgICAgICAgICAgICAgICB2YXIgY2hhcnNldCA9IGVudmlyb25tZW50LmNoYXJzZXRMb29rdXAobWltZXR5cGUpO1xuICAgICAgICAgICAgICAgIHVzZUJhc2U2NCA9IFsnVVMtQVNDSUknLCAnVVRGLTgnXS5pbmRleE9mKGNoYXJzZXQpIDwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1c2VCYXNlNjQpIHsgbWltZXR5cGUgKz0gJztiYXNlNjQnOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1c2VCYXNlNjQgPSAvO2Jhc2U2NCQvLnRlc3QobWltZXR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpbGVTeW5jID0gZmlsZU1hbmFnZXIubG9hZEZpbGVTeW5jKGZpbGVQYXRoLCBjdXJyZW50RGlyZWN0b3J5LCB0aGlzLmNvbnRleHQsIGVudmlyb25tZW50KTtcbiAgICAgICAgaWYgKCFmaWxlU3luYy5jb250ZW50cykge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJTa2lwcGVkIGRhdGEtdXJpIGVtYmVkZGluZyBvZiBcIiArIGZpbGVQYXRoICsgXCIgYmVjYXVzZSBmaWxlIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxsYmFjayh0aGlzLCBmaWxlUGF0aE5vZGUgfHwgbWltZXR5cGVOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmID0gZmlsZVN5bmMuY29udGVudHM7XG4gICAgICAgIGlmICh1c2VCYXNlNjQgJiYgIWVudmlyb25tZW50LmVuY29kZUJhc2U2NCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrKHRoaXMsIGZpbGVQYXRoTm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBidWYgPSB1c2VCYXNlNjQgPyBlbnZpcm9ubWVudC5lbmNvZGVCYXNlNjQoYnVmKSA6IGVuY29kZVVSSUNvbXBvbmVudChidWYpO1xuXG4gICAgICAgIHZhciB1cmkgPSBcImRhdGE6XCIgKyBtaW1ldHlwZSArICcsJyArIGJ1ZiArIGZyYWdtZW50O1xuXG4gICAgICAgIC8vIElFOCBjYW5ub3QgaGFuZGxlIGEgZGF0YS11cmkgbGFyZ2VyIHRoYW4gMzIsNzY4IGNoYXJhY3RlcnMuIElmIHRoaXMgaXMgZXhjZWVkZWRcbiAgICAgICAgLy8gYW5kIHRoZSAtLWllQ29tcGF0IGZsYWcgaXMgZW5hYmxlZCwgcmV0dXJuIGEgbm9ybWFsIHVybCgpIGluc3RlYWQuXG4gICAgICAgIHZhciBEQVRBX1VSSV9NQVggPSAzMjc2ODtcbiAgICAgICAgaWYgKHVyaS5sZW5ndGggPj0gREFUQV9VUklfTUFYKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuaWVDb21wYXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJTa2lwcGVkIGRhdGEtdXJpIGVtYmVkZGluZyBvZiBcIiArIGZpbGVQYXRoICsgXCIgYmVjYXVzZSBpdHMgc2l6ZSAoXCIgKyB1cmkubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgXCIgY2hhcmFjdGVycykgZXhjZWVkcyBJRTgtc2FmZSBcIiArIERBVEFfVVJJX01BWCArIFwiIGNoYXJhY3RlcnMhXCIpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrKHRoaXMsIGZpbGVQYXRoTm9kZSB8fCBtaW1ldHlwZU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBVUkwobmV3IFF1b3RlZCgnXCInICsgdXJpICsgJ1wiJywgdXJpLCBmYWxzZSwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbyk7XG4gICAgfSk7XG59O1xuXG59LHtcIi4uL2xvZ2dlclwiOjMzLFwiLi4vdHJlZS9xdW90ZWRcIjo3MyxcIi4uL3RyZWUvdXJsXCI6ODAsXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCI6MjJ9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgS2V5d29yZCA9IHJlcXVpcmUoXCIuLi90cmVlL2tleXdvcmRcIiksXG4gICAgZnVuY3Rpb25SZWdpc3RyeSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCIpO1xuXG52YXIgZGVmYXVsdEZ1bmMgPSB7XG4gICAgZXZhbDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMudmFsdWVfLCBlID0gdGhpcy5lcnJvcl87XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB2ID8gS2V5d29yZC5UcnVlIDogS2V5d29yZC5GYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdmFsdWU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHRoaXMudmFsdWVfID0gdjtcbiAgICB9LFxuICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLmVycm9yXyA9IGU7XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZhbHVlXyA9IHRoaXMuZXJyb3JfID0gbnVsbDtcbiAgICB9XG59O1xuXG5mdW5jdGlvblJlZ2lzdHJ5LmFkZChcImRlZmF1bHRcIiwgZGVmYXVsdEZ1bmMuZXZhbC5iaW5kKGRlZmF1bHRGdW5jKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdEZ1bmM7XG5cbn0se1wiLi4vdHJlZS9rZXl3b3JkXCI6NjUsXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCI6MjJ9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRXhwcmVzc2lvbiA9IHJlcXVpcmUoXCIuLi90cmVlL2V4cHJlc3Npb25cIik7XG5cbnZhciBmdW5jdGlvbkNhbGxlciA9IGZ1bmN0aW9uKG5hbWUsIGNvbnRleHQsIGluZGV4LCBjdXJyZW50RmlsZUluZm8pIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jdXJyZW50RmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XG5cbiAgICB0aGlzLmZ1bmMgPSBjb250ZXh0LmZyYW1lc1swXS5mdW5jdGlvblJlZ2lzdHJ5LmdldCh0aGlzLm5hbWUpO1xufTtcbmZ1bmN0aW9uQ2FsbGVyLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5mdW5jKTtcbn07XG5mdW5jdGlvbkNhbGxlci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uKGFyZ3MpIHtcblxuICAgIC8vIFRoaXMgY29kZSBpcyB0ZXJyaWJsZSBhbmQgc2hvdWxkIGJlIHJlcGxhY2VkIGFzIHBlciB0aGlzIGlzc3VlLi4uXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xlc3MvbGVzcy5qcy9pc3N1ZXMvMjQ3N1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpKSB7XG4gICAgICAgIGFyZ3MgPSBhcmdzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJDb21tZW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcIkV4cHJlc3Npb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBzdWJOb2RlcyA9IGl0ZW0udmFsdWUuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwiQ29tbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1Yk5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ViTm9kZXNbMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uKHN1Yk5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb25DYWxsZXI7XG5cbn0se1wiLi4vdHJlZS9leHByZXNzaW9uXCI6NTl9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5mdW5jdGlvbiBtYWtlUmVnaXN0cnkoIGJhc2UgKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2RhdGE6IHt9LFxuICAgICAgICBhZGQ6IGZ1bmN0aW9uKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgICAgIC8vIHByZWNhdXRpb25hcnkgY2FzZSBjb252ZXJzaW9uLCBhcyBsYXRlciBxdWVyeWluZyBvZlxuICAgICAgICAgICAgLy8gdGhlIHJlZ2lzdHJ5IGJ5IGZ1bmN0aW9uLWNhbGxlciB1c2VzIGxvd2VyIGNhc2UgYXMgd2VsbC5cbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9kYXRhLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy9UT0RPIHdhcm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RhdGFbbmFtZV0gPSBmdW5jO1xuICAgICAgICB9LFxuICAgICAgICBhZGRNdWx0aXBsZTogZnVuY3Rpb24oZnVuY3Rpb25zKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhmdW5jdGlvbnMpLmZvckVhY2goXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChuYW1lLCBmdW5jdGlvbnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbbmFtZV0gfHwgKCBiYXNlICYmIGJhc2UuZ2V0KCBuYW1lICkpO1xuICAgICAgICB9LFxuICAgICAgICBpbmhlcml0IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZVJlZ2lzdHJ5KCB0aGlzICk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1ha2VSZWdpc3RyeSggbnVsbCApO1xufSx7fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbnZpcm9ubWVudCkge1xuICAgIHZhciBmdW5jdGlvbnMgPSB7XG4gICAgICAgIGZ1bmN0aW9uUmVnaXN0cnk6IHJlcXVpcmUoXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCIpLFxuICAgICAgICBmdW5jdGlvbkNhbGxlcjogcmVxdWlyZShcIi4vZnVuY3Rpb24tY2FsbGVyXCIpXG4gICAgfTtcblxuICAgIC8vcmVnaXN0ZXIgZnVuY3Rpb25zXG4gICAgcmVxdWlyZShcIi4vZGVmYXVsdFwiKTtcbiAgICByZXF1aXJlKFwiLi9jb2xvclwiKTtcbiAgICByZXF1aXJlKFwiLi9jb2xvci1ibGVuZGluZ1wiKTtcbiAgICByZXF1aXJlKFwiLi9kYXRhLXVyaVwiKShlbnZpcm9ubWVudCk7XG4gICAgcmVxdWlyZShcIi4vbWF0aFwiKTtcbiAgICByZXF1aXJlKFwiLi9udW1iZXJcIik7XG4gICAgcmVxdWlyZShcIi4vc3RyaW5nXCIpO1xuICAgIHJlcXVpcmUoXCIuL3N2Z1wiKShlbnZpcm9ubWVudCk7XG4gICAgcmVxdWlyZShcIi4vdHlwZXNcIik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb25zO1xufTtcblxufSx7XCIuL2NvbG9yXCI6MTgsXCIuL2NvbG9yLWJsZW5kaW5nXCI6MTcsXCIuL2RhdGEtdXJpXCI6MTksXCIuL2RlZmF1bHRcIjoyMCxcIi4vZnVuY3Rpb24tY2FsbGVyXCI6MjEsXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCI6MjIsXCIuL21hdGhcIjoyNSxcIi4vbnVtYmVyXCI6MjYsXCIuL3N0cmluZ1wiOjI3LFwiLi9zdmdcIjoyOCxcIi4vdHlwZXNcIjoyOX1dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBEaW1lbnNpb24gPSByZXF1aXJlKFwiLi4vdHJlZS9kaW1lbnNpb25cIik7XG5cbnZhciBNYXRoSGVscGVyID0gZnVuY3Rpb24oKSB7XG59O1xuTWF0aEhlbHBlci5fbWF0aCA9IGZ1bmN0aW9uIChmbiwgdW5pdCwgbikge1xuICAgIGlmICghKG4gaW5zdGFuY2VvZiBEaW1lbnNpb24pKSB7XG4gICAgICAgIHRocm93IHsgdHlwZTogXCJBcmd1bWVudFwiLCBtZXNzYWdlOiBcImFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXJcIiB9O1xuICAgIH1cbiAgICBpZiAodW5pdCA9PSBudWxsKSB7XG4gICAgICAgIHVuaXQgPSBuLnVuaXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IG4udW5pZnkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oZm4ocGFyc2VGbG9hdChuLnZhbHVlKSksIHVuaXQpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gTWF0aEhlbHBlcjtcbn0se1wiLi4vdHJlZS9kaW1lbnNpb25cIjo1Nn1dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBmdW5jdGlvblJlZ2lzdHJ5ID0gcmVxdWlyZShcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIiksXG4gICAgbWF0aEhlbHBlciA9IHJlcXVpcmUoXCIuL21hdGgtaGVscGVyLmpzXCIpO1xuXG52YXIgbWF0aEZ1bmN0aW9ucyA9IHtcbiAgICAvLyBuYW1lLCAgdW5pdFxuICAgIGNlaWw6ICBudWxsLFxuICAgIGZsb29yOiBudWxsLFxuICAgIHNxcnQ6ICBudWxsLFxuICAgIGFiczogICBudWxsLFxuICAgIHRhbjogICBcIlwiLFxuICAgIHNpbjogICBcIlwiLFxuICAgIGNvczogICBcIlwiLFxuICAgIGF0YW46ICBcInJhZFwiLFxuICAgIGFzaW46ICBcInJhZFwiLFxuICAgIGFjb3M6ICBcInJhZFwiXG59O1xuXG5mb3IgKHZhciBmIGluIG1hdGhGdW5jdGlvbnMpIHtcbiAgICBpZiAobWF0aEZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShmKSkge1xuICAgICAgICBtYXRoRnVuY3Rpb25zW2ZdID0gbWF0aEhlbHBlci5fbWF0aC5iaW5kKG51bGwsIE1hdGhbZl0sIG1hdGhGdW5jdGlvbnNbZl0pO1xuICAgIH1cbn1cblxubWF0aEZ1bmN0aW9ucy5yb3VuZCA9IGZ1bmN0aW9uIChuLCBmKSB7XG4gICAgdmFyIGZyYWN0aW9uID0gdHlwZW9mIGYgPT09IFwidW5kZWZpbmVkXCIgPyAwIDogZi52YWx1ZTtcbiAgICByZXR1cm4gbWF0aEhlbHBlci5fbWF0aChmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bS50b0ZpeGVkKGZyYWN0aW9uKTsgfSwgbnVsbCwgbik7XG59O1xuXG5mdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKG1hdGhGdW5jdGlvbnMpO1xuXG59LHtcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIjoyMixcIi4vbWF0aC1oZWxwZXIuanNcIjoyNH1dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBEaW1lbnNpb24gPSByZXF1aXJlKFwiLi4vdHJlZS9kaW1lbnNpb25cIiksXG4gICAgQW5vbnltb3VzID0gcmVxdWlyZShcIi4uL3RyZWUvYW5vbnltb3VzXCIpLFxuICAgIGZ1bmN0aW9uUmVnaXN0cnkgPSByZXF1aXJlKFwiLi9mdW5jdGlvbi1yZWdpc3RyeVwiKSxcbiAgICBtYXRoSGVscGVyID0gcmVxdWlyZShcIi4vbWF0aC1oZWxwZXIuanNcIik7XG5cbnZhciBtaW5NYXggPSBmdW5jdGlvbiAoaXNNaW4sIGFyZ3MpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gICAgc3dpdGNoKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogdGhyb3cgeyB0eXBlOiBcIkFyZ3VtZW50XCIsIG1lc3NhZ2U6IFwib25lIG9yIG1vcmUgYXJndW1lbnRzIHJlcXVpcmVkXCIgfTtcbiAgICB9XG4gICAgdmFyIGksIGosIGN1cnJlbnQsIGN1cnJlbnRVbmlmaWVkLCByZWZlcmVuY2VVbmlmaWVkLCB1bml0LCB1bml0U3RhdGljLCB1bml0Q2xvbmUsXG4gICAgICAgIG9yZGVyICA9IFtdLCAvLyBlbGVtcyBvbmx5IGNvbnRhaW5zIG9yaWdpbmFsIGFyZ3VtZW50IHZhbHVlcy5cbiAgICAgICAgdmFsdWVzID0ge307IC8vIGtleSBpcyB0aGUgdW5pdC50b1N0cmluZygpIGZvciB1bmlmaWVkIERpbWVuc2lvbiB2YWx1ZXMsXG4gICAgLy8gdmFsdWUgaXMgdGhlIGluZGV4IGludG8gdGhlIG9yZGVyIGFycmF5LlxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnQgPSBhcmdzW2ldO1xuICAgICAgICBpZiAoIShjdXJyZW50IGluc3RhbmNlb2YgRGltZW5zaW9uKSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1tpXS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcmdzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzW2ldLnZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VW5pZmllZCA9IGN1cnJlbnQudW5pdC50b1N0cmluZygpID09PSBcIlwiICYmIHVuaXRDbG9uZSAhPT0gdW5kZWZpbmVkID8gbmV3IERpbWVuc2lvbihjdXJyZW50LnZhbHVlLCB1bml0Q2xvbmUpLnVuaWZ5KCkgOiBjdXJyZW50LnVuaWZ5KCk7XG4gICAgICAgIHVuaXQgPSBjdXJyZW50VW5pZmllZC51bml0LnRvU3RyaW5nKCkgPT09IFwiXCIgJiYgdW5pdFN0YXRpYyAhPT0gdW5kZWZpbmVkID8gdW5pdFN0YXRpYyA6IGN1cnJlbnRVbmlmaWVkLnVuaXQudG9TdHJpbmcoKTtcbiAgICAgICAgdW5pdFN0YXRpYyA9IHVuaXQgIT09IFwiXCIgJiYgdW5pdFN0YXRpYyA9PT0gdW5kZWZpbmVkIHx8IHVuaXQgIT09IFwiXCIgJiYgb3JkZXJbMF0udW5pZnkoKS51bml0LnRvU3RyaW5nKCkgPT09IFwiXCIgPyB1bml0IDogdW5pdFN0YXRpYztcbiAgICAgICAgdW5pdENsb25lID0gdW5pdCAhPT0gXCJcIiAmJiB1bml0Q2xvbmUgPT09IHVuZGVmaW5lZCA/IGN1cnJlbnQudW5pdC50b1N0cmluZygpIDogdW5pdENsb25lO1xuICAgICAgICBqID0gdmFsdWVzW1wiXCJdICE9PSB1bmRlZmluZWQgJiYgdW5pdCAhPT0gXCJcIiAmJiB1bml0ID09PSB1bml0U3RhdGljID8gdmFsdWVzW1wiXCJdIDogdmFsdWVzW3VuaXRdO1xuICAgICAgICBpZiAoaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodW5pdFN0YXRpYyAhPT0gdW5kZWZpbmVkICYmIHVuaXQgIT09IHVuaXRTdGF0aWMpIHtcbiAgICAgICAgICAgICAgICB0aHJvd3sgdHlwZTogXCJBcmd1bWVudFwiLCBtZXNzYWdlOiBcImluY29tcGF0aWJsZSB0eXBlc1wiIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXNbdW5pdF0gPSBvcmRlci5sZW5ndGg7XG4gICAgICAgICAgICBvcmRlci5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVmZXJlbmNlVW5pZmllZCA9IG9yZGVyW2pdLnVuaXQudG9TdHJpbmcoKSA9PT0gXCJcIiAmJiB1bml0Q2xvbmUgIT09IHVuZGVmaW5lZCA/IG5ldyBEaW1lbnNpb24ob3JkZXJbal0udmFsdWUsIHVuaXRDbG9uZSkudW5pZnkoKSA6IG9yZGVyW2pdLnVuaWZ5KCk7XG4gICAgICAgIGlmICggaXNNaW4gJiYgY3VycmVudFVuaWZpZWQudmFsdWUgPCByZWZlcmVuY2VVbmlmaWVkLnZhbHVlIHx8XG4gICAgICAgICAgICAhaXNNaW4gJiYgY3VycmVudFVuaWZpZWQudmFsdWUgPiByZWZlcmVuY2VVbmlmaWVkLnZhbHVlKSB7XG4gICAgICAgICAgICBvcmRlcltqXSA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9yZGVyLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJldHVybiBvcmRlclswXTtcbiAgICB9XG4gICAgYXJncyA9IG9yZGVyLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS50b0NTUyh0aGlzLmNvbnRleHQpOyB9KS5qb2luKHRoaXMuY29udGV4dC5jb21wcmVzcyA/IFwiLFwiIDogXCIsIFwiKTtcbiAgICByZXR1cm4gbmV3IEFub255bW91cygoaXNNaW4gPyBcIm1pblwiIDogXCJtYXhcIikgKyBcIihcIiArIGFyZ3MgKyBcIilcIik7XG59O1xuZnVuY3Rpb25SZWdpc3RyeS5hZGRNdWx0aXBsZSh7XG4gICAgbWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtaW5NYXgodHJ1ZSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIG1heDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbWluTWF4KGZhbHNlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgY29udmVydDogZnVuY3Rpb24gKHZhbCwgdW5pdCkge1xuICAgICAgICByZXR1cm4gdmFsLmNvbnZlcnRUbyh1bml0LnZhbHVlKTtcbiAgICB9LFxuICAgIHBpOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKE1hdGguUEkpO1xuICAgIH0sXG4gICAgbW9kOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGEudmFsdWUgJSBiLnZhbHVlLCBhLnVuaXQpO1xuICAgIH0sXG4gICAgcG93OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgeCA9IG5ldyBEaW1lbnNpb24oeCk7XG4gICAgICAgICAgICB5ID0gbmV3IERpbWVuc2lvbih5KTtcbiAgICAgICAgfSBlbHNlIGlmICghKHggaW5zdGFuY2VvZiBEaW1lbnNpb24pIHx8ICEoeSBpbnN0YW5jZW9mIERpbWVuc2lvbikpIHtcbiAgICAgICAgICAgIHRocm93IHsgdHlwZTogXCJBcmd1bWVudFwiLCBtZXNzYWdlOiBcImFyZ3VtZW50cyBtdXN0IGJlIG51bWJlcnNcIiB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oTWF0aC5wb3coeC52YWx1ZSwgeS52YWx1ZSksIHgudW5pdCk7XG4gICAgfSxcbiAgICBwZXJjZW50YWdlOiBmdW5jdGlvbiAobikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbWF0aEhlbHBlci5fbWF0aChmdW5jdGlvbihudW0pIHtcbiAgICAgICAgICAgIHJldHVybiBudW0gKiAxMDA7XG4gICAgICAgIH0sICclJywgbik7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59KTtcblxufSx7XCIuLi90cmVlL2Fub255bW91c1wiOjQ2LFwiLi4vdHJlZS9kaW1lbnNpb25cIjo1NixcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIjoyMixcIi4vbWF0aC1oZWxwZXIuanNcIjoyNH1dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBRdW90ZWQgPSByZXF1aXJlKFwiLi4vdHJlZS9xdW90ZWRcIiksXG4gICAgQW5vbnltb3VzID0gcmVxdWlyZShcIi4uL3RyZWUvYW5vbnltb3VzXCIpLFxuICAgIEphdmFTY3JpcHQgPSByZXF1aXJlKFwiLi4vdHJlZS9qYXZhc2NyaXB0XCIpLFxuICAgIGZ1bmN0aW9uUmVnaXN0cnkgPSByZXF1aXJlKFwiLi9mdW5jdGlvbi1yZWdpc3RyeVwiKTtcblxuZnVuY3Rpb25SZWdpc3RyeS5hZGRNdWx0aXBsZSh7XG4gICAgZTogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IEFub255bW91cyhzdHIgaW5zdGFuY2VvZiBKYXZhU2NyaXB0ID8gc3RyLmV2YWx1YXRlZCA6IHN0ci52YWx1ZSk7XG4gICAgfSxcbiAgICBlc2NhcGU6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXMoXG4gICAgICAgICAgICBlbmNvZGVVUkkoc3RyLnZhbHVlKS5yZXBsYWNlKC89L2csIFwiJTNEXCIpLnJlcGxhY2UoLzovZywgXCIlM0FcIikucmVwbGFjZSgvIy9nLCBcIiUyM1wiKS5yZXBsYWNlKC87L2csIFwiJTNCXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKC9nLCBcIiUyOFwiKS5yZXBsYWNlKC9cXCkvZywgXCIlMjlcIikpO1xuICAgIH0sXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKHN0cmluZywgcGF0dGVybiwgcmVwbGFjZW1lbnQsIGZsYWdzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBzdHJpbmcudmFsdWU7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gKHJlcGxhY2VtZW50LnR5cGUgPT09IFwiUXVvdGVkXCIpID9cbiAgICAgICAgICAgIHJlcGxhY2VtZW50LnZhbHVlIDogcmVwbGFjZW1lbnQudG9DU1MoKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UobmV3IFJlZ0V4cChwYXR0ZXJuLnZhbHVlLCBmbGFncyA/IGZsYWdzLnZhbHVlIDogJycpLCByZXBsYWNlbWVudCk7XG4gICAgICAgIHJldHVybiBuZXcgUXVvdGVkKHN0cmluZy5xdW90ZSB8fCAnJywgcmVzdWx0LCBzdHJpbmcuZXNjYXBlZCk7XG4gICAgfSxcbiAgICAnJSc6IGZ1bmN0aW9uIChzdHJpbmcgLyogYXJnLCBhcmcsIC4uLiovKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IHN0cmluZy52YWx1ZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8qanNoaW50IGxvb3BmdW5jOnRydWUgKi9cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC8lW3NkYV0vaSwgZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAoKGFyZ3NbaV0udHlwZSA9PT0gXCJRdW90ZWRcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4ubWF0Y2goL3MvaSkpID8gYXJnc1tpXS52YWx1ZSA6IGFyZ3NbaV0udG9DU1MoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4ubWF0Y2goL1tBLVpdJC8pID8gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoLyUlL2csICclJyk7XG4gICAgICAgIHJldHVybiBuZXcgUXVvdGVkKHN0cmluZy5xdW90ZSB8fCAnJywgcmVzdWx0LCBzdHJpbmcuZXNjYXBlZCk7XG4gICAgfVxufSk7XG5cbn0se1wiLi4vdHJlZS9hbm9ueW1vdXNcIjo0NixcIi4uL3RyZWUvamF2YXNjcmlwdFwiOjYzLFwiLi4vdHJlZS9xdW90ZWRcIjo3MyxcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIjoyMn1dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZW52aXJvbm1lbnQpIHtcbiAgICB2YXIgRGltZW5zaW9uID0gcmVxdWlyZShcIi4uL3RyZWUvZGltZW5zaW9uXCIpLFxuICAgICAgICBDb2xvciA9IHJlcXVpcmUoXCIuLi90cmVlL2NvbG9yXCIpLFxuICAgICAgICBFeHByZXNzaW9uID0gcmVxdWlyZShcIi4uL3RyZWUvZXhwcmVzc2lvblwiKSxcbiAgICAgICAgUXVvdGVkID0gcmVxdWlyZShcIi4uL3RyZWUvcXVvdGVkXCIpLFxuICAgICAgICBVUkwgPSByZXF1aXJlKFwiLi4vdHJlZS91cmxcIiksXG4gICAgICAgIGZ1bmN0aW9uUmVnaXN0cnkgPSByZXF1aXJlKFwiLi9mdW5jdGlvbi1yZWdpc3RyeVwiKTtcblxuICAgIGZ1bmN0aW9uUmVnaXN0cnkuYWRkKFwic3ZnLWdyYWRpZW50XCIsIGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuXG4gICAgICAgIHZhciBzdG9wcyxcbiAgICAgICAgICAgIGdyYWRpZW50RGlyZWN0aW9uU3ZnLFxuICAgICAgICAgICAgZ3JhZGllbnRUeXBlID0gXCJsaW5lYXJcIixcbiAgICAgICAgICAgIHJlY3RhbmdsZURpbWVuc2lvbiA9ICd4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCIxXCIgaGVpZ2h0PVwiMVwiJyxcbiAgICAgICAgICAgIHJlbmRlckVudiA9IHtjb21wcmVzczogZmFsc2V9LFxuICAgICAgICAgICAgcmV0dXJuZXIsXG4gICAgICAgICAgICBkaXJlY3Rpb25WYWx1ZSA9IGRpcmVjdGlvbi50b0NTUyhyZW5kZXJFbnYpLFxuXHRcdFx0aSwgY29sb3IsIHBvc2l0aW9uLCBwb3NpdGlvblZhbHVlLCBhbHBoYTtcblxuICAgICAgICBmdW5jdGlvbiB0aHJvd0FyZ3VtZW50RGVzY3JpcHRvcigpIHtcbiAgICAgICAgICAgIHRocm93IHsgdHlwZTogXCJBcmd1bWVudFwiLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IFwic3ZnLWdyYWRpZW50IGV4cGVjdHMgZGlyZWN0aW9uLCBzdGFydF9jb2xvciBbc3RhcnRfcG9zaXRpb25dLCBbY29sb3IgcG9zaXRpb24sXS4uLixcIiArXG5cdFx0XHRcdFx0XHRcdFwiIGVuZF9jb2xvciBbZW5kX3Bvc2l0aW9uXSBvciBkaXJlY3Rpb24sIGNvbG9yIGxpc3RcIiB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1sxXS52YWx1ZS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dBcmd1bWVudERlc2NyaXB0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3BzID0gYXJndW1lbnRzWzFdLnZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICB0aHJvd0FyZ3VtZW50RGVzY3JpcHRvcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RvcHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb25WYWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcInRvIGJvdHRvbVwiOlxuICAgICAgICAgICAgICAgIGdyYWRpZW50RGlyZWN0aW9uU3ZnID0gJ3gxPVwiMCVcIiB5MT1cIjAlXCIgeDI9XCIwJVwiIHkyPVwiMTAwJVwiJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0byByaWdodFwiOlxuICAgICAgICAgICAgICAgIGdyYWRpZW50RGlyZWN0aW9uU3ZnID0gJ3gxPVwiMCVcIiB5MT1cIjAlXCIgeDI9XCIxMDAlXCIgeTI9XCIwJVwiJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0byBib3R0b20gcmlnaHRcIjpcbiAgICAgICAgICAgICAgICBncmFkaWVudERpcmVjdGlvblN2ZyA9ICd4MT1cIjAlXCIgeTE9XCIwJVwiIHgyPVwiMTAwJVwiIHkyPVwiMTAwJVwiJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0byB0b3AgcmlnaHRcIjpcbiAgICAgICAgICAgICAgICBncmFkaWVudERpcmVjdGlvblN2ZyA9ICd4MT1cIjAlXCIgeTE9XCIxMDAlXCIgeDI9XCIxMDAlXCIgeTI9XCIwJVwiJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlbGxpcHNlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWxsaXBzZSBhdCBjZW50ZXJcIjpcbiAgICAgICAgICAgICAgICBncmFkaWVudFR5cGUgPSBcInJhZGlhbFwiO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50RGlyZWN0aW9uU3ZnID0gJ2N4PVwiNTAlXCIgY3k9XCI1MCVcIiByPVwiNzUlXCInO1xuICAgICAgICAgICAgICAgIHJlY3RhbmdsZURpbWVuc2lvbiA9ICd4PVwiLTUwXCIgeT1cIi01MFwiIHdpZHRoPVwiMTAxXCIgaGVpZ2h0PVwiMTAxXCInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyB7IHR5cGU6IFwiQXJndW1lbnRcIiwgbWVzc2FnZTogXCJzdmctZ3JhZGllbnQgZGlyZWN0aW9uIG11c3QgYmUgJ3RvIGJvdHRvbScsICd0byByaWdodCcsXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiAndG8gYm90dG9tIHJpZ2h0JywgJ3RvIHRvcCByaWdodCcgb3IgJ2VsbGlwc2UgYXQgY2VudGVyJ1wiIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuZXIgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiID8+JyArXG4gICAgICAgICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmVyc2lvbj1cIjEuMVwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDEgMVwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCI+JyArXG4gICAgICAgICAgICAnPCcgKyBncmFkaWVudFR5cGUgKyAnR3JhZGllbnQgaWQ9XCJncmFkaWVudFwiIGdyYWRpZW50VW5pdHM9XCJ1c2VyU3BhY2VPblVzZVwiICcgKyBncmFkaWVudERpcmVjdGlvblN2ZyArICc+JztcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3RvcHMubGVuZ3RoOyBpKz0gMSkge1xuICAgICAgICAgICAgaWYgKHN0b3BzW2ldIGluc3RhbmNlb2YgRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gc3RvcHNbaV0udmFsdWVbMF07XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBzdG9wc1tpXS52YWx1ZVsxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBzdG9wc1tpXTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoY29sb3IgaW5zdGFuY2VvZiBDb2xvcikgfHwgKCEoKGkgPT09IDAgfHwgaSArIDEgPT09IHN0b3BzLmxlbmd0aCkgJiYgcG9zaXRpb24gPT09IHVuZGVmaW5lZCkgJiYgIShwb3NpdGlvbiBpbnN0YW5jZW9mIERpbWVuc2lvbikpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dBcmd1bWVudERlc2NyaXB0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc2l0aW9uVmFsdWUgPSBwb3NpdGlvbiA/IHBvc2l0aW9uLnRvQ1NTKHJlbmRlckVudikgOiBpID09PSAwID8gXCIwJVwiIDogXCIxMDAlXCI7XG4gICAgICAgICAgICBhbHBoYSA9IGNvbG9yLmFscGhhO1xuICAgICAgICAgICAgcmV0dXJuZXIgKz0gJzxzdG9wIG9mZnNldD1cIicgKyBwb3NpdGlvblZhbHVlICsgJ1wiIHN0b3AtY29sb3I9XCInICsgY29sb3IudG9SR0IoKSArICdcIicgKyAoYWxwaGEgPCAxID8gJyBzdG9wLW9wYWNpdHk9XCInICsgYWxwaGEgKyAnXCInIDogJycpICsgJy8+JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5lciArPSAnPC8nICsgZ3JhZGllbnRUeXBlICsgJ0dyYWRpZW50PicgK1xuICAgICAgICAgICAgJzxyZWN0ICcgKyByZWN0YW5nbGVEaW1lbnNpb24gKyAnIGZpbGw9XCJ1cmwoI2dyYWRpZW50KVwiIC8+PC9zdmc+JztcblxuICAgICAgICByZXR1cm5lciA9IGVuY29kZVVSSUNvbXBvbmVudChyZXR1cm5lcik7XG5cbiAgICAgICAgcmV0dXJuZXIgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbCxcIiArIHJldHVybmVyO1xuICAgICAgICByZXR1cm4gbmV3IFVSTChuZXcgUXVvdGVkKFwiJ1wiICsgcmV0dXJuZXIgKyBcIidcIiwgcmV0dXJuZXIsIGZhbHNlLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbyksIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvKTtcbiAgICB9KTtcbn07XG5cbn0se1wiLi4vdHJlZS9jb2xvclwiOjUwLFwiLi4vdHJlZS9kaW1lbnNpb25cIjo1NixcIi4uL3RyZWUvZXhwcmVzc2lvblwiOjU5LFwiLi4vdHJlZS9xdW90ZWRcIjo3MyxcIi4uL3RyZWUvdXJsXCI6ODAsXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCI6MjJ9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgS2V5d29yZCA9IHJlcXVpcmUoXCIuLi90cmVlL2tleXdvcmRcIiksXG4gICAgRGV0YWNoZWRSdWxlc2V0ID0gcmVxdWlyZShcIi4uL3RyZWUvZGV0YWNoZWQtcnVsZXNldFwiKSxcbiAgICBEaW1lbnNpb24gPSByZXF1aXJlKFwiLi4vdHJlZS9kaW1lbnNpb25cIiksXG4gICAgQ29sb3IgPSByZXF1aXJlKFwiLi4vdHJlZS9jb2xvclwiKSxcbiAgICBRdW90ZWQgPSByZXF1aXJlKFwiLi4vdHJlZS9xdW90ZWRcIiksXG4gICAgQW5vbnltb3VzID0gcmVxdWlyZShcIi4uL3RyZWUvYW5vbnltb3VzXCIpLFxuICAgIFVSTCA9IHJlcXVpcmUoXCIuLi90cmVlL3VybFwiKSxcbiAgICBPcGVyYXRpb24gPSByZXF1aXJlKFwiLi4vdHJlZS9vcGVyYXRpb25cIiksXG4gICAgZnVuY3Rpb25SZWdpc3RyeSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCIpO1xuXG52YXIgaXNhID0gZnVuY3Rpb24gKG4sIFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIChuIGluc3RhbmNlb2YgVHlwZSkgPyBLZXl3b3JkLlRydWUgOiBLZXl3b3JkLkZhbHNlO1xuICAgIH0sXG4gICAgaXN1bml0ID0gZnVuY3Rpb24gKG4sIHVuaXQpIHtcbiAgICAgICAgaWYgKHVuaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiBcIkFyZ3VtZW50XCIsIG1lc3NhZ2U6IFwibWlzc2luZyB0aGUgcmVxdWlyZWQgc2Vjb25kIGFyZ3VtZW50IHRvIGlzdW5pdC5cIiB9O1xuICAgICAgICB9XG4gICAgICAgIHVuaXQgPSB0eXBlb2YgdW5pdC52YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHVuaXQudmFsdWUgOiB1bml0O1xuICAgICAgICBpZiAodHlwZW9mIHVuaXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IHsgdHlwZTogXCJBcmd1bWVudFwiLCBtZXNzYWdlOiBcIlNlY29uZCBhcmd1bWVudCB0byBpc3VuaXQgc2hvdWxkIGJlIGEgdW5pdCBvciBhIHN0cmluZy5cIiB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobiBpbnN0YW5jZW9mIERpbWVuc2lvbikgJiYgbi51bml0LmlzKHVuaXQpID8gS2V5d29yZC5UcnVlIDogS2V5d29yZC5GYWxzZTtcbiAgICB9LFxuICAgIGdldEl0ZW1zRnJvbU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIC8vIGhhbmRsZSBub24tYXJyYXkgdmFsdWVzIGFzIGFuIGFycmF5IG9mIGxlbmd0aCAxXG4gICAgICAgIC8vIHJldHVybiAndW5kZWZpbmVkJyBpZiBpbmRleCBpcyBpbnZhbGlkXG4gICAgICAgIHZhciBpdGVtcyA9IEFycmF5LmlzQXJyYXkobm9kZS52YWx1ZSkgP1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA6IEFycmF5KG5vZGUpO1xuXG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9O1xuZnVuY3Rpb25SZWdpc3RyeS5hZGRNdWx0aXBsZSh7XG4gICAgaXNydWxlc2V0OiBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gaXNhKG4sIERldGFjaGVkUnVsZXNldCk7XG4gICAgfSxcbiAgICBpc2NvbG9yOiBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gaXNhKG4sIENvbG9yKTtcbiAgICB9LFxuICAgIGlzbnVtYmVyOiBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gaXNhKG4sIERpbWVuc2lvbik7XG4gICAgfSxcbiAgICBpc3N0cmluZzogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIGlzYShuLCBRdW90ZWQpO1xuICAgIH0sXG4gICAgaXNrZXl3b3JkOiBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gaXNhKG4sIEtleXdvcmQpO1xuICAgIH0sXG4gICAgaXN1cmw6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBpc2EobiwgVVJMKTtcbiAgICB9LFxuICAgIGlzcGl4ZWw6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBpc3VuaXQobiwgJ3B4Jyk7XG4gICAgfSxcbiAgICBpc3BlcmNlbnRhZ2U6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBpc3VuaXQobiwgJyUnKTtcbiAgICB9LFxuICAgIGlzZW06IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBpc3VuaXQobiwgJ2VtJyk7XG4gICAgfSxcbiAgICBpc3VuaXQ6IGlzdW5pdCxcbiAgICB1bml0OiBmdW5jdGlvbiAodmFsLCB1bml0KSB7XG4gICAgICAgIGlmICghKHZhbCBpbnN0YW5jZW9mIERpbWVuc2lvbikpIHtcbiAgICAgICAgICAgIHRocm93IHsgdHlwZTogXCJBcmd1bWVudFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwidGhlIGZpcnN0IGFyZ3VtZW50IHRvIHVuaXQgbXVzdCBiZSBhIG51bWJlclwiICtcbiAgICAgICAgICAgICAgICAgICAgKHZhbCBpbnN0YW5jZW9mIE9wZXJhdGlvbiA/IFwiLiBIYXZlIHlvdSBmb3Jnb3R0ZW4gcGFyZW50aGVzaXM/XCIgOiBcIlwiKSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0KSB7XG4gICAgICAgICAgICBpZiAodW5pdCBpbnN0YW5jZW9mIEtleXdvcmQpIHtcbiAgICAgICAgICAgICAgICB1bml0ID0gdW5pdC52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9IHVuaXQudG9DU1MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKHZhbC52YWx1ZSwgdW5pdCk7XG4gICAgfSxcbiAgICBcImdldC11bml0XCI6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzKG4udW5pdCk7XG4gICAgfSxcbiAgICBleHRyYWN0OiBmdW5jdGlvbih2YWx1ZXMsIGluZGV4KSB7XG4gICAgICAgIGluZGV4ID0gaW5kZXgudmFsdWUgLSAxOyAvLyAoMS1iYXNlZCBpbmRleClcblxuICAgICAgICByZXR1cm4gZ2V0SXRlbXNGcm9tTm9kZSh2YWx1ZXMpW2luZGV4XTtcbiAgICB9LFxuICAgIGxlbmd0aDogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGdldEl0ZW1zRnJvbU5vZGUodmFsdWVzKS5sZW5ndGgpO1xuICAgIH1cbn0pO1xuXG59LHtcIi4uL3RyZWUvYW5vbnltb3VzXCI6NDYsXCIuLi90cmVlL2NvbG9yXCI6NTAsXCIuLi90cmVlL2RldGFjaGVkLXJ1bGVzZXRcIjo1NSxcIi4uL3RyZWUvZGltZW5zaW9uXCI6NTYsXCIuLi90cmVlL2tleXdvcmRcIjo2NSxcIi4uL3RyZWUvb3BlcmF0aW9uXCI6NzEsXCIuLi90cmVlL3F1b3RlZFwiOjczLFwiLi4vdHJlZS91cmxcIjo4MCxcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIjoyMn1dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBjb250ZXh0cyA9IHJlcXVpcmUoXCIuL2NvbnRleHRzXCIpLFxuICAgIFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyL3BhcnNlcicpLFxuICAgIEZ1bmN0aW9uSW1wb3J0ZXIgPSByZXF1aXJlKCcuL3BsdWdpbnMvZnVuY3Rpb24taW1wb3J0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbnZpcm9ubWVudCkge1xuXG4gICAgLy8gRmlsZUluZm8gPSB7XG4gICAgLy8gICdyZWxhdGl2ZVVybHMnIC0gb3B0aW9uIC0gd2hldGhlciB0byBhZGp1c3QgVVJMJ3MgdG8gYmUgcmVsYXRpdmVcbiAgICAvLyAgJ2ZpbGVuYW1lJyAtIGZ1bGwgcmVzb2x2ZWQgZmlsZW5hbWUgb2YgY3VycmVudCBmaWxlXG4gICAgLy8gICdyb290cGF0aCcgLSBwYXRoIHRvIGFwcGVuZCB0byBub3JtYWwgVVJMcyBmb3IgdGhpcyBub2RlXG4gICAgLy8gICdjdXJyZW50RGlyZWN0b3J5JyAtIHBhdGggdG8gdGhlIGN1cnJlbnQgZmlsZSwgYWJzb2x1dGVcbiAgICAvLyAgJ3Jvb3RGaWxlbmFtZScgLSBmaWxlbmFtZSBvZiB0aGUgYmFzZSBmaWxlXG4gICAgLy8gICdlbnRyeVBhdGgnIC0gYWJzb2x1dGUgcGF0aCB0byB0aGUgZW50cnkgZmlsZVxuICAgIC8vICAncmVmZXJlbmNlJyAtIHdoZXRoZXIgdGhlIGZpbGUgc2hvdWxkIG5vdCBiZSBvdXRwdXQgYW5kIG9ubHkgb3V0cHV0IHBhcnRzIHRoYXQgYXJlIHJlZmVyZW5jZWRcblxuICAgIHZhciBJbXBvcnRNYW5hZ2VyID0gZnVuY3Rpb24oY29udGV4dCwgcm9vdEZpbGVJbmZvKSB7XG4gICAgICAgIHRoaXMucm9vdEZpbGVuYW1lID0gcm9vdEZpbGVJbmZvLmZpbGVuYW1lO1xuICAgICAgICB0aGlzLnBhdGhzID0gY29udGV4dC5wYXRocyB8fCBbXTsgIC8vIFNlYXJjaCBwYXRocywgd2hlbiBpbXBvcnRpbmdcbiAgICAgICAgdGhpcy5jb250ZW50cyA9IHt9OyAgICAgICAgICAgICAvLyBtYXAgLSBmaWxlbmFtZSB0byBjb250ZW50cyBvZiBhbGwgdGhlIGZpbGVzXG4gICAgICAgIHRoaXMuY29udGVudHNJZ25vcmVkQ2hhcnMgPSB7fTsgLy8gbWFwIC0gZmlsZW5hbWUgdG8gbGluZXMgYXQgdGhlIGJlZ2lubmluZyBvZiBlYWNoIGZpbGUgdG8gaWdub3JlXG4gICAgICAgIHRoaXMubWltZSA9IGNvbnRleHQubWltZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIC8vIERlcHJlY2F0ZWQ/IFVudXNlZCBvdXRzaWRlIG9mIGhlcmUsIGNvdWxkIGJlIHVzZWZ1bC5cbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdOyAgICAgICAgLy8gRmlsZXMgd2hpY2ggaGF2ZW4ndCBiZWVuIGltcG9ydGVkIHlldFxuICAgICAgICB0aGlzLmZpbGVzID0ge307ICAgICAgICAvLyBIb2xkcyB0aGUgaW1wb3J0ZWQgcGFyc2UgdHJlZXMuXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYW4gaW1wb3J0IHRvIGJlIGltcG9ydGVkXG4gICAgICogQHBhcmFtIHBhdGggLSB0aGUgcmF3IHBhdGhcbiAgICAgKiBAcGFyYW0gdHJ5QXBwZW5kTGVzc0V4dGVuc2lvbiAtIHdoZXRoZXIgdG8gdHJ5IGFwcGVuZGluZyB0aGUgbGVzcyBleHRlbnNpb24gKGlmIHRoZSBwYXRoIGhhcyBubyBleHRlbnNpb24pXG4gICAgICogQHBhcmFtIGN1cnJlbnRGaWxlSW5mbyAtIHRoZSBjdXJyZW50IGZpbGUgaW5mbyAodXNlZCBmb3IgaW5zdGFuY2UgdG8gd29yayBvdXQgcmVsYXRpdmUgcGF0aHMpXG4gICAgICogQHBhcmFtIGltcG9ydE9wdGlvbnMgLSBpbXBvcnQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIGNhbGxiYWNrIGZvciB3aGVuIGl0IGlzIGltcG9ydGVkXG4gICAgICovXG4gICAgSW1wb3J0TWFuYWdlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChwYXRoLCB0cnlBcHBlbmRMZXNzRXh0ZW5zaW9uLCBjdXJyZW50RmlsZUluZm8sIGltcG9ydE9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpbXBvcnRNYW5hZ2VyID0gdGhpcztcbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHBhdGgpO1xuXG4gICAgICAgIHZhciBmaWxlUGFyc2VkRnVuYyA9IGZ1bmN0aW9uIChlLCByb290LCBmdWxsUGF0aCkge1xuICAgICAgICAgICAgaW1wb3J0TWFuYWdlci5xdWV1ZS5zcGxpY2UoaW1wb3J0TWFuYWdlci5xdWV1ZS5pbmRleE9mKHBhdGgpLCAxKTsgLy8gUmVtb3ZlIHRoZSBwYXRoIGZyb20gdGhlIHF1ZXVlXG5cbiAgICAgICAgICAgIHZhciBpbXBvcnRlZEVxdWFsc1Jvb3QgPSBmdWxsUGF0aCA9PT0gaW1wb3J0TWFuYWdlci5yb290RmlsZW5hbWU7XG4gICAgICAgICAgICBpZiAoaW1wb3J0T3B0aW9ucy5vcHRpb25hbCAmJiBlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge3J1bGVzOltdfSwgZmFsc2UsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0TWFuYWdlci5maWxlc1tmdWxsUGF0aF0gPSByb290O1xuICAgICAgICAgICAgICAgIGlmIChlICYmICFpbXBvcnRNYW5hZ2VyLmVycm9yKSB7IGltcG9ydE1hbmFnZXIuZXJyb3IgPSBlOyB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSwgcm9vdCwgaW1wb3J0ZWRFcXVhbHNSb290LCBmdWxsUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG5ld0ZpbGVJbmZvID0ge1xuICAgICAgICAgICAgcmVsYXRpdmVVcmxzOiB0aGlzLmNvbnRleHQucmVsYXRpdmVVcmxzLFxuICAgICAgICAgICAgZW50cnlQYXRoOiBjdXJyZW50RmlsZUluZm8uZW50cnlQYXRoLFxuICAgICAgICAgICAgcm9vdHBhdGg6IGN1cnJlbnRGaWxlSW5mby5yb290cGF0aCxcbiAgICAgICAgICAgIHJvb3RGaWxlbmFtZTogY3VycmVudEZpbGVJbmZvLnJvb3RGaWxlbmFtZVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBmaWxlTWFuYWdlciA9IGVudmlyb25tZW50LmdldEZpbGVNYW5hZ2VyKHBhdGgsIGN1cnJlbnRGaWxlSW5mby5jdXJyZW50RGlyZWN0b3J5LCB0aGlzLmNvbnRleHQsIGVudmlyb25tZW50KTtcblxuICAgICAgICBpZiAoIWZpbGVNYW5hZ2VyKSB7XG4gICAgICAgICAgICBmaWxlUGFyc2VkRnVuYyh7IG1lc3NhZ2U6IFwiQ291bGQgbm90IGZpbmQgYSBmaWxlLW1hbmFnZXIgZm9yIFwiICsgcGF0aCB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cnlBcHBlbmRMZXNzRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBwYXRoID0gZmlsZU1hbmFnZXIudHJ5QXBwZW5kRXh0ZW5zaW9uKHBhdGgsIGltcG9ydE9wdGlvbnMucGx1Z2luID8gXCIuanNcIiA6IFwiLmxlc3NcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9hZEZpbGVDYWxsYmFjayA9IGZ1bmN0aW9uKGxvYWRlZEZpbGUpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlZEZpbGVuYW1lID0gbG9hZGVkRmlsZS5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBjb250ZW50cyA9IGxvYWRlZEZpbGUuY29udGVudHMucmVwbGFjZSgvXlxcdUZFRkYvLCAnJyk7XG5cbiAgICAgICAgICAgIC8vIFBhc3Mgb24gYW4gdXBkYXRlZCByb290cGF0aCBpZiBwYXRoIG9mIGltcG9ydGVkIGZpbGUgaXMgcmVsYXRpdmUgYW5kIGZpbGVcbiAgICAgICAgICAgIC8vIGlzIGluIGEgKHN1YnxzdXApIGRpcmVjdG9yeVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEV4YW1wbGVzOlxuICAgICAgICAgICAgLy8gLSBJZiBwYXRoIG9mIGltcG9ydGVkIGZpbGUgaXMgJ21vZHVsZS9uYXYvbmF2Lmxlc3MnIGFuZCByb290cGF0aCBpcyAnbGVzcy8nLFxuICAgICAgICAgICAgLy8gICB0aGVuIHJvb3RwYXRoIHNob3VsZCBiZWNvbWUgJ2xlc3MvbW9kdWxlL25hdi8nXG4gICAgICAgICAgICAvLyAtIElmIHBhdGggb2YgaW1wb3J0ZWQgZmlsZSBpcyAnLi4vbWl4aW5zLmxlc3MnIGFuZCByb290cGF0aCBpcyAnbGVzcy8nLFxuICAgICAgICAgICAgLy8gICB0aGVuIHJvb3RwYXRoIHNob3VsZCBiZWNvbWUgJ2xlc3MvLi4vJ1xuICAgICAgICAgICAgbmV3RmlsZUluZm8uY3VycmVudERpcmVjdG9yeSA9IGZpbGVNYW5hZ2VyLmdldFBhdGgocmVzb2x2ZWRGaWxlbmFtZSk7XG4gICAgICAgICAgICBpZiAobmV3RmlsZUluZm8ucmVsYXRpdmVVcmxzKSB7XG4gICAgICAgICAgICAgICAgbmV3RmlsZUluZm8ucm9vdHBhdGggPSBmaWxlTWFuYWdlci5qb2luKFxuICAgICAgICAgICAgICAgICAgICAoaW1wb3J0TWFuYWdlci5jb250ZXh0LnJvb3RwYXRoIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAgICAgICBmaWxlTWFuYWdlci5wYXRoRGlmZihuZXdGaWxlSW5mby5jdXJyZW50RGlyZWN0b3J5LCBuZXdGaWxlSW5mby5lbnRyeVBhdGgpKTtcblxuICAgICAgICAgICAgICAgIGlmICghZmlsZU1hbmFnZXIuaXNQYXRoQWJzb2x1dGUobmV3RmlsZUluZm8ucm9vdHBhdGgpICYmIGZpbGVNYW5hZ2VyLmFsd2F5c01ha2VQYXRoc0Fic29sdXRlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RmlsZUluZm8ucm9vdHBhdGggPSBmaWxlTWFuYWdlci5qb2luKG5ld0ZpbGVJbmZvLmVudHJ5UGF0aCwgbmV3RmlsZUluZm8ucm9vdHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0ZpbGVJbmZvLmZpbGVuYW1lID0gcmVzb2x2ZWRGaWxlbmFtZTtcblxuICAgICAgICAgICAgdmFyIG5ld0VudiA9IG5ldyBjb250ZXh0cy5QYXJzZShpbXBvcnRNYW5hZ2VyLmNvbnRleHQpO1xuXG4gICAgICAgICAgICBuZXdFbnYucHJvY2Vzc0ltcG9ydHMgPSBmYWxzZTtcbiAgICAgICAgICAgIGltcG9ydE1hbmFnZXIuY29udGVudHNbcmVzb2x2ZWRGaWxlbmFtZV0gPSBjb250ZW50cztcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRGaWxlSW5mby5yZWZlcmVuY2UgfHwgaW1wb3J0T3B0aW9ucy5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICBuZXdGaWxlSW5mby5yZWZlcmVuY2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW1wb3J0T3B0aW9ucy5wbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBuZXcgRnVuY3Rpb25JbXBvcnRlcihuZXdFbnYsIG5ld0ZpbGVJbmZvKS5ldmFsKGNvbnRlbnRzLCBmdW5jdGlvbiAoZSwgcm9vdCkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlUGFyc2VkRnVuYyhlLCByb290LCByZXNvbHZlZEZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW1wb3J0T3B0aW9ucy5pbmxpbmUpIHtcbiAgICAgICAgICAgICAgICBmaWxlUGFyc2VkRnVuYyhudWxsLCBjb250ZW50cywgcmVzb2x2ZWRGaWxlbmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ldyBQYXJzZXIobmV3RW52LCBpbXBvcnRNYW5hZ2VyLCBuZXdGaWxlSW5mbykucGFyc2UoY29udGVudHMsIGZ1bmN0aW9uIChlLCByb290KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYXJzZWRGdW5jKGUsIHJvb3QsIHJlc29sdmVkRmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwcm9taXNlID0gZmlsZU1hbmFnZXIubG9hZEZpbGUocGF0aCwgY3VycmVudEZpbGVJbmZvLmN1cnJlbnREaXJlY3RvcnksIHRoaXMuY29udGV4dCwgZW52aXJvbm1lbnQsXG4gICAgICAgICAgICBmdW5jdGlvbihlcnIsIGxvYWRlZEZpbGUpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmaWxlUGFyc2VkRnVuYyhlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2FkRmlsZUNhbGxiYWNrKGxvYWRlZEZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICAgIHByb21pc2UudGhlbihsb2FkRmlsZUNhbGxiYWNrLCBmaWxlUGFyc2VkRnVuYyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJbXBvcnRNYW5hZ2VyO1xufTtcblxufSx7XCIuL2NvbnRleHRzXCI6MTEsXCIuL3BhcnNlci9wYXJzZXJcIjozOCxcIi4vcGx1Z2lucy9mdW5jdGlvbi1pbXBvcnRlclwiOjQwfV0sMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbnZpcm9ubWVudCwgZmlsZU1hbmFnZXJzKSB7XG4gICAgdmFyIFNvdXJjZU1hcE91dHB1dCwgU291cmNlTWFwQnVpbGRlciwgUGFyc2VUcmVlLCBJbXBvcnRNYW5hZ2VyLCBFbnZpcm9ubWVudDtcblxuICAgIHZhciBsZXNzID0ge1xuICAgICAgICB2ZXJzaW9uOiBbMiwgNywgMl0sXG4gICAgICAgIGRhdGE6IHJlcXVpcmUoJy4vZGF0YScpLFxuICAgICAgICB0cmVlOiByZXF1aXJlKCcuL3RyZWUnKSxcbiAgICAgICAgRW52aXJvbm1lbnQ6IChFbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50L2Vudmlyb25tZW50XCIpKSxcbiAgICAgICAgQWJzdHJhY3RGaWxlTWFuYWdlcjogcmVxdWlyZShcIi4vZW52aXJvbm1lbnQvYWJzdHJhY3QtZmlsZS1tYW5hZ2VyXCIpLFxuICAgICAgICBlbnZpcm9ubWVudDogKGVudmlyb25tZW50ID0gbmV3IEVudmlyb25tZW50KGVudmlyb25tZW50LCBmaWxlTWFuYWdlcnMpKSxcbiAgICAgICAgdmlzaXRvcnM6IHJlcXVpcmUoJy4vdmlzaXRvcnMnKSxcbiAgICAgICAgUGFyc2VyOiByZXF1aXJlKCcuL3BhcnNlci9wYXJzZXInKSxcbiAgICAgICAgZnVuY3Rpb25zOiByZXF1aXJlKCcuL2Z1bmN0aW9ucycpKGVudmlyb25tZW50KSxcbiAgICAgICAgY29udGV4dHM6IHJlcXVpcmUoXCIuL2NvbnRleHRzXCIpLFxuICAgICAgICBTb3VyY2VNYXBPdXRwdXQ6IChTb3VyY2VNYXBPdXRwdXQgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtb3V0cHV0JykoZW52aXJvbm1lbnQpKSxcbiAgICAgICAgU291cmNlTWFwQnVpbGRlcjogKFNvdXJjZU1hcEJ1aWxkZXIgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtYnVpbGRlcicpKFNvdXJjZU1hcE91dHB1dCwgZW52aXJvbm1lbnQpKSxcbiAgICAgICAgUGFyc2VUcmVlOiAoUGFyc2VUcmVlID0gcmVxdWlyZSgnLi9wYXJzZS10cmVlJykoU291cmNlTWFwQnVpbGRlcikpLFxuICAgICAgICBJbXBvcnRNYW5hZ2VyOiAoSW1wb3J0TWFuYWdlciA9IHJlcXVpcmUoJy4vaW1wb3J0LW1hbmFnZXInKShlbnZpcm9ubWVudCkpLFxuICAgICAgICByZW5kZXI6IHJlcXVpcmUoXCIuL3JlbmRlclwiKShlbnZpcm9ubWVudCwgUGFyc2VUcmVlLCBJbXBvcnRNYW5hZ2VyKSxcbiAgICAgICAgcGFyc2U6IHJlcXVpcmUoXCIuL3BhcnNlXCIpKGVudmlyb25tZW50LCBQYXJzZVRyZWUsIEltcG9ydE1hbmFnZXIpLFxuICAgICAgICBMZXNzRXJyb3I6IHJlcXVpcmUoJy4vbGVzcy1lcnJvcicpLFxuICAgICAgICB0cmFuc2Zvcm1UcmVlOiByZXF1aXJlKCcuL3RyYW5zZm9ybS10cmVlJyksXG4gICAgICAgIHV0aWxzOiByZXF1aXJlKCcuL3V0aWxzJyksXG4gICAgICAgIFBsdWdpbk1hbmFnZXI6IHJlcXVpcmUoJy4vcGx1Z2luLW1hbmFnZXInKSxcbiAgICAgICAgbG9nZ2VyOiByZXF1aXJlKCcuL2xvZ2dlcicpXG4gICAgfTtcblxuICAgIHJldHVybiBsZXNzO1xufTtcblxufSx7XCIuL2NvbnRleHRzXCI6MTEsXCIuL2RhdGFcIjoxMyxcIi4vZW52aXJvbm1lbnQvYWJzdHJhY3QtZmlsZS1tYW5hZ2VyXCI6MTUsXCIuL2Vudmlyb25tZW50L2Vudmlyb25tZW50XCI6MTYsXCIuL2Z1bmN0aW9uc1wiOjIzLFwiLi9pbXBvcnQtbWFuYWdlclwiOjMwLFwiLi9sZXNzLWVycm9yXCI6MzIsXCIuL2xvZ2dlclwiOjMzLFwiLi9wYXJzZVwiOjM1LFwiLi9wYXJzZS10cmVlXCI6MzQsXCIuL3BhcnNlci9wYXJzZXJcIjozOCxcIi4vcGx1Z2luLW1hbmFnZXJcIjozOSxcIi4vcmVuZGVyXCI6NDEsXCIuL3NvdXJjZS1tYXAtYnVpbGRlclwiOjQyLFwiLi9zb3VyY2UtbWFwLW91dHB1dFwiOjQzLFwiLi90cmFuc2Zvcm0tdHJlZVwiOjQ0LFwiLi90cmVlXCI6NjIsXCIuL3V0aWxzXCI6ODMsXCIuL3Zpc2l0b3JzXCI6ODd9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcblxudmFyIExlc3NFcnJvciA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gTGVzc0Vycm9yKGUsIGltcG9ydE1hbmFnZXIsIGN1cnJlbnRGaWxlbmFtZSkge1xuXG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcblxuICAgIHZhciBmaWxlbmFtZSA9IGUuZmlsZW5hbWUgfHwgY3VycmVudEZpbGVuYW1lO1xuXG4gICAgaWYgKGltcG9ydE1hbmFnZXIgJiYgZmlsZW5hbWUpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gaW1wb3J0TWFuYWdlci5jb250ZW50c1tmaWxlbmFtZV0sXG4gICAgICAgICAgICBsb2MgPSB1dGlscy5nZXRMb2NhdGlvbihlLmluZGV4LCBpbnB1dCksXG4gICAgICAgICAgICBsaW5lID0gbG9jLmxpbmUsXG4gICAgICAgICAgICBjb2wgID0gbG9jLmNvbHVtbixcbiAgICAgICAgICAgIGNhbGxMaW5lID0gZS5jYWxsICYmIHV0aWxzLmdldExvY2F0aW9uKGUuY2FsbCwgaW5wdXQpLmxpbmUsXG4gICAgICAgICAgICBsaW5lcyA9IGlucHV0LnNwbGl0KCdcXG4nKTtcblxuICAgICAgICB0aGlzLnR5cGUgPSBlLnR5cGUgfHwgJ1N5bnRheCc7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGUuaW5kZXg7XG4gICAgICAgIHRoaXMubGluZSA9IHR5cGVvZiBsaW5lID09PSAnbnVtYmVyJyA/IGxpbmUgKyAxIDogbnVsbDtcbiAgICAgICAgdGhpcy5jYWxsTGluZSA9IGNhbGxMaW5lICsgMTtcbiAgICAgICAgdGhpcy5jYWxsRXh0cmFjdCA9IGxpbmVzW2NhbGxMaW5lXTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2w7XG4gICAgICAgIHRoaXMuZXh0cmFjdCA9IFtcbiAgICAgICAgICAgIGxpbmVzW2xpbmUgLSAxXSxcbiAgICAgICAgICAgIGxpbmVzW2xpbmVdLFxuICAgICAgICAgICAgbGluZXNbbGluZSArIDFdXG4gICAgICAgIF07XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZSA9IGUubWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gZS5zdGFjaztcbn07XG5cbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgRiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIEYucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuICAgIExlc3NFcnJvci5wcm90b3R5cGUgPSBuZXcgRigpO1xufSBlbHNlIHtcbiAgICBMZXNzRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xufVxuXG5MZXNzRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGVzc0Vycm9yO1xuXG59LHtcIi4vdXRpbHNcIjo4M31dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVycm9yOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KFwiZXJyb3JcIiwgbXNnKTtcbiAgICB9LFxuICAgIHdhcm46IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICB0aGlzLl9maXJlRXZlbnQoXCJ3YXJuXCIsIG1zZyk7XG4gICAgfSxcbiAgICBpbmZvOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KFwiaW5mb1wiLCBtc2cpO1xuICAgIH0sXG4gICAgZGVidWc6IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICB0aGlzLl9maXJlRXZlbnQoXCJkZWJ1Z1wiLCBtc2cpO1xuICAgIH0sXG4gICAgYWRkTGlzdGVuZXI6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVyc1tpXSA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgX2ZpcmVFdmVudDogZnVuY3Rpb24odHlwZSwgbXNnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbG9nRnVuY3Rpb24gPSB0aGlzLl9saXN0ZW5lcnNbaV1bdHlwZV07XG4gICAgICAgICAgICBpZiAobG9nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBfbGlzdGVuZXJzOiBbXVxufTtcblxufSx7fV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIExlc3NFcnJvciA9IHJlcXVpcmUoJy4vbGVzcy1lcnJvcicpLFxuICAgIHRyYW5zZm9ybVRyZWUgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm0tdHJlZVwiKSxcbiAgICBsb2dnZXIgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oU291cmNlTWFwQnVpbGRlcikge1xuICAgIHZhciBQYXJzZVRyZWUgPSBmdW5jdGlvbihyb290LCBpbXBvcnRzKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuaW1wb3J0cyA9IGltcG9ydHM7XG4gICAgfTtcblxuICAgIFBhcnNlVHJlZS5wcm90b3R5cGUudG9DU1MgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBldmFsZFJvb3QsIHJlc3VsdCA9IHt9LCBzb3VyY2VNYXBCdWlsZGVyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXZhbGRSb290ID0gdHJhbnNmb3JtVHJlZSh0aGlzLnJvb3QsIG9wdGlvbnMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTGVzc0Vycm9yKGUsIHRoaXMuaW1wb3J0cyk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNvbXByZXNzID0gQm9vbGVhbihvcHRpb25zLmNvbXByZXNzKTtcbiAgICAgICAgICAgIGlmIChjb21wcmVzcykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiVGhlIGNvbXByZXNzIG9wdGlvbiBoYXMgYmVlbiBkZXByZWNhdGVkLiBXZSByZWNvbW1lbmQgeW91IHVzZSBhIGRlZGljYXRlZCBjc3MgbWluaWZpZXIsIGZvciBpbnN0YW5jZSBzZWUgbGVzcy1wbHVnaW4tY2xlYW4tY3NzLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvQ1NTT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBjb21wcmVzczogY29tcHJlc3MsXG4gICAgICAgICAgICAgICAgZHVtcExpbmVOdW1iZXJzOiBvcHRpb25zLmR1bXBMaW5lTnVtYmVycyxcbiAgICAgICAgICAgICAgICBzdHJpY3RVbml0czogQm9vbGVhbihvcHRpb25zLnN0cmljdFVuaXRzKSxcbiAgICAgICAgICAgICAgICBudW1QcmVjaXNpb246IDh9O1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2VNYXApIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBCdWlsZGVyID0gbmV3IFNvdXJjZU1hcEJ1aWxkZXIob3B0aW9ucy5zb3VyY2VNYXApO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jc3MgPSBzb3VyY2VNYXBCdWlsZGVyLnRvQ1NTKGV2YWxkUm9vdCwgdG9DU1NPcHRpb25zLCB0aGlzLmltcG9ydHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY3NzID0gZXZhbGRSb290LnRvQ1NTKHRvQ1NTT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBMZXNzRXJyb3IoZSwgdGhpcy5pbXBvcnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnBsdWdpbk1hbmFnZXIpIHtcbiAgICAgICAgICAgIHZhciBwb3N0UHJvY2Vzc29ycyA9IG9wdGlvbnMucGx1Z2luTWFuYWdlci5nZXRQb3N0UHJvY2Vzc29ycygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0UHJvY2Vzc29ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jc3MgPSBwb3N0UHJvY2Vzc29yc1tpXS5wcm9jZXNzKHJlc3VsdC5jc3MsIHsgc291cmNlTWFwOiBzb3VyY2VNYXBCdWlsZGVyLCBvcHRpb25zOiBvcHRpb25zLCBpbXBvcnRzOiB0aGlzLmltcG9ydHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlTWFwKSB7XG4gICAgICAgICAgICByZXN1bHQubWFwID0gc291cmNlTWFwQnVpbGRlci5nZXRFeHRlcm5hbFNvdXJjZU1hcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmltcG9ydHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgZmlsZSBpbiB0aGlzLmltcG9ydHMuZmlsZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmltcG9ydHMuZmlsZXMuaGFzT3duUHJvcGVydHkoZmlsZSkgJiYgZmlsZSAhPT0gdGhpcy5pbXBvcnRzLnJvb3RGaWxlbmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5pbXBvcnRzLnB1c2goZmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZVRyZWU7XG59O1xuXG59LHtcIi4vbGVzcy1lcnJvclwiOjMyLFwiLi9sb2dnZXJcIjozMyxcIi4vdHJhbnNmb3JtLXRyZWVcIjo0NH1dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBQcm9taXNlQ29uc3RydWN0b3IsXG4gICAgY29udGV4dHMgPSByZXF1aXJlKFwiLi9jb250ZXh0c1wiKSxcbiAgICBQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlci9wYXJzZXInKSxcbiAgICBQbHVnaW5NYW5hZ2VyID0gcmVxdWlyZSgnLi9wbHVnaW4tbWFuYWdlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVudmlyb25tZW50LCBQYXJzZVRyZWUsIEltcG9ydE1hbmFnZXIpIHtcbiAgICB2YXIgcGFyc2UgPSBmdW5jdGlvbiAoaW5wdXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKCFQcm9taXNlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlQ29uc3RydWN0b3IgPSB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlKCdwcm9taXNlJykgOiBQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHBhcnNlLmNhbGwoc2VsZiwgaW5wdXQsIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0LFxuICAgICAgICAgICAgICAgIHJvb3RGaWxlSW5mbyxcbiAgICAgICAgICAgICAgICBwbHVnaW5NYW5hZ2VyID0gbmV3IFBsdWdpbk1hbmFnZXIodGhpcyk7XG5cbiAgICAgICAgICAgIHBsdWdpbk1hbmFnZXIuYWRkUGx1Z2lucyhvcHRpb25zLnBsdWdpbnMpO1xuICAgICAgICAgICAgb3B0aW9ucy5wbHVnaW5NYW5hZ2VyID0gcGx1Z2luTWFuYWdlcjtcblxuICAgICAgICAgICAgY29udGV4dCA9IG5ldyBjb250ZXh0cy5QYXJzZShvcHRpb25zKTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucm9vdEZpbGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgcm9vdEZpbGVJbmZvID0gb3B0aW9ucy5yb290RmlsZUluZm87XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IG9wdGlvbnMuZmlsZW5hbWUgfHwgXCJpbnB1dFwiO1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeVBhdGggPSBmaWxlbmFtZS5yZXBsYWNlKC9bXlxcL1xcXFxdKiQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICByb290RmlsZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVVcmxzOiBjb250ZXh0LnJlbGF0aXZlVXJscyxcbiAgICAgICAgICAgICAgICAgICAgcm9vdHBhdGg6IGNvbnRleHQucm9vdHBhdGggfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERpcmVjdG9yeTogZW50cnlQYXRoLFxuICAgICAgICAgICAgICAgICAgICBlbnRyeVBhdGg6IGVudHJ5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcm9vdEZpbGVuYW1lOiBmaWxlbmFtZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gYWRkIGluIGEgbWlzc2luZyB0cmFpbGluZyBzbGFzaFxuICAgICAgICAgICAgICAgIGlmIChyb290RmlsZUluZm8ucm9vdHBhdGggJiYgcm9vdEZpbGVJbmZvLnJvb3RwYXRoLnNsaWNlKC0xKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdEZpbGVJbmZvLnJvb3RwYXRoICs9IFwiL1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGltcG9ydHMgPSBuZXcgSW1wb3J0TWFuYWdlcihjb250ZXh0LCByb290RmlsZUluZm8pO1xuXG4gICAgICAgICAgICBuZXcgUGFyc2VyKGNvbnRleHQsIGltcG9ydHMsIHJvb3RGaWxlSW5mbylcbiAgICAgICAgICAgICAgICAucGFyc2UoaW5wdXQsIGZ1bmN0aW9uIChlLCByb290KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUpIHsgcmV0dXJuIGNhbGxiYWNrKGUpOyB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcm9vdCwgaW1wb3J0cywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHBhcnNlO1xufTtcblxufSx7XCIuL2NvbnRleHRzXCI6MTEsXCIuL3BhcnNlci9wYXJzZXJcIjozOCxcIi4vcGx1Z2luLW1hbmFnZXJcIjozOSxcInByb21pc2VcIjp1bmRlZmluZWR9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBTcGxpdCB0aGUgaW5wdXQgaW50byBjaHVua3MuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgZmFpbCkge1xuICAgIHZhciBsZW4gPSBpbnB1dC5sZW5ndGgsIGxldmVsID0gMCwgcGFyZW5MZXZlbCA9IDAsXG4gICAgICAgIGxhc3RPcGVuaW5nLCBsYXN0T3BlbmluZ1BhcmVuLCBsYXN0TXVsdGlDb21tZW50LCBsYXN0TXVsdGlDb21tZW50RW5kQnJhY2UsXG4gICAgICAgIGNodW5rcyA9IFtdLCBlbWl0RnJvbSA9IDAsXG4gICAgICAgIGNodW5rZXJDdXJyZW50SW5kZXgsIGN1cnJlbnRDaHVua1N0YXJ0SW5kZXgsIGNjLCBjYzIsIG1hdGNoZWQ7XG5cbiAgICBmdW5jdGlvbiBlbWl0Q2h1bmsoZm9yY2UpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNodW5rZXJDdXJyZW50SW5kZXggLSBlbWl0RnJvbTtcbiAgICAgICAgaWYgKCgobGVuIDwgNTEyKSAmJiAhZm9yY2UpIHx8ICFsZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjaHVua3MucHVzaChpbnB1dC5zbGljZShlbWl0RnJvbSwgY2h1bmtlckN1cnJlbnRJbmRleCArIDEpKTtcbiAgICAgICAgZW1pdEZyb20gPSBjaHVua2VyQ3VycmVudEluZGV4ICsgMTtcbiAgICB9XG5cbiAgICBmb3IgKGNodW5rZXJDdXJyZW50SW5kZXggPSAwOyBjaHVua2VyQ3VycmVudEluZGV4IDwgbGVuOyBjaHVua2VyQ3VycmVudEluZGV4KyspIHtcbiAgICAgICAgY2MgPSBpbnB1dC5jaGFyQ29kZUF0KGNodW5rZXJDdXJyZW50SW5kZXgpO1xuICAgICAgICBpZiAoKChjYyA+PSA5NykgJiYgKGNjIDw9IDEyMikpIHx8IChjYyA8IDM0KSkge1xuICAgICAgICAgICAgLy8gYS16IG9yIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChjYykge1xuICAgICAgICAgICAgY2FzZSA0MDogICAgICAgICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgICAgICAgICAgcGFyZW5MZXZlbCsrO1xuICAgICAgICAgICAgICAgIGxhc3RPcGVuaW5nUGFyZW4gPSBjaHVua2VyQ3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSA0MTogICAgICAgICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgICAgICAgICAgaWYgKC0tcGFyZW5MZXZlbCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoXCJtaXNzaW5nIG9wZW5pbmcgYChgXCIsIGNodW5rZXJDdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgNTk6ICAgICAgICAgICAgICAgICAgICAgICAgLy8gO1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW5MZXZlbCkgeyBlbWl0Q2h1bmsoKTsgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSAxMjM6ICAgICAgICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICAgICAgICBsYXN0T3BlbmluZyA9IGNodW5rZXJDdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIDEyNTogICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAoLS1sZXZlbCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoXCJtaXNzaW5nIG9wZW5pbmcgYHtgXCIsIGNodW5rZXJDdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWxldmVsICYmICFwYXJlbkxldmVsKSB7IGVtaXRDaHVuaygpOyB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIDkyOiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFxcXG4gICAgICAgICAgICAgICAgaWYgKGNodW5rZXJDdXJyZW50SW5kZXggPCBsZW4gLSAxKSB7IGNodW5rZXJDdXJyZW50SW5kZXgrKzsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbChcInVuZXNjYXBlZCBgXFxcXGBcIiwgY2h1bmtlckN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgIGNhc2UgOTY6ICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCIsICcgYW5kIGBcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gMDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmtTdGFydEluZGV4ID0gY2h1bmtlckN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICBmb3IgKGNodW5rZXJDdXJyZW50SW5kZXggPSBjaHVua2VyQ3VycmVudEluZGV4ICsgMTsgY2h1bmtlckN1cnJlbnRJbmRleCA8IGxlbjsgY2h1bmtlckN1cnJlbnRJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNjMiA9IGlucHV0LmNoYXJDb2RlQXQoY2h1bmtlckN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYzIgPiA5NikgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2MyID09IGNjKSB7IG1hdGNoZWQgPSAxOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2MyID09IDkyKSB7ICAgICAgICAvLyBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rZXJDdXJyZW50SW5kZXggPT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKFwidW5lc2NhcGVkIGBcXFxcYFwiLCBjaHVua2VyQ3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rZXJDdXJyZW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZCkgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKFwidW5tYXRjaGVkIGBcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2MpICsgXCJgXCIsIGN1cnJlbnRDaHVua1N0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgY2FzZSA0NzogICAgICAgICAgICAgICAgICAgICAgICAvLyAvLCBjaGVjayBmb3IgY29tbWVudFxuICAgICAgICAgICAgICAgIGlmIChwYXJlbkxldmVsIHx8IChjaHVua2VyQ3VycmVudEluZGV4ID09IGxlbiAtIDEpKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgY2MyID0gaW5wdXQuY2hhckNvZGVBdChjaHVua2VyQ3VycmVudEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGNjMiA9PSA0Nykge1xuICAgICAgICAgICAgICAgICAgICAvLyAvLywgZmluZCBsbmZlZWRcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjaHVua2VyQ3VycmVudEluZGV4ID0gY2h1bmtlckN1cnJlbnRJbmRleCArIDI7IGNodW5rZXJDdXJyZW50SW5kZXggPCBsZW47IGNodW5rZXJDdXJyZW50SW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2MyID0gaW5wdXQuY2hhckNvZGVBdChjaHVua2VyQ3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY2MyIDw9IDEzKSAmJiAoKGNjMiA9PSAxMCkgfHwgKGNjMiA9PSAxMykpKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNjMiA9PSA0Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyAvKiwgZmluZCAqL1xuICAgICAgICAgICAgICAgICAgICBsYXN0TXVsdGlDb21tZW50ID0gY3VycmVudENodW5rU3RhcnRJbmRleCA9IGNodW5rZXJDdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY2h1bmtlckN1cnJlbnRJbmRleCA9IGNodW5rZXJDdXJyZW50SW5kZXggKyAyOyBjaHVua2VyQ3VycmVudEluZGV4IDwgbGVuIC0gMTsgY2h1bmtlckN1cnJlbnRJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYzIgPSBpbnB1dC5jaGFyQ29kZUF0KGNodW5rZXJDdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNjMiA9PSAxMjUpIHsgbGFzdE11bHRpQ29tbWVudEVuZEJyYWNlID0gY2h1bmtlckN1cnJlbnRJbmRleDsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNjMiAhPSA0MikgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoY2h1bmtlckN1cnJlbnRJbmRleCArIDEpID09IDQ3KSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rZXJDdXJyZW50SW5kZXggPT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoXCJtaXNzaW5nIGNsb3NpbmcgYCovYFwiLCBjdXJyZW50Q2h1bmtTdGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaHVua2VyQ3VycmVudEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSA0MjogICAgICAgICAgICAgICAgICAgICAgIC8vICosIGNoZWNrIGZvciB1bm1hdGNoZWQgKi9cbiAgICAgICAgICAgICAgICBpZiAoKGNodW5rZXJDdXJyZW50SW5kZXggPCBsZW4gLSAxKSAmJiAoaW5wdXQuY2hhckNvZGVBdChjaHVua2VyQ3VycmVudEluZGV4ICsgMSkgPT0gNDcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKFwidW5tYXRjaGVkIGAvKmBcIiwgY2h1bmtlckN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxldmVsICE9PSAwKSB7XG4gICAgICAgIGlmICgobGFzdE11bHRpQ29tbWVudCA+IGxhc3RPcGVuaW5nKSAmJiAobGFzdE11bHRpQ29tbWVudEVuZEJyYWNlID4gbGFzdE11bHRpQ29tbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKFwibWlzc2luZyBjbG9zaW5nIGB9YCBvciBgKi9gXCIsIGxhc3RPcGVuaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKFwibWlzc2luZyBjbG9zaW5nIGB9YFwiLCBsYXN0T3BlbmluZyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcmVuTGV2ZWwgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoXCJtaXNzaW5nIGNsb3NpbmcgYClgXCIsIGxhc3RPcGVuaW5nUGFyZW4pO1xuICAgIH1cblxuICAgIGVtaXRDaHVuayh0cnVlKTtcbiAgICByZXR1cm4gY2h1bmtzO1xufTtcblxufSx7fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGNodW5rZXIgPSByZXF1aXJlKCcuL2NodW5rZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5wdXQsICAgICAgIC8vIExlU1MgaW5wdXQgc3RyaW5nXG4gICAgICAgIGosICAgICAgICAgICAvLyBjdXJyZW50IGNodW5rXG4gICAgICAgIHNhdmVTdGFjayA9IFtdLCAgIC8vIGhvbGRzIHN0YXRlIGZvciBiYWNrdHJhY2tpbmdcbiAgICAgICAgZnVydGhlc3QsICAgIC8vIGZ1cnRoZXN0IGluZGV4IHRoZSBwYXJzZXIgaGFzIGdvbmUgdG9cbiAgICAgICAgZnVydGhlc3RQb3NzaWJsZUVycm9yTWVzc2FnZSwvLyBpZiB0aGlzIGlzIGZ1cnRoZXN0IHdlIGdvdCB0bywgdGhpcyBpcyB0aGUgcHJvYmFibHkgY2F1c2VcbiAgICAgICAgY2h1bmtzLCAgICAgIC8vIGNodW5raWZpZWQgaW5wdXRcbiAgICAgICAgY3VycmVudCwgICAgIC8vIGN1cnJlbnQgY2h1bmtcbiAgICAgICAgY3VycmVudFBvcywgIC8vIGluZGV4IG9mIGN1cnJlbnQgY2h1bmssIGluIGBpbnB1dGBcbiAgICAgICAgcGFyc2VySW5wdXQgPSB7fTtcblxuICAgIHZhciBDSEFSQ09ERV9TUEFDRSA9IDMyLFxuICAgICAgICBDSEFSQ09ERV9UQUIgPSA5LFxuICAgICAgICBDSEFSQ09ERV9MRiA9IDEwLFxuICAgICAgICBDSEFSQ09ERV9DUiA9IDEzLFxuICAgICAgICBDSEFSQ09ERV9QTFVTID0gNDMsXG4gICAgICAgIENIQVJDT0RFX0NPTU1BID0gNDQsXG4gICAgICAgIENIQVJDT0RFX0ZPUldBUkRfU0xBU0ggPSA0NyxcbiAgICAgICAgQ0hBUkNPREVfOSA9IDU3O1xuXG4gICAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UobGVuZ3RoKSB7XG4gICAgICAgIHZhciBvbGRpID0gcGFyc2VySW5wdXQuaSwgb2xkaiA9IGosXG4gICAgICAgICAgICBjdXJyID0gcGFyc2VySW5wdXQuaSAtIGN1cnJlbnRQb3MsXG4gICAgICAgICAgICBlbmRJbmRleCA9IHBhcnNlcklucHV0LmkgKyBjdXJyZW50Lmxlbmd0aCAtIGN1cnIsXG4gICAgICAgICAgICBtZW0gPSAocGFyc2VySW5wdXQuaSArPSBsZW5ndGgpLFxuICAgICAgICAgICAgaW5wID0gaW5wdXQsXG4gICAgICAgICAgICBjLCBuZXh0Q2hhciwgY29tbWVudDtcblxuICAgICAgICBmb3IgKDsgcGFyc2VySW5wdXQuaSA8IGVuZEluZGV4OyBwYXJzZXJJbnB1dC5pKyspIHtcbiAgICAgICAgICAgIGMgPSBpbnAuY2hhckNvZGVBdChwYXJzZXJJbnB1dC5pKTtcblxuICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmF1dG9Db21tZW50QWJzb3JiICYmIGMgPT09IENIQVJDT0RFX0ZPUldBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICBuZXh0Q2hhciA9IGlucC5jaGFyQXQocGFyc2VySW5wdXQuaSArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSB7aW5kZXg6IHBhcnNlcklucHV0LmksIGlzTGluZUNvbW1lbnQ6IHRydWV9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dE5ld0xpbmUgPSBpbnAuaW5kZXhPZihcIlxcblwiLCBwYXJzZXJJbnB1dC5pICsgMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0TmV3TGluZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROZXdMaW5lID0gZW5kSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuaSA9IG5leHROZXdMaW5lO1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50LnRleHQgPSBpbnAuc3Vic3RyKGNvbW1lbnQuaW5kZXgsIHBhcnNlcklucHV0LmkgLSBjb21tZW50LmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuY29tbWVudFN0b3JlLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFN0YXJTbGFzaCA9IGlucC5pbmRleE9mKFwiKi9cIiwgcGFyc2VySW5wdXQuaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFN0YXJTbGFzaCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBwYXJzZXJJbnB1dC5pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGlucC5zdWJzdHIocGFyc2VySW5wdXQuaSwgbmV4dFN0YXJTbGFzaCArIDIgLSBwYXJzZXJJbnB1dC5pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xpbmVDb21tZW50OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkgKz0gY29tbWVudC50ZXh0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGMgIT09IENIQVJDT0RFX1NQQUNFKSAmJiAoYyAhPT0gQ0hBUkNPREVfTEYpICYmIChjICE9PSBDSEFSQ09ERV9UQUIpICYmIChjICE9PSBDSEFSQ09ERV9DUikpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNsaWNlKGxlbmd0aCArIHBhcnNlcklucHV0LmkgLSBtZW0gKyBjdXJyKTtcbiAgICAgICAgY3VycmVudFBvcyA9IHBhcnNlcklucHV0Lmk7XG5cbiAgICAgICAgaWYgKCFjdXJyZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGogPCBjaHVua3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjaHVua3NbKytqXTtcbiAgICAgICAgICAgICAgICBza2lwV2hpdGVzcGFjZSgwKTsgLy8gc2tpcCBzcGFjZSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgY2h1bmtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gdGhpbmdzIGNoYW5nZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlcklucHV0LmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvbGRpICE9PSBwYXJzZXJJbnB1dC5pIHx8IG9sZGogIT09IGo7XG4gICAgfVxuXG4gICAgcGFyc2VySW5wdXQuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjdXJyZW50UG9zID0gcGFyc2VySW5wdXQuaTtcbiAgICAgICAgc2F2ZVN0YWNrLnB1c2goIHsgY3VycmVudDogY3VycmVudCwgaTogcGFyc2VySW5wdXQuaSwgajogaiB9KTtcbiAgICB9O1xuICAgIHBhcnNlcklucHV0LnJlc3RvcmUgPSBmdW5jdGlvbihwb3NzaWJsZUVycm9yTWVzc2FnZSkge1xuXG4gICAgICAgIGlmIChwYXJzZXJJbnB1dC5pID4gZnVydGhlc3QgfHwgKHBhcnNlcklucHV0LmkgPT09IGZ1cnRoZXN0ICYmIHBvc3NpYmxlRXJyb3JNZXNzYWdlICYmICFmdXJ0aGVzdFBvc3NpYmxlRXJyb3JNZXNzYWdlKSkge1xuICAgICAgICAgICAgZnVydGhlc3QgPSBwYXJzZXJJbnB1dC5pO1xuICAgICAgICAgICAgZnVydGhlc3RQb3NzaWJsZUVycm9yTWVzc2FnZSA9IHBvc3NpYmxlRXJyb3JNZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IHNhdmVTdGFjay5wb3AoKTtcbiAgICAgICAgY3VycmVudCA9IHN0YXRlLmN1cnJlbnQ7XG4gICAgICAgIGN1cnJlbnRQb3MgPSBwYXJzZXJJbnB1dC5pID0gc3RhdGUuaTtcbiAgICAgICAgaiA9IHN0YXRlLmo7XG4gICAgfTtcbiAgICBwYXJzZXJJbnB1dC5mb3JnZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2F2ZVN0YWNrLnBvcCgpO1xuICAgIH07XG4gICAgcGFyc2VySW5wdXQuaXNXaGl0ZXNwYWNlID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICB2YXIgcG9zID0gcGFyc2VySW5wdXQuaSArIChvZmZzZXQgfHwgMCksXG4gICAgICAgICAgICBjb2RlID0gaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICByZXR1cm4gKGNvZGUgPT09IENIQVJDT0RFX1NQQUNFIHx8IGNvZGUgPT09IENIQVJDT0RFX0NSIHx8IGNvZGUgPT09IENIQVJDT0RFX1RBQiB8fCBjb2RlID09PSBDSEFSQ09ERV9MRik7XG4gICAgfTtcblxuICAgIC8vIFNwZWNpYWxpemF0aW9uIG9mICQodG9rKVxuICAgIHBhcnNlcklucHV0LiRyZSA9IGZ1bmN0aW9uKHRvaykge1xuICAgICAgICBpZiAocGFyc2VySW5wdXQuaSA+IGN1cnJlbnRQb3MpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNsaWNlKHBhcnNlcklucHV0LmkgLSBjdXJyZW50UG9zKTtcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBwYXJzZXJJbnB1dC5pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG0gPSB0b2suZXhlYyhjdXJyZW50KTtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNraXBXaGl0ZXNwYWNlKG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtLmxlbmd0aCA9PT0gMSA/IG1bMF0gOiBtO1xuICAgIH07XG5cbiAgICBwYXJzZXJJbnB1dC4kY2hhciA9IGZ1bmN0aW9uKHRvaykge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckF0KHBhcnNlcklucHV0LmkpICE9PSB0b2spIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHNraXBXaGl0ZXNwYWNlKDEpO1xuICAgICAgICByZXR1cm4gdG9rO1xuICAgIH07XG5cbiAgICBwYXJzZXJJbnB1dC4kc3RyID0gZnVuY3Rpb24odG9rKSB7XG4gICAgICAgIHZhciB0b2tMZW5ndGggPSB0b2subGVuZ3RoO1xuXG4gICAgICAgIC8vIGh0dHBzOi8vanNwZXJmLmNvbS9zdHJpbmctc3RhcnRzd2l0aC8yMVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckF0KHBhcnNlcklucHV0LmkgKyBpKSAhPT0gdG9rLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2tpcFdoaXRlc3BhY2UodG9rTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRvaztcbiAgICB9O1xuXG4gICAgcGFyc2VySW5wdXQuJHF1b3RlZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzdGFydENoYXIgPSBpbnB1dC5jaGFyQXQocGFyc2VySW5wdXQuaSk7XG4gICAgICAgIGlmIChzdGFydENoYXIgIT09IFwiJ1wiICYmIHN0YXJ0Q2hhciAhPT0gJ1wiJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGgsXG4gICAgICAgICAgICBjdXJyZW50UG9zaXRpb24gPSBwYXJzZXJJbnB1dC5pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpICsgY3VycmVudFBvc2l0aW9uIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IGlucHV0LmNoYXJBdChpICsgY3VycmVudFBvc2l0aW9uKTtcbiAgICAgICAgICAgIHN3aXRjaChuZXh0Q2hhcikge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzdGFydENoYXI6XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHIgPSBpbnB1dC5zdWJzdHIoY3VycmVudFBvc2l0aW9uLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHNraXBXaGl0ZXNwYWNlKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwYXJzZXJJbnB1dC5hdXRvQ29tbWVudEFic29yYiA9IHRydWU7XG4gICAgcGFyc2VySW5wdXQuY29tbWVudFN0b3JlID0gW107XG4gICAgcGFyc2VySW5wdXQuZmluaXNoZWQgPSBmYWxzZTtcblxuICAgIC8vIFNhbWUgYXMgJCgpLCBidXQgZG9uJ3QgY2hhbmdlIHRoZSBzdGF0ZSBvZiB0aGUgcGFyc2VyLFxuICAgIC8vIGp1c3QgcmV0dXJuIHRoZSBtYXRjaC5cbiAgICBwYXJzZXJJbnB1dC5wZWVrID0gZnVuY3Rpb24odG9rKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL3N0cmluZy1zdGFydHN3aXRoLzIxXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQXQocGFyc2VySW5wdXQuaSArIGkpICE9PSB0b2suY2hhckF0KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0b2sudGVzdChjdXJyZW50KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTcGVjaWFsaXphdGlvbiBvZiBwZWVrKClcbiAgICAvLyBUT0RPIHJlbW92ZSBvciBjaGFuZ2Ugc29tZSBjdXJyZW50Q2hhciBjYWxscyB0byBwZWVrQ2hhclxuICAgIHBhcnNlcklucHV0LnBlZWtDaGFyID0gZnVuY3Rpb24odG9rKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5jaGFyQXQocGFyc2VySW5wdXQuaSkgPT09IHRvaztcbiAgICB9O1xuXG4gICAgcGFyc2VySW5wdXQuY3VycmVudENoYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LmNoYXJBdChwYXJzZXJJbnB1dC5pKTtcbiAgICB9O1xuXG4gICAgcGFyc2VySW5wdXQuZ2V0SW5wdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH07XG5cbiAgICBwYXJzZXJJbnB1dC5wZWVrTm90TnVtZXJpYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYyA9IGlucHV0LmNoYXJDb2RlQXQocGFyc2VySW5wdXQuaSk7XG4gICAgICAgIC8vSXMgdGhlIGZpcnN0IGNoYXIgb2YgdGhlIGRpbWVuc2lvbiAwLTksICcuJywgJysnIG9yICctJ1xuICAgICAgICByZXR1cm4gKGMgPiBDSEFSQ09ERV85IHx8IGMgPCBDSEFSQ09ERV9QTFVTKSB8fCBjID09PSBDSEFSQ09ERV9GT1JXQVJEX1NMQVNIIHx8IGMgPT09IENIQVJDT0RFX0NPTU1BO1xuICAgIH07XG5cbiAgICBwYXJzZXJJbnB1dC5zdGFydCA9IGZ1bmN0aW9uKHN0ciwgY2h1bmtJbnB1dCwgZmFpbEZ1bmN0aW9uKSB7XG4gICAgICAgIGlucHV0ID0gc3RyO1xuICAgICAgICBwYXJzZXJJbnB1dC5pID0gaiA9IGN1cnJlbnRQb3MgPSBmdXJ0aGVzdCA9IDA7XG5cbiAgICAgICAgLy8gY2h1bmtpbmcgYXBwYXJlbnRseSBtYWtlcyB0aGluZ3MgcXVpY2tlciAoYnV0IG15IHRlc3RzIGluZGljYXRlXG4gICAgICAgIC8vIGl0IG1pZ2h0IGFjdHVhbGx5IG1ha2UgdGhpbmdzIHNsb3dlciBpbiBub2RlIGF0IGxlYXN0KVxuICAgICAgICAvLyBhbmQgaXQgaXMgYSBub24tcGVyZmVjdCBwYXJzZSAtIGl0IGNhbid0IHJlY29nbmlzZVxuICAgICAgICAvLyB1bnF1b3RlZCB1cmxzLCBtZWFuaW5nIGl0IGNhbid0IGRpc3Rpbmd1aXNoIGNvbW1lbnRzXG4gICAgICAgIC8vIG1lYW5pbmcgY29tbWVudHMgd2l0aCBxdW90ZXMgb3Ige30oKSBpbiB0aGVtIGdldCAnY291bnRlZCdcbiAgICAgICAgLy8gYW5kIHRoZW4gbGVhZCB0byBwYXJzZSBlcnJvcnMuXG4gICAgICAgIC8vIEluIGFkZGl0aW9uIGlmIHRoZSBjaHVua2luZyBjaHVua3MgaW4gdGhlIHdyb25nIHBsYWNlIHdlIG1pZ2h0XG4gICAgICAgIC8vIG5vdCBiZSBhYmxlIHRvIHBhcnNlIGEgcGFyc2VyIHN0YXRlbWVudCBpbiBvbmUgZ29cbiAgICAgICAgLy8gdGhpcyBpcyBvZmZpY2lhbGx5IGRlcHJlY2F0ZWQgYnV0IGNhbiBiZSBzd2l0Y2hlZCBvbiB2aWEgYW4gb3B0aW9uXG4gICAgICAgIC8vIGluIHRoZSBjYXNlIGl0IGNhdXNlcyB0b28gbXVjaCBwZXJmb3JtYW5jZSBpc3N1ZXMuXG4gICAgICAgIGlmIChjaHVua0lucHV0KSB7XG4gICAgICAgICAgICBjaHVua3MgPSBjaHVua2VyKHN0ciwgZmFpbEZ1bmN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNodW5rcyA9IFtzdHJdO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA9IGNodW5rc1swXTtcblxuICAgICAgICBza2lwV2hpdGVzcGFjZSgwKTtcbiAgICB9O1xuXG4gICAgcGFyc2VySW5wdXQuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtZXNzYWdlLFxuICAgICAgICAgICAgaXNGaW5pc2hlZCA9IHBhcnNlcklucHV0LmkgPj0gaW5wdXQubGVuZ3RoO1xuXG4gICAgICAgIGlmIChwYXJzZXJJbnB1dC5pIDwgZnVydGhlc3QpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBmdXJ0aGVzdFBvc3NpYmxlRXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgcGFyc2VySW5wdXQuaSA9IGZ1cnRoZXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0ZpbmlzaGVkOiBpc0ZpbmlzaGVkLFxuICAgICAgICAgICAgZnVydGhlc3Q6IHBhcnNlcklucHV0LmksXG4gICAgICAgICAgICBmdXJ0aGVzdFBvc3NpYmxlRXJyb3JNZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgZnVydGhlc3RSZWFjaGVkRW5kOiBwYXJzZXJJbnB1dC5pID49IGlucHV0Lmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBmdXJ0aGVzdENoYXI6IGlucHV0W3BhcnNlcklucHV0LmldXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHJldHVybiBwYXJzZXJJbnB1dDtcbn07XG5cbn0se1wiLi9jaHVua2VyXCI6MzZ9XSwzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTGVzc0Vycm9yID0gcmVxdWlyZSgnLi4vbGVzcy1lcnJvcicpLFxuICAgIHRyZWUgPSByZXF1aXJlKFwiLi4vdHJlZVwiKSxcbiAgICB2aXNpdG9ycyA9IHJlcXVpcmUoXCIuLi92aXNpdG9yc1wiKSxcbiAgICBnZXRQYXJzZXJJbnB1dCA9IHJlcXVpcmUoXCIuL3BhcnNlci1pbnB1dFwiKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcblxuLy9cbi8vIGxlc3MuanMgLSBwYXJzZXJcbi8vXG4vLyAgICBBIHJlbGF0aXZlbHkgc3RyYWlnaHQtZm9yd2FyZCBwcmVkaWN0aXZlIHBhcnNlci5cbi8vICAgIFRoZXJlIGlzIG5vIHRva2VuaXphdGlvbi9sZXhpbmcgc3RhZ2UsIHRoZSBpbnB1dCBpcyBwYXJzZWRcbi8vICAgIGluIG9uZSBzd2VlcC5cbi8vXG4vLyAgICBUbyBtYWtlIHRoZSBwYXJzZXIgZmFzdCBlbm91Z2ggdG8gcnVuIGluIHRoZSBicm93c2VyLCBzZXZlcmFsXG4vLyAgICBvcHRpbWl6YXRpb24gaGFkIHRvIGJlIG1hZGU6XG4vL1xuLy8gICAgLSBNYXRjaGluZyBhbmQgc2xpY2luZyBvbiBhIGh1Z2UgaW5wdXQgaXMgb2Z0ZW4gY2F1c2Ugb2Ygc2xvd2Rvd25zLlxuLy8gICAgICBUaGUgc29sdXRpb24gaXMgdG8gY2h1bmtpZnkgdGhlIGlucHV0IGludG8gc21hbGxlciBzdHJpbmdzLlxuLy8gICAgICBUaGUgY2h1bmtzIGFyZSBzdG9yZWQgaW4gdGhlIGBjaHVua3NgIHZhcixcbi8vICAgICAgYGpgIGhvbGRzIHRoZSBjdXJyZW50IGNodW5rIGluZGV4LCBhbmQgYGN1cnJlbnRQb3NgIGhvbGRzXG4vLyAgICAgIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaHVuayBpbiByZWxhdGlvbiB0byBgaW5wdXRgLlxuLy8gICAgICBUaGlzIGdpdmVzIHVzIGFuIGFsbW9zdCA0eCBzcGVlZC11cC5cbi8vXG4vLyAgICAtIEluIG1hbnkgY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gbWF0Y2ggaW5kaXZpZHVhbCB0b2tlbnM7XG4vLyAgICAgIGZvciBleGFtcGxlLCBpZiBhIHZhbHVlIGRvZXNuJ3QgaG9sZCBhbnkgdmFyaWFibGVzLCBvcGVyYXRpb25zXG4vLyAgICAgIG9yIGR5bmFtaWMgcmVmZXJlbmNlcywgdGhlIHBhcnNlciBjYW4gZWZmZWN0aXZlbHkgJ3NraXAnIGl0LFxuLy8gICAgICB0cmVhdGluZyBpdCBhcyBhIGxpdGVyYWwuXG4vLyAgICAgIEFuIGV4YW1wbGUgd291bGQgYmUgJzFweCBzb2xpZCAjMDAwJyAtIHdoaWNoIGV2YWx1YXRlcyB0byBpdHNlbGYsXG4vLyAgICAgIHdlIGRvbid0IG5lZWQgdG8ga25vdyB3aGF0IHRoZSBpbmRpdmlkdWFsIGNvbXBvbmVudHMgYXJlLlxuLy8gICAgICBUaGUgZHJhd2JhY2ssIG9mIGNvdXJzZSBpcyB0aGF0IHlvdSBkb24ndCBnZXQgdGhlIGJlbmVmaXRzIG9mXG4vLyAgICAgIHN5bnRheC1jaGVja2luZyBvbiB0aGUgQ1NTLiBUaGlzIGdpdmVzIHVzIGEgNTAlIHNwZWVkLXVwIGluIHRoZSBwYXJzZXIsXG4vLyAgICAgIGFuZCBhIHNtYWxsZXIgc3BlZWQtdXAgaW4gdGhlIGNvZGUtZ2VuLlxuLy9cbi8vXG4vLyAgICBUb2tlbiBtYXRjaGluZyBpcyBkb25lIHdpdGggdGhlIGAkYCBmdW5jdGlvbiwgd2hpY2ggZWl0aGVyIHRha2VzXG4vLyAgICBhIHRlcm1pbmFsIHN0cmluZyBvciByZWdleHAsIG9yIGEgbm9uLXRlcm1pbmFsIGZ1bmN0aW9uIHRvIGNhbGwuXG4vLyAgICBJdCBhbHNvIHRha2VzIGNhcmUgb2YgbW92aW5nIGFsbCB0aGUgaW5kaWNlcyBmb3J3YXJkcy5cbi8vYFxuLy9cbnZhciBQYXJzZXIgPSBmdW5jdGlvbiBQYXJzZXIoY29udGV4dCwgaW1wb3J0cywgZmlsZUluZm8pIHtcbiAgICB2YXIgcGFyc2VycyxcbiAgICAgICAgcGFyc2VySW5wdXQgPSBnZXRQYXJzZXJJbnB1dCgpO1xuXG4gICAgZnVuY3Rpb24gZXJyb3IobXNnLCB0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBMZXNzRXJyb3IoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcnNlcklucHV0LmksXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVJbmZvLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUgfHwgJ1N5bnRheCcsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1wb3J0c1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGVjdChhcmcsIG1zZywgaW5kZXgpIHtcbiAgICAgICAgLy8gc29tZSBvbGRlciBicm93c2VycyByZXR1cm4gdHlwZW9mICdmdW5jdGlvbicgZm9yIFJlZ0V4cFxuICAgICAgICB2YXIgcmVzdWx0ID0gKGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSA/IGFyZy5jYWxsKHBhcnNlcnMpIDogcGFyc2VySW5wdXQuJHJlKGFyZyk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IobXNnIHx8ICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJyA/IFwiZXhwZWN0ZWQgJ1wiICsgYXJnICsgXCInIGdvdCAnXCIgKyBwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpICsgXCInXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcInVuZXhwZWN0ZWQgdG9rZW5cIikpO1xuICAgIH1cblxuICAgIC8vIFNwZWNpYWxpemF0aW9uIG9mIGV4cGVjdCgpXG4gICAgZnVuY3Rpb24gZXhwZWN0Q2hhcihhcmcsIG1zZykge1xuICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoYXJnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgfVxuICAgICAgICBlcnJvcihtc2cgfHwgXCJleHBlY3RlZCAnXCIgKyBhcmcgKyBcIicgZ290ICdcIiArIHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgKyBcIidcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGVidWdJbmZvKGluZGV4KSB7XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IGZpbGVJbmZvLmZpbGVuYW1lO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lTnVtYmVyOiB1dGlscy5nZXRMb2NhdGlvbihpbmRleCwgcGFyc2VySW5wdXQuZ2V0SW5wdXQoKSkubGluZSArIDEsXG4gICAgICAgICAgICBmaWxlTmFtZTogZmlsZW5hbWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFRoZSBQYXJzZXJcbiAgICAvL1xuICAgIHJldHVybiB7XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUGFyc2UgYW4gaW5wdXQgc3RyaW5nIGludG8gYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUsXG4gICAgICAgIC8vIEBwYXJhbSBzdHIgQSBzdHJpbmcgY29udGFpbmluZyAnbGVzcycgbWFya3VwXG4gICAgICAgIC8vIEBwYXJhbSBjYWxsYmFjayBjYWxsIGBjYWxsYmFja2Agd2hlbiBkb25lLlxuICAgICAgICAvLyBAcGFyYW0gW2FkZGl0aW9uYWxEYXRhXSBBbiBvcHRpb25hbCBtYXAgd2hpY2ggY2FuIGNvbnRhaW5zIHZhcnMgLSBhIG1hcCAoa2V5LCB2YWx1ZSkgb2YgdmFyaWFibGVzIHRvIGFwcGx5XG4gICAgICAgIC8vXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyLCBjYWxsYmFjaywgYWRkaXRpb25hbERhdGEpIHtcbiAgICAgICAgICAgIHZhciByb290LCBlcnJvciA9IG51bGwsIGdsb2JhbFZhcnMsIG1vZGlmeVZhcnMsIGlnbm9yZWQsIHByZVRleHQgPSBcIlwiO1xuXG4gICAgICAgICAgICBnbG9iYWxWYXJzID0gKGFkZGl0aW9uYWxEYXRhICYmIGFkZGl0aW9uYWxEYXRhLmdsb2JhbFZhcnMpID8gUGFyc2VyLnNlcmlhbGl6ZVZhcnMoYWRkaXRpb25hbERhdGEuZ2xvYmFsVmFycykgKyAnXFxuJyA6ICcnO1xuICAgICAgICAgICAgbW9kaWZ5VmFycyA9IChhZGRpdGlvbmFsRGF0YSAmJiBhZGRpdGlvbmFsRGF0YS5tb2RpZnlWYXJzKSA/ICdcXG4nICsgUGFyc2VyLnNlcmlhbGl6ZVZhcnMoYWRkaXRpb25hbERhdGEubW9kaWZ5VmFycykgOiAnJztcblxuICAgICAgICAgICAgaWYgKGNvbnRleHQucGx1Z2luTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIHZhciBwcmVQcm9jZXNzb3JzID0gY29udGV4dC5wbHVnaW5NYW5hZ2VyLmdldFByZVByb2Nlc3NvcnMoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVByb2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gcHJlUHJvY2Vzc29yc1tpXS5wcm9jZXNzKHN0ciwgeyBjb250ZXh0OiBjb250ZXh0LCBpbXBvcnRzOiBpbXBvcnRzLCBmaWxlSW5mbzogZmlsZUluZm8gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ2xvYmFsVmFycyB8fCAoYWRkaXRpb25hbERhdGEgJiYgYWRkaXRpb25hbERhdGEuYmFubmVyKSkge1xuICAgICAgICAgICAgICAgIHByZVRleHQgPSAoKGFkZGl0aW9uYWxEYXRhICYmIGFkZGl0aW9uYWxEYXRhLmJhbm5lcikgPyBhZGRpdGlvbmFsRGF0YS5iYW5uZXIgOiBcIlwiKSArIGdsb2JhbFZhcnM7XG4gICAgICAgICAgICAgICAgaWdub3JlZCA9IGltcG9ydHMuY29udGVudHNJZ25vcmVkQ2hhcnM7XG4gICAgICAgICAgICAgICAgaWdub3JlZFtmaWxlSW5mby5maWxlbmFtZV0gPSBpZ25vcmVkW2ZpbGVJbmZvLmZpbGVuYW1lXSB8fCAwO1xuICAgICAgICAgICAgICAgIGlnbm9yZWRbZmlsZUluZm8uZmlsZW5hbWVdICs9IHByZVRleHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFxyXFxuPy9nLCAnXFxuJyk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgcG90ZW50aWFsIFVURiBCeXRlIE9yZGVyIE1hcmtcbiAgICAgICAgICAgIHN0ciA9IHByZVRleHQgKyBzdHIucmVwbGFjZSgvXlxcdUZFRkYvLCAnJykgKyBtb2RpZnlWYXJzO1xuICAgICAgICAgICAgaW1wb3J0cy5jb250ZW50c1tmaWxlSW5mby5maWxlbmFtZV0gPSBzdHI7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggdGhlIHByaW1hcnkgcnVsZS5cbiAgICAgICAgICAgIC8vIFRoZSB3aG9sZSBzeW50YXggdHJlZSBpcyBoZWxkIHVuZGVyIGEgUnVsZXNldCBub2RlLFxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgYHJvb3RgIHByb3BlcnR5IHNldCB0byB0cnVlLCBzbyBubyBge31gIGFyZVxuICAgICAgICAgICAgLy8gb3V0cHV0LiBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIGlucHV0IGlzIHBhcnNlZC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc3RhcnQoc3RyLCBjb250ZXh0LmNodW5rSW5wdXQsIGZ1bmN0aW9uIGZhaWwobXNnLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTGVzc0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQYXJzZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZUluZm8uZmlsZW5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSwgaW1wb3J0cyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByb290ID0gbmV3KHRyZWUuUnVsZXNldCkobnVsbCwgdGhpcy5wYXJzZXJzLnByaW1hcnkoKSk7XG4gICAgICAgICAgICAgICAgcm9vdC5yb290ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByb290LmZpcnN0Um9vdCA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBMZXNzRXJyb3IoZSwgaW1wb3J0cywgZmlsZUluZm8uZmlsZW5hbWUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgYGlgIGlzIHNtYWxsZXIgdGhhbiB0aGUgYGlucHV0Lmxlbmd0aCAtIDFgLFxuICAgICAgICAgICAgLy8gaXQgbWVhbnMgdGhlIHBhcnNlciB3YXNuJ3QgYWJsZSB0byBwYXJzZSB0aGUgd2hvbGVcbiAgICAgICAgICAgIC8vIHN0cmluZywgc28gd2UndmUgZ290IGEgcGFyc2luZyBlcnJvci5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBXZSB0cnkgdG8gZXh0cmFjdCBhIFxcbiBkZWxpbWl0ZWQgc3RyaW5nLFxuICAgICAgICAgICAgLy8gc2hvd2luZyB0aGUgbGluZSB3aGVyZSB0aGUgcGFyc2UgZXJyb3Igb2NjdXJyZWQuXG4gICAgICAgICAgICAvLyBXZSBzcGxpdCBpdCB1cCBpbnRvIHR3byBwYXJ0cyAodGhlIHBhcnQgd2hpY2ggcGFyc2VkLFxuICAgICAgICAgICAgLy8gYW5kIHRoZSBwYXJ0IHdoaWNoIGRpZG4ndCksIHNvIHdlIGNhbiBjb2xvciB0aGVtIGRpZmZlcmVudGx5LlxuICAgICAgICAgICAgdmFyIGVuZEluZm8gPSBwYXJzZXJJbnB1dC5lbmQoKTtcbiAgICAgICAgICAgIGlmICghZW5kSW5mby5pc0ZpbmlzaGVkKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGVuZEluZm8uZnVydGhlc3RQb3NzaWJsZUVycm9yTWVzc2FnZTtcblxuICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJVbnJlY29nbmlzZWQgaW5wdXRcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEluZm8uZnVydGhlc3RDaGFyID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIuIFBvc3NpYmx5IG1pc3Npbmcgb3BlbmluZyAneydcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmRJbmZvLmZ1cnRoZXN0Q2hhciA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiLiBQb3NzaWJseSBtaXNzaW5nIG9wZW5pbmcgJygnXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5kSW5mby5mdXJ0aGVzdFJlYWNoZWRFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIuIFBvc3NpYmx5IG1pc3Npbmcgc29tZXRoaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBMZXNzRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlBhcnNlXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBlbmRJbmZvLmZ1cnRoZXN0LFxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZUluZm8uZmlsZW5hbWVcbiAgICAgICAgICAgICAgICB9LCBpbXBvcnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZpbmlzaCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZSA9IGVycm9yIHx8IGUgfHwgaW1wb3J0cy5lcnJvcjtcblxuICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBMZXNzRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gbmV3IExlc3NFcnJvcihlLCBpbXBvcnRzLCBmaWxlSW5mby5maWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcm9vdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGNvbnRleHQucHJvY2Vzc0ltcG9ydHMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbmV3IHZpc2l0b3JzLkltcG9ydFZpc2l0b3IoaW1wb3J0cywgZmluaXNoKVxuICAgICAgICAgICAgICAgICAgICAucnVuKHJvb3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSGVyZSBpbiwgdGhlIHBhcnNpbmcgcnVsZXMvZnVuY3Rpb25zXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBiYXNpYyBzdHJ1Y3R1cmUgb2YgdGhlIHN5bnRheCB0cmVlIGdlbmVyYXRlZCBpcyBhcyBmb2xsb3dzOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgIFJ1bGVzZXQgLT4gIFJ1bGUgLT4gVmFsdWUgLT4gRXhwcmVzc2lvbiAtPiBFbnRpdHlcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSGVyZSdzIHNvbWUgTGVzcyBjb2RlOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAuY2xhc3Mge1xuICAgICAgICAvLyAgICAgIGNvbG9yOiAjZmZmO1xuICAgICAgICAvLyAgICAgIGJvcmRlcjogMXB4IHNvbGlkICMwMDA7XG4gICAgICAgIC8vICAgICAgd2lkdGg6IEB3ICsgNHB4O1xuICAgICAgICAvLyAgICAgID4gLmNoaWxkIHsuLi59XG4gICAgICAgIC8vICAgIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQW5kIGhlcmUncyB3aGF0IHRoZSBwYXJzZSB0cmVlIG1pZ2h0IGxvb2sgbGlrZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIFJ1bGVzZXQgKFNlbGVjdG9yICcuY2xhc3MnLCBbXG4gICAgICAgIC8vICAgICAgICAgUnVsZSAoXCJjb2xvclwiLCAgVmFsdWUgKFtFeHByZXNzaW9uIFtDb2xvciAjZmZmXV0pKVxuICAgICAgICAvLyAgICAgICAgIFJ1bGUgKFwiYm9yZGVyXCIsIFZhbHVlIChbRXhwcmVzc2lvbiBbRGltZW5zaW9uIDFweF1bS2V5d29yZCBcInNvbGlkXCJdW0NvbG9yICMwMDBdXSkpXG4gICAgICAgIC8vICAgICAgICAgUnVsZSAoXCJ3aWR0aFwiLCAgVmFsdWUgKFtFeHByZXNzaW9uIFtPcGVyYXRpb24gXCIgKyBcIiBbVmFyaWFibGUgXCJAd1wiXVtEaW1lbnNpb24gNHB4XV1dKSlcbiAgICAgICAgLy8gICAgICAgICBSdWxlc2V0IChTZWxlY3RvciBbRWxlbWVudCAnPicsICcuY2hpbGQnXSwgWy4uLl0pXG4gICAgICAgIC8vICAgICBdKVxuICAgICAgICAvL1xuICAgICAgICAvLyAgSW4gZ2VuZXJhbCwgbW9zdCBydWxlcyB3aWxsIHRyeSB0byBwYXJzZSBhIHRva2VuIHdpdGggdGhlIGAkcmUoKWAgZnVuY3Rpb24sIGFuZCBpZiB0aGUgcmV0dXJuXG4gICAgICAgIC8vICB2YWx1ZSBpcyB0cnVseSwgd2lsbCByZXR1cm4gYSBuZXcgbm9kZSwgb2YgdGhlIHJlbGV2YW50IHR5cGUuIFNvbWV0aW1lcywgd2UgbmVlZCB0byBjaGVja1xuICAgICAgICAvLyAgZmlyc3QsIGJlZm9yZSBwYXJzaW5nLCB0aGF0J3Mgd2hlbiB3ZSB1c2UgYHBlZWsoKWAuXG4gICAgICAgIC8vXG4gICAgICAgIHBhcnNlcnM6IHBhcnNlcnMgPSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhlIGBwcmltYXJ5YCBydWxlIGlzIHRoZSAqZW50cnkqIGFuZCAqZXhpdCogcG9pbnQgb2YgdGhlIHBhcnNlci5cbiAgICAgICAgICAgIC8vIFRoZSBydWxlcyBoZXJlIGNhbiBhcHBlYXIgYXQgYW55IGxldmVsIG9mIHRoZSBwYXJzZSB0cmVlLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSByZWN1cnNpdmUgbmF0dXJlIG9mIHRoZSBncmFtbWFyIGlzIGFuIGludGVycGxheSBiZXR3ZWVuIHRoZSBgYmxvY2tgXG4gICAgICAgICAgICAvLyBydWxlLCB3aGljaCByZXByZXNlbnRzIGB7IC4uLiB9YCwgdGhlIGBydWxlc2V0YCBydWxlLCBhbmQgdGhpcyBgcHJpbWFyeWAgcnVsZSxcbiAgICAgICAgICAgIC8vIGFzIHJlcHJlc2VudGVkIGJ5IHRoaXMgc2ltcGxpZmllZCBncmFtbWFyOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICBwcmltYXJ5ICDihpIgIChydWxlc2V0IHwgcnVsZSkrXG4gICAgICAgICAgICAvLyAgICAgcnVsZXNldCAg4oaSICBzZWxlY3RvcisgYmxvY2tcbiAgICAgICAgICAgIC8vICAgICBibG9jayAgICDihpIgICd7JyBwcmltYXJ5ICd9J1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIE9ubHkgYXQgb25lIHBvaW50IGlzIHRoZSBwcmltYXJ5IHJ1bGUgbm90IGNhbGxlZCBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gYmxvY2sgcnVsZTogYXQgdGhlIHJvb3QgbGV2ZWwuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgcHJpbWFyeTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBtaXhpbiA9IHRoaXMubWl4aW4sIHJvb3QgPSBbXSwgbm9kZTtcblxuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5jb21tZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBhbHdheXMgcHJvY2VzcyBjb21tZW50cyBiZWZvcmUgZGVjaWRpbmcgaWYgZmluaXNoZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQucGVlaygnfScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmV4dGVuZFJ1bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QgPSByb290LmNvbmNhdChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG1peGluLmRlZmluaXRpb24oKSB8fCB0aGlzLnJ1bGUoKSB8fCB0aGlzLnJ1bGVzZXQoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbWl4aW4uY2FsbCgpIHx8IHRoaXMucnVsZXNldENhbGwoKSB8fCB0aGlzLmVudGl0aWVzLmNhbGwoKSB8fCB0aGlzLmRpcmVjdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kU2VtaUNvbG9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocGFyc2VySW5wdXQuJGNoYXIoXCI7XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTZW1pQ29sb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZFNlbWlDb2xvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBjb21tZW50cyBhcmUgY29sbGVjdGVkIGJ5IHRoZSBtYWluIHBhcnNpbmcgbWVjaGFuaXNtIGFuZCB0aGVuIGFzc2lnbmVkIHRvIG5vZGVzXG4gICAgICAgICAgICAvLyB3aGVyZSB0aGUgY3VycmVudCBzdHJ1Y3R1cmUgYWxsb3dzIGl0XG4gICAgICAgICAgICBjb21tZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmNvbW1lbnRTdG9yZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkNvbW1lbnQpKGNvbW1lbnQudGV4dCwgY29tbWVudC5pc0xpbmVDb21tZW50LCBjb21tZW50LmluZGV4LCBmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEVudGl0aWVzIGFyZSB0b2tlbnMgd2hpY2ggY2FuIGJlIGZvdW5kIGluc2lkZSBhbiBFeHByZXNzaW9uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZW50aXRpZXM6IHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEEgc3RyaW5nLCB3aGljaCBzdXBwb3J0cyBlc2NhcGluZyBcIiBhbmQgJ1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgIFwibWlsa3kgd2F5XCIgJ2hlXFwncyB0aGUgb25lISdcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHF1b3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyLCBpbmRleCA9IHBhcnNlcklucHV0LmksIGlzRXNjYXBlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKFwiflwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNFc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBwYXJzZXJJbnB1dC4kcXVvdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLlF1b3RlZCkoc3RyLmNoYXJBdCgwKSwgc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMiksIGlzRXNjYXBlZCwgaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBIGNhdGNoLWFsbCB3b3JkLCBzdWNoIGFzOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgIGJsYWNrIGJvcmRlci1jb2xsYXBzZVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAga2V5d29yZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgayA9IHBhcnNlcklucHV0LiRjaGFyKFwiJVwiKSB8fCBwYXJzZXJJbnB1dC4kcmUoL15bX0EtWmEtei1dW19BLVphLXowLTktXSovKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmVlLkNvbG9yLmZyb21LZXl3b3JkKGspIHx8IG5ldyh0cmVlLktleXdvcmQpKGspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgcmdiKDI1NSwgMCwgMjU1KVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gV2UgYWxzbyB0cnkgdG8gY2F0Y2ggSUUncyBgYWxwaGEoKWAsIGJ1dCBsZXQgdGhlIGBhbHBoYWAgcGFyc2VyXG4gICAgICAgICAgICAgICAgLy8gZGVhbCB3aXRoIHRoZSBkZXRhaWxzLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgcGFyc2VkIHdpdGggdGhlIGBlbnRpdGllcy5hcmd1bWVudHNgIHBhcnNlci5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGNhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUsIG5hbWVMQywgYXJncywgYWxwaGEsIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jYXNlLWluc2Vuc2l0aXZlLXJlZ2V4LXZzLXN0cnRvbG93ZXItdGhlbi1yZWdleC8xOFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQucGVlaygvXnVybFxcKC9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwYXJzZXJJbnB1dC4kcmUoL14oW1xcdy1dK3wlfHByb2dpZDpbXFx3XFwuXSspXFwoLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmFtZSkgeyBwYXJzZXJJbnB1dC5mb3JnZXQoKTsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVbMV07XG4gICAgICAgICAgICAgICAgICAgIG5hbWVMQyA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZUxDID09PSAnYWxwaGEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IHBhcnNlcnMuYWxwaGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLmFyZ3VtZW50cygpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghIHBhcnNlcklucHV0LiRjaGFyKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoXCJDb3VsZCBub3QgcGFyc2UgY2FsbCBhcmd1bWVudHMgb3IgbWlzc2luZyAnKSdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkNhbGwpKG5hbWUsIGFyZ3MsIGluZGV4LCBmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3NTZW1pQ29sb24gPSBbXSwgYXJnc0NvbW1hID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTZW1pQ29sb25TZXBhcmF0ZWQsIHZhbHVlLCBhcmc7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IHBhcnNlcnMuZGV0YWNoZWRSdWxlc2V0KCkgfHwgdGhpcy5hc3NpZ25tZW50KCkgfHwgcGFyc2Vycy5leHByZXNzaW9uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXJnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLnZhbHVlICYmIGFyZy52YWx1ZS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXJnLnZhbHVlWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc0NvbW1hLnB1c2godmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJywnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJzsnKSB8fCBpc1NlbWlDb2xvblNlcGFyYXRlZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTZW1pQ29sb25TZXBhcmF0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcodHJlZS5WYWx1ZSkoZXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzU2VtaUNvbG9uLnB1c2godmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNTZW1pQ29sb25TZXBhcmF0ZWQgPyBhcmdzU2VtaUNvbG9uIDogYXJnc0NvbW1hO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGl0ZXJhbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24oKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xvcigpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1b3RlZCgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVuaWNvZGVEZXNjcmlwdG9yKCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIEFzc2lnbm1lbnRzIGFyZSBhcmd1bWVudCBlbnRpdGllcyBmb3IgY2FsbHMuXG4gICAgICAgICAgICAgICAgLy8gVGhleSBhcmUgcHJlc2VudCBpbiBpZSBmaWx0ZXIgcHJvcGVydGllcyBhcyBzaG93biBiZWxvdy5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICBmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYSggKm9wYWNpdHk9NTAqIClcbiAgICAgICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICAgICAgYXNzaWdubWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5LCB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZXJJbnB1dC4kcmUoL15cXHcrKD89XFxzPz0pL2kpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Vycy5lbnRpdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5Bc3NpZ25tZW50KShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHVybCgpIHRva2Vuc1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIGEgc3BlY2lmaWMgcnVsZSBmb3IgdXJscywgYmVjYXVzZSB0aGV5IGRvbid0IHJlYWxseSBiZWhhdmUgbGlrZVxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkIGZ1bmN0aW9uIGNhbGxzLiBUaGUgZGlmZmVyZW5jZSBpcyB0aGF0IHRoZSBhcmd1bWVudCBkb2Vzbid0IGhhdmVcbiAgICAgICAgICAgICAgICAvLyB0byBiZSBlbmNsb3NlZCB3aXRoaW4gYSBzdHJpbmcsIHNvIGl0IGNhbid0IGJlIHBhcnNlZCBhcyBhbiBFeHByZXNzaW9uLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdXJsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSwgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmF1dG9Db21tZW50QWJzb3JiID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kc3RyKFwidXJsKFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuYXV0b0NvbW1lbnRBYnNvcmIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnF1b3RlZCgpIHx8IHRoaXMudmFyaWFibGUoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LiRyZSgvXig/Oig/OlxcXFxbXFwoXFwpJ1wiXSl8W15cXChcXCknXCJdKSsvKSB8fCBcIlwiO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmF1dG9Db21tZW50QWJzb3JiID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBleHBlY3RDaGFyKCcpJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLlVSTCkoKHZhbHVlLnZhbHVlICE9IG51bGwgfHwgdmFsdWUgaW5zdGFuY2VvZiB0cmVlLlZhcmlhYmxlKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgOiBuZXcodHJlZS5Bbm9ueW1vdXMpKHZhbHVlKSwgaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBIFZhcmlhYmxlIGVudGl0eSwgc3VjaCBhcyBgQGZpbmtgLCBpblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgIHdpZHRoOiBAZmluayArIDJweFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIGEgZGlmZmVyZW50IHBhcnNlciBmb3IgdmFyaWFibGUgZGVmaW5pdGlvbnMsXG4gICAgICAgICAgICAgICAgLy8gc2VlIGBwYXJzZXJzLnZhcmlhYmxlYC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lLCBpbmRleCA9IHBhcnNlcklucHV0Lmk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICdAJyAmJiAobmFtZSA9IHBhcnNlcklucHV0LiRyZSgvXkBAP1tcXHctXSsvKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5WYXJpYWJsZSkobmFtZSwgaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBBIHZhcmlhYmxlIGVudGl0eSB1c2luZyB0aGUgcHJvdGVjdGl2ZSB7fSBlLmcuIEB7dmFyfVxuICAgICAgICAgICAgICAgIHZhcmlhYmxlQ3VybHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cmx5LCBpbmRleCA9IHBhcnNlcklucHV0Lmk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICdAJyAmJiAoY3VybHkgPSBwYXJzZXJJbnB1dC4kcmUoL15AXFx7KFtcXHctXSspXFx9LykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuVmFyaWFibGUpKFwiQFwiICsgY3VybHlbMV0sIGluZGV4LCBmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBIEhleGFkZWNpbWFsIGNvbG9yXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgIzRGM0MyRlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gYHJnYmAgYW5kIGBoc2xgIGNvbG9ycyBhcmUgcGFyc2VkIHRocm91Z2ggdGhlIGBlbnRpdGllcy5jYWxsYCBwYXJzZXIuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBjb2xvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmdiO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpID09PSAnIycgJiYgKHJnYiA9IHBhcnNlcklucHV0LiRyZSgvXiMoW0EtRmEtZjAtOV17Nn18W0EtRmEtZjAtOV17M30pLykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpcCBjb2xvbnMsIGJyYWNrZXRzLCB3aGl0ZXNwYWNlcyBhbmQgb3RoZXIgY2hhcmFjdGVycyB0aGF0IHNob3VsZCBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmluaXRlbHkgYmUgcGFydCBvZiBjb2xvciBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvckNhbmRpZGF0ZVN0cmluZyA9IHJnYi5pbnB1dC5tYXRjaCgvXiMoW1xcd10rKS4qLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckNhbmRpZGF0ZVN0cmluZyA9IGNvbG9yQ2FuZGlkYXRlU3RyaW5nWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2xvckNhbmRpZGF0ZVN0cmluZy5tYXRjaCgvXltBLUZhLWYwLTldKyQvKSkgeyAvLyB2ZXJpZnkgaWYgY2FuZGlkYXRlIGNvbnNpc3RzIG9ubHkgb2YgYWxsb3dlZCBIRVggY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiSW52YWxpZCBIRVggY29sb3IgY29kZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5Db2xvcikocmdiWzFdLCB1bmRlZmluZWQsICcjJyArIGNvbG9yQ2FuZGlkYXRlU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBjb2xvcktleXdvcmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXV0b0NvbW1lbnRBYnNvcmIgPSBwYXJzZXJJbnB1dC5hdXRvQ29tbWVudEFic29yYjtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuYXV0b0NvbW1lbnRBYnNvcmIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBwYXJzZXJJbnB1dC4kcmUoL15bX0EtWmEtei1dW19BLVphLXowLTktXSsvKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuYXV0b0NvbW1lbnRBYnNvcmIgPSBhdXRvQ29tbWVudEFic29yYjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHRyZWUuQ29sb3IuZnJvbUtleXdvcmQoayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuJHN0cihrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEEgRGltZW5zaW9uLCB0aGF0IGlzLCBhIG51bWJlciBhbmQgYSB1bml0XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgMC41ZW0gOTUlXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBkaW1lbnNpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LnBlZWtOb3ROdW1lcmljKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlcklucHV0LiRyZSgvXihbKy1dP1xcZCpcXC4/XFxkKykoJXxbYS16X10rKT8vaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkRpbWVuc2lvbikodmFsdWVbMV0sIHZhbHVlWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEEgdW5pY29kZSBkZXNjcmlwdG9yLCBhcyBpcyB1c2VkIGluIHVuaWNvZGUtcmFuZ2VcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFUrMD8/ICBvciBVKzAwQTEtMDBBOVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdW5pY29kZURlc2NyaXB0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVkO1xuXG4gICAgICAgICAgICAgICAgICAgIHVkID0gcGFyc2VySW5wdXQuJHJlKC9eVVxcK1swLTlhLWZBLUY/XSsoXFwtWzAtOWEtZkEtRj9dKyk/Lyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLlVuaWNvZGVEZXNjcmlwdG9yKSh1ZFswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBKYXZhU2NyaXB0IGNvZGUgdG8gYmUgZXZhbHVhdGVkXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgYHdpbmRvdy5sb2NhdGlvbi5ocmVmYFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgamF2YXNjcmlwdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIganMsIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcblxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGVzY2FwZSA9IHBhcnNlcklucHV0LiRjaGFyKFwiflwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGpzUXVvdGUgPSBwYXJzZXJJbnB1dC4kY2hhcihcImBcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqc1F1b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBqcyA9IHBhcnNlcklucHV0LiRyZSgvXlteYF0qYC8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoanMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkphdmFTY3JpcHQpKGpzLnN1YnN0cigwLCBqcy5sZW5ndGggLSAxKSwgQm9vbGVhbihlc2NhcGUpLCBpbmRleCwgZmlsZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoXCJpbnZhbGlkIGphdmFzY3JpcHQgZGVmaW5pdGlvblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhlIHZhcmlhYmxlIHBhcnQgb2YgYSB2YXJpYWJsZSBkZWZpbml0aW9uLiBVc2VkIGluIHRoZSBgcnVsZWAgcGFyc2VyXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIEBmaW5rOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHZhcmlhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuY3VycmVudENoYXIoKSA9PT0gJ0AnICYmIChuYW1lID0gcGFyc2VySW5wdXQuJHJlKC9eKEBbXFx3LV0rKVxccyo6LykpKSB7IHJldHVybiBuYW1lWzFdOyB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhlIHZhcmlhYmxlIHBhcnQgb2YgYSB2YXJpYWJsZSBkZWZpbml0aW9uLiBVc2VkIGluIHRoZSBgcnVsZWAgcGFyc2VyXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIEBmaW5rKCk7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgcnVsZXNldENhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpID09PSAnQCcgJiYgKG5hbWUgPSBwYXJzZXJJbnB1dC4kcmUoL14oQFtcXHctXSspXFwoXFxzKlxcKVxccyo7LykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5SdWxlc2V0Q2FsbChuYW1lWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gZXh0ZW5kIHN5bnRheCAtIHVzZWQgdG8gZXh0ZW5kIHNlbGVjdG9yc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGV4dGVuZDogZnVuY3Rpb24oaXNSdWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzLCBlLCBpbmRleCA9IHBhcnNlcklucHV0LmksIG9wdGlvbiwgZXh0ZW5kTGlzdCwgZXh0ZW5kO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kc3RyKGlzUnVsZSA/IFwiJjpleHRlbmQoXCIgOiBcIjpleHRlbmQoXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCEgKG9wdGlvbiA9IHBhcnNlcklucHV0LiRyZSgvXihhbGwpKD89XFxzKihcXCl8LCkpLykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5lbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gWyBlIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb24gJiYgb3B0aW9uWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcIk1pc3NpbmcgdGFyZ2V0IHNlbGVjdG9yIGZvciA6ZXh0ZW5kKCkuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZCA9IG5ldyh0cmVlLkV4dGVuZCkobmV3KHRyZWUuU2VsZWN0b3IpKGVsZW1lbnRzKSwgb3B0aW9uLCBpbmRleCwgZmlsZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kTGlzdC5wdXNoKGV4dGVuZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRMaXN0ID0gWyBleHRlbmQgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHBhcnNlcklucHV0LiRjaGFyKFwiLFwiKSk7XG5cbiAgICAgICAgICAgICAgICBleHBlY3QoL15cXCkvKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc1J1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KC9eOy8pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBleHRlbmRMaXN0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGV4dGVuZFJ1bGUgLSB1c2VkIGluIGEgcnVsZSB0byBleHRlbmQgYWxsIHRoZSBwYXJlbnQgc2VsZWN0b3JzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZXh0ZW5kUnVsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHRydWUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIE1peGluc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIG1peGluOiB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBIE1peGluIGNhbGwsIHdpdGggYW4gb3B0aW9uYWwgYXJndW1lbnQgbGlzdFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgICNtaXhpbnMgPiAuc3F1YXJlKCNmZmYpO1xuICAgICAgICAgICAgICAgIC8vICAgICAucm91bmRlZCg0cHgsIGJsYWNrKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgLmJ1dHRvbjtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFRoZSBgd2hpbGVgIGxvb3AgaXMgdGhlcmUgYmVjYXVzZSBtaXhpbnMgY2FuIGJlXG4gICAgICAgICAgICAgICAgLy8gbmFtZXNwYWNlZCwgYnV0IHdlIG9ubHkgc3VwcG9ydCB0aGUgY2hpbGQgYW5kIGRlc2NlbmRhbnRcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3RvciBmb3Igbm93LlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgY2FsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCksIGltcG9ydGFudCA9IGZhbHNlLCBpbmRleCA9IHBhcnNlcklucHV0LmksIGVsZW1JbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLCBlbGVtLCBlLCBjLCBhcmdzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzICE9PSAnLicgJiYgcyAhPT0gJyMnKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTsgLy8gc3RvcCB1cyBhYnNvcmJpbmcgcGFydCBvZiBhbiBpbnZhbGlkIHNlbGVjdG9yXG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1JbmRleCA9IHBhcnNlcklucHV0Lmk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gcGFyc2VySW5wdXQuJHJlKC9eWyMuXSg/OltcXHctXXxcXFxcKD86W0EtRmEtZjAtOV17MSw2fSA/fFteQS1GYS1mMC05XSkpKy8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gbmV3KHRyZWUuRWxlbWVudCkoYywgZSwgZWxlbUluZGV4LCBmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IFsgZWxlbSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHBhcnNlcklucHV0LiRjaGFyKCc+Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignKCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IHRoaXMuYXJncyh0cnVlKS5hcmdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdENoYXIoJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcnMuaW1wb3J0YW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2Vycy5lbmQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5taXhpbi5DYWxsKShlbGVtZW50cywgYXJncywgaW5kZXgsIGZpbGVJbmZvLCBpbXBvcnRhbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXJnczogZnVuY3Rpb24gKGlzQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW50aXRpZXMgPSBwYXJzZXJzLmVudGl0aWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZXIgPSB7IGFyZ3M6bnVsbCwgdmFyaWFkaWM6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucyA9IFtdLCBhcmdzU2VtaUNvbG9uID0gW10sIGFyZ3NDb21tYSA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTZW1pQ29sb25TZXBhcmF0ZWQsIGV4cHJlc3Npb25Db250YWluc05hbWVkLCBuYW1lLCBuYW1lTG9vcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLCBhcmcsIGV4cGFuZDtcblxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBwYXJzZXJzLmRldGFjaGVkUnVsZXNldCgpIHx8IHBhcnNlcnMuZXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJHN0cihcIi4uLlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lci52YXJpYWRpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcihcIjtcIikgJiYgIWlzU2VtaUNvbG9uU2VwYXJhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NlbWlDb2xvblNlcGFyYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlzU2VtaUNvbG9uU2VwYXJhdGVkID8gYXJnc1NlbWlDb2xvbiA6IGFyZ3NDb21tYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wdXNoKHsgdmFyaWFkaWM6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBlbnRpdGllcy52YXJpYWJsZSgpIHx8IGVudGl0aWVzLmxpdGVyYWwoKSB8fCBlbnRpdGllcy5rZXl3b3JkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVMb29wID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcudGhyb3dBd2F5Q29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcudGhyb3dBd2F5Q29tbWVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXJnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWYXJpYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcudmFsdWUgJiYgYXJnLnZhbHVlLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGFyZy52YWx1ZVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGFyZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCAmJiB2YWwgaW5zdGFuY2VvZiB0cmVlLlZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc6JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlbWlDb2xvblNlcGFyYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiQ2Fubm90IG1peCA7IGFuZCAsIGFzIGRlbGltaXRlciB0eXBlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25Db250YWluc05hbWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Vycy5kZXRhY2hlZFJ1bGVzZXQoKSB8fCBwYXJzZXJzLmV4cHJlc3Npb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJjb3VsZCBub3QgdW5kZXJzdGFuZCB2YWx1ZSBmb3IgbmFtZWQgYXJndW1lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lci5hcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVMb29wID0gKG5hbWUgPSB2YWwubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZXJJbnB1dC4kc3RyKFwiLi4uXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNDYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lci52YXJpYWRpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoXCI7XCIpICYmICFpc1NlbWlDb2xvblNlcGFyYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VtaUNvbG9uU2VwYXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpc1NlbWlDb2xvblNlcGFyYXRlZCA/IGFyZ3NTZW1pQ29sb24gOiBhcmdzQ29tbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnB1c2goeyBuYW1lOiBhcmcubmFtZSwgdmFyaWFkaWM6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0NhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVMb29wID0gdmFsLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzQ29tbWEucHVzaCh7IG5hbWU6bmFtZUxvb3AsIHZhbHVlOnZhbHVlLCBleHBhbmQ6ZXhwYW5kIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJywnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJzsnKSB8fCBpc1NlbWlDb2xvblNlcGFyYXRlZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25Db250YWluc05hbWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiQ2Fubm90IG1peCA7IGFuZCAsIGFzIGRlbGltaXRlciB0eXBlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NlbWlDb2xvblNlcGFyYXRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyh0cmVlLlZhbHVlKShleHByZXNzaW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NTZW1pQ29sb24ucHVzaCh7IG5hbWU6bmFtZSwgdmFsdWU6dmFsdWUsIGV4cGFuZDpleHBhbmQgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25Db250YWluc05hbWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuZXIuYXJncyA9IGlzU2VtaUNvbG9uU2VwYXJhdGVkID8gYXJnc1NlbWlDb2xvbiA6IGFyZ3NDb21tYTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybmVyO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBIE1peGluIGRlZmluaXRpb24sIHdpdGggYSBsaXN0IG9mIHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICAucm91bmRlZCAoQHJhZGl1czogMnB4LCBAY29sb3IpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgLi4uXG4gICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFVudGlsIHdlIGhhdmUgYSBmaW5lciBncmFpbmVkIHN0YXRlLW1hY2hpbmUsIHdlIGhhdmUgdG9cbiAgICAgICAgICAgICAgICAvLyBkbyBhIGxvb2stYWhlYWQsIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIGEgbWl4aW4gY2FsbC5cbiAgICAgICAgICAgICAgICAvLyBTZWUgdGhlIGBydWxlYCBmdW5jdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFdlIHN0YXJ0IGJ5IG1hdGNoaW5nIGAucm91bmRlZCAoYCwgYW5kIHRoZW4gcHJvY2VlZCBvbiB0b1xuICAgICAgICAgICAgICAgIC8vIHRoZSBhcmd1bWVudCBsaXN0LCB3aGljaCBoYXMgb3B0aW9uYWwgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgLy8gV2Ugc3RvcmUgdGhlIHBhcmFtZXRlcnMgaW4gYHBhcmFtc2AsIHdpdGggYSBgdmFsdWVgIGtleSxcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHZhbHVlLCBzdWNoIGFzIGluIHRoZSBjYXNlIG9mIGBAcmFkaXVzYC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIE9uY2Ugd2UndmUgZ290IG91ciBwYXJhbXMgbGlzdCwgYW5kIGEgY2xvc2luZyBgKWAsIHdlIHBhcnNlXG4gICAgICAgICAgICAgICAgLy8gdGhlIGB7Li4ufWAgYmxvY2suXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lLCBwYXJhbXMgPSBbXSwgbWF0Y2gsIHJ1bGVzZXQsIGNvbmQsIHZhcmlhZGljID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocGFyc2VySW5wdXQuY3VycmVudENoYXIoKSAhPT0gJy4nICYmIHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgIT09ICcjJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnBlZWsoL15bXntdKlxcfS8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBwYXJzZXJJbnB1dC4kcmUoL14oWyMuXSg/OltcXHctXXxcXFxcKD86W0EtRmEtZjAtOV17MSw2fSA/fFteQS1GYS1mMC05XSkpKylcXHMqXFwoLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG1hdGNoWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnSW5mbyA9IHRoaXMuYXJncyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBhcmdJbmZvLmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWRpYyA9IGFyZ0luZm8udmFyaWFkaWM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5taXhpbmNhbGwoXCJAe2F9XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9va3MgYSBiaXQgbGlrZSBhIG1peGluIGRlZmluaXRpb24uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxzb1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLm1peGluY2FsbChAYToge3J1bGU6IHNldDt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gYmUgbmljZSBhbmQgcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignKScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZShcIk1pc3NpbmcgY2xvc2luZyAnKSdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRzdHIoXCJ3aGVuXCIpKSB7IC8vIEd1YXJkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZCA9IGV4cGVjdChwYXJzZXJzLmNvbmRpdGlvbnMsICdleHBlY3RlZCBjb25kaXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXNldCA9IHBhcnNlcnMuYmxvY2soKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUubWl4aW4uRGVmaW5pdGlvbikobmFtZSwgcGFyYW1zLCBydWxlc2V0LCBjb25kLCB2YXJpYWRpYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEVudGl0aWVzIGFyZSB0aGUgc21hbGxlc3QgcmVjb2duaXplZCB0b2tlbixcbiAgICAgICAgICAgIC8vIGFuZCBjYW4gYmUgZm91bmQgaW5zaWRlIGEgcnVsZSdzIHZhbHVlLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGVudGl0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRpdGllcyA9IHRoaXMuZW50aXRpZXM7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21tZW50KCkgfHwgZW50aXRpZXMubGl0ZXJhbCgpIHx8IGVudGl0aWVzLnZhcmlhYmxlKCkgfHwgZW50aXRpZXMudXJsKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgZW50aXRpZXMuY2FsbCgpICAgIHx8IGVudGl0aWVzLmtleXdvcmQoKSAgfHwgZW50aXRpZXMuamF2YXNjcmlwdCgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEEgUnVsZSB0ZXJtaW5hdG9yLiBOb3RlIHRoYXQgd2UgdXNlIGBwZWVrKClgIHRvIGNoZWNrIGZvciAnfScsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBgYmxvY2tgIHJ1bGUgd2lsbCBiZSBleHBlY3RpbmcgaXQsIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvIG1ha2Ugc3VyZVxuICAgICAgICAgICAgLy8gaXQncyB0aGVyZSwgaWYgJzsnIHdhcyBvbWl0dGVkLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXJJbnB1dC4kY2hhcignOycpIHx8IHBhcnNlcklucHV0LnBlZWsoJ30nKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJRSdzIGFscGhhIGZ1bmN0aW9uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIGFscGhhKG9wYWNpdHk9ODgpXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgYWxwaGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jYXNlLWluc2Vuc2l0aXZlLXJlZ2V4LXZzLXN0cnRvbG93ZXItdGhlbi1yZWdleC8xOFxuICAgICAgICAgICAgICAgIGlmICghIHBhcnNlcklucHV0LiRyZSgvXm9wYWNpdHk9L2kpKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VySW5wdXQuJHJlKC9eXFxkKy8pO1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBleHBlY3QodGhpcy5lbnRpdGllcy52YXJpYWJsZSwgXCJDb3VsZCBub3QgcGFyc2UgYWxwaGFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdENoYXIoJyknKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuQWxwaGEpKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBIFNlbGVjdG9yIEVsZW1lbnRcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgZGl2XG4gICAgICAgICAgICAvLyAgICAgKyBoMVxuICAgICAgICAgICAgLy8gICAgICNzb2Nrc1xuICAgICAgICAgICAgLy8gICAgIGlucHV0W3R5cGU9XCJ0ZXh0XCJdXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRWxlbWVudHMgYXJlIHRoZSBidWlsZGluZyBibG9ja3MgZm9yIFNlbGVjdG9ycyxcbiAgICAgICAgICAgIC8vIHRoZXkgYXJlIG1hZGUgb3V0IG9mIGEgYENvbWJpbmF0b3JgIChzZWUgY29tYmluYXRvciBydWxlKSxcbiAgICAgICAgICAgIC8vIGFuZCBhbiBlbGVtZW50IG5hbWUsIHN1Y2ggYXMgYSB0YWcgYSBjbGFzcywgb3IgYCpgLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSwgYywgdiwgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xuXG4gICAgICAgICAgICAgICAgYyA9IHRoaXMuY29tYmluYXRvcigpO1xuXG4gICAgICAgICAgICAgICAgZSA9IHBhcnNlcklucHV0LiRyZSgvXig/OlxcZCtcXC5cXGQrfFxcZCspJS8pIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LiRyZSgvXig/OlsuI10/fDoqKSg/OltcXHctXXxbXlxceDAwLVxceDlmXXxcXFxcKD86W0EtRmEtZjAtOV17MSw2fSA/fFteQS1GYS1mMC05XSkpKy8pIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LiRjaGFyKCcqJykgfHwgcGFyc2VySW5wdXQuJGNoYXIoJyYnKSB8fCB0aGlzLmF0dHJpYnV0ZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LiRyZSgvXlxcKFteJigpQF0rXFwpLykgfHwgIHBhcnNlcklucHV0LiRyZSgvXltcXC4jOl0oPz1AKS8pIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW50aXRpZXMudmFyaWFibGVDdXJseSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEgZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignKCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHYgPSB0aGlzLnNlbGVjdG9yKCkpICYmIHBhcnNlcklucHV0LiRjaGFyKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gbmV3KHRyZWUuUGFyZW4pKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKFwiTWlzc2luZyBjbG9zaW5nICcpJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGUpIHsgcmV0dXJuIG5ldyh0cmVlLkVsZW1lbnQpKGMsIGUsIGluZGV4LCBmaWxlSW5mbyk7IH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBDb21iaW5hdG9ycyBjb21iaW5lIGVsZW1lbnRzIHRvZ2V0aGVyLCBpbiBhIFNlbGVjdG9yLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEJlY2F1c2Ugb3VyIHBhcnNlciBpc24ndCB3aGl0ZS1zcGFjZSBzZW5zaXRpdmUsIHNwZWNpYWwgY2FyZVxuICAgICAgICAgICAgLy8gaGFzIHRvIGJlIHRha2VuLCB3aGVuIHBhcnNpbmcgdGhlIGRlc2NlbmRhbnQgY29tYmluYXRvciwgYCBgLFxuICAgICAgICAgICAgLy8gYXMgaXQncyBhbiBlbXB0eSBzcGFjZS4gV2UgaGF2ZSB0byBjaGVjayB0aGUgcHJldmlvdXMgY2hhcmFjdGVyXG4gICAgICAgICAgICAvLyBpbiB0aGUgaW5wdXQsIHRvIHNlZSBpZiBpdCdzIGEgYCBgIGNoYXJhY3Rlci4gTW9yZSBpbmZvIG9uIGhvd1xuICAgICAgICAgICAgLy8gd2UgZGVhbCB3aXRoIHRoaXMgaW4gKmNvbWJpbmF0b3IuanMqLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGNvbWJpbmF0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsYXNoZWRDb21iaW5hdG9yID0gcGFyc2VySW5wdXQuJHJlKC9eXFwvW2Etel0rXFwvL2kpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2xhc2hlZENvbWJpbmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkNvbWJpbmF0b3IpKHNsYXNoZWRDb21iaW5hdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICc+JyB8fCBjID09PSAnKycgfHwgYyA9PT0gJ34nIHx8IGMgPT09ICd8JyB8fCBjID09PSAnXicpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuaSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ14nICYmIHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICdeJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdeXic7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBhcnNlcklucHV0LmlzV2hpdGVzcGFjZSgpKSB7IHBhcnNlcklucHV0LmkrKzsgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuQ29tYmluYXRvcikoYyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZXJJbnB1dC5pc1doaXRlc3BhY2UoLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5Db21iaW5hdG9yKShcIiBcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkNvbWJpbmF0b3IpKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQSBDU1Mgc2VsZWN0b3IgKHNlZSBzZWxlY3RvciBiZWxvdylcbiAgICAgICAgICAgIC8vIHdpdGggbGVzcyBleHRlbnNpb25zIGUuZy4gdGhlIGFiaWxpdHkgdG8gZXh0ZW5kIGFuZCBndWFyZFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGxlc3NTZWxlY3RvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9yKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBIENTUyBTZWxlY3RvclxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICAuY2xhc3MgPiBkaXYgKyBoMVxuICAgICAgICAgICAgLy8gICAgIGxpIGE6aG92ZXJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBTZWxlY3RvcnMgYXJlIG1hZGUgb3V0IG9mIG9uZSBvciBtb3JlIEVsZW1lbnRzLCBzZWUgYWJvdmUuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgc2VsZWN0b3I6IGZ1bmN0aW9uIChpc0xlc3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pLCBlbGVtZW50cywgZXh0ZW5kTGlzdCwgYywgZSwgYWxsRXh0ZW5kcywgd2hlbiwgY29uZGl0aW9uO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKChpc0xlc3MgJiYgKGV4dGVuZExpc3QgPSB0aGlzLmV4dGVuZCgpKSkgfHwgKGlzTGVzcyAmJiAod2hlbiA9IHBhcnNlcklucHV0LiRzdHIoXCJ3aGVuXCIpKSkgfHwgKGUgPSB0aGlzLmVsZW1lbnQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbiA9IGV4cGVjdCh0aGlzLmNvbmRpdGlvbnMsICdleHBlY3RlZCBjb25kaXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiQ1NTIGd1YXJkIGNhbiBvbmx5IGJlIHVzZWQgYXQgdGhlIGVuZCBvZiBzZWxlY3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHRlbmRMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsRXh0ZW5kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEV4dGVuZHMgPSBhbGxFeHRlbmRzLmNvbmNhdChleHRlbmRMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRXh0ZW5kcyA9IGV4dGVuZExpc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsRXh0ZW5kcykgeyBlcnJvcihcIkV4dGVuZCBjYW4gb25seSBiZSB1c2VkIGF0IHRoZSBlbmQgb2Ygc2VsZWN0b3JcIik7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBbIGUgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAneycgfHwgYyA9PT0gJ30nIHx8IGMgPT09ICc7JyB8fCBjID09PSAnLCcgfHwgYyA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cykgeyByZXR1cm4gbmV3KHRyZWUuU2VsZWN0b3IpKGVsZW1lbnRzLCBhbGxFeHRlbmRzLCBjb25kaXRpb24sIGluZGV4LCBmaWxlSW5mbyk7IH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsRXh0ZW5kcykgeyBlcnJvcihcIkV4dGVuZCBtdXN0IGJlIHVzZWQgdG8gZXh0ZW5kIGEgc2VsZWN0b3IsIGl0IGNhbm5vdCBiZSB1c2VkIG9uIGl0cyBvd25cIik7IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdHRyaWJ1dGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoISBwYXJzZXJJbnB1dC4kY2hhcignWycpKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGVudGl0aWVzID0gdGhpcy5lbnRpdGllcyxcbiAgICAgICAgICAgICAgICAgICAga2V5LCB2YWwsIG9wO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5ID0gZW50aXRpZXMudmFyaWFibGVDdXJseSgpKSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBleHBlY3QoL14oPzpbX0EtWmEtejAtOS1cXCpdKlxcfCk/KD86W19BLVphLXowLTktXXxcXFxcLikrLyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3AgPSBwYXJzZXJJbnB1dC4kcmUoL15bfH4qJF5dPz0vKTtcbiAgICAgICAgICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZW50aXRpZXMucXVvdGVkKCkgfHwgcGFyc2VySW5wdXQuJHJlKC9eWzAtOV0rJS8pIHx8IHBhcnNlcklucHV0LiRyZSgvXltcXHctXSsvKSB8fCBlbnRpdGllcy52YXJpYWJsZUN1cmx5KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZXhwZWN0Q2hhcignXScpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkF0dHJpYnV0ZSkoa2V5LCBvcCwgdmFsKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgYGJsb2NrYCBydWxlIGlzIHVzZWQgYnkgYHJ1bGVzZXRgIGFuZCBgbWl4aW4uZGVmaW5pdGlvbmAuXG4gICAgICAgICAgICAvLyBJdCdzIGEgd3JhcHBlciBhcm91bmQgdGhlIGBwcmltYXJ5YCBydWxlLCB3aXRoIGFkZGVkIGB7fWAuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgYmxvY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudDtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJ3snKSAmJiAoY29udGVudCA9IHRoaXMucHJpbWFyeSgpKSAmJiBwYXJzZXJJbnB1dC4kY2hhcignfScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGJsb2NrUnVsZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gdGhpcy5ibG9jaygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrID0gbmV3IHRyZWUuUnVsZXNldChudWxsLCBibG9jayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBibG9jaztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRldGFjaGVkUnVsZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrUnVsZXNldCA9IHRoaXMuYmxvY2tSdWxlc2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrUnVsZXNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuRGV0YWNoZWRSdWxlc2V0KGJsb2NrUnVsZXNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGRpdiwgLmNsYXNzLCBib2R5ID4gcCB7Li4ufVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHJ1bGVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3JzLCBzLCBydWxlcywgZGVidWdJbmZvO1xuXG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuZHVtcExpbmVOdW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnSW5mbyA9IGdldERlYnVnSW5mbyhwYXJzZXJJbnB1dC5pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzID0gdGhpcy5sZXNzU2VsZWN0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnMucHVzaChzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IFsgcyBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmNvbW1lbnRTdG9yZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5jb25kaXRpb24gJiYgc2VsZWN0b3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiR3VhcmRzIGFyZSBvbmx5IGN1cnJlbnRseSBhbGxvd2VkIG9uIGEgc2luZ2xlIHNlbGVjdG9yLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoISBwYXJzZXJJbnB1dC4kY2hhcignLCcpKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJHdWFyZHMgYXJlIG9ubHkgY3VycmVudGx5IGFsbG93ZWQgb24gYSBzaW5nbGUgc2VsZWN0b3IuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmNvbW1lbnRTdG9yZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvcnMgJiYgKHJ1bGVzID0gdGhpcy5ibG9jaygpKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGVzZXQgPSBuZXcodHJlZS5SdWxlc2V0KShzZWxlY3RvcnMsIHJ1bGVzLCBjb250ZXh0LnN0cmljdEltcG9ydHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5kdW1wTGluZU51bWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzZXQuZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydWxlc2V0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVsZTogZnVuY3Rpb24gKHRyeUFub255bW91cykge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lLCB2YWx1ZSwgc3RhcnRPZlJ1bGUgPSBwYXJzZXJJbnB1dC5pLCBjID0gcGFyc2VySW5wdXQuY3VycmVudENoYXIoKSwgaW1wb3J0YW50LCBtZXJnZSwgaXNWYXJpYWJsZTtcblxuICAgICAgICAgICAgICAgIGlmIChjID09PSAnLicgfHwgYyA9PT0gJyMnIHx8IGMgPT09ICcmJyB8fCBjID09PSAnOicpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy52YXJpYWJsZSgpIHx8IHRoaXMucnVsZVByb3BlcnR5KCk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNWYXJpYWJsZSA9IHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZGV0YWNoZWRSdWxlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBuYW1lIHJldHVybmVkIGJ5IHRoaXMucnVsZVByb3BlcnR5KCkgaXMgYWx3YXlzIGFuIGFycmF5IG9mIHRoZSBmb3JtOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gW3N0cmluZy0xLCAuLi4sIHN0cmluZy1uLCBcIlwiXSBvciBbc3RyaW5nLTEsIC4uLiwgc3RyaW5nLW4sIFwiK1wiXVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlcmUgZWFjaCBpdGVtIGlzIGEgdHJlZS5LZXl3b3JkIG9yIHRyZWUuVmFyaWFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlID0gIWlzVmFyaWFibGUgJiYgbmFtZS5sZW5ndGggPiAxICYmIG5hbWUucG9wKCkudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZWZlciB0byB0cnkgdG8gcGFyc2UgZmlyc3QgaWYgaXRzIGEgdmFyaWFibGUgb3Igd2UgYXJlIGNvbXByZXNzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgYWx3YXlzIGZhbGxiYWNrIG9uIHRoZSBvdGhlciBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cnlWYWx1ZUZpcnN0ID0gIXRyeUFub255bW91cyAmJiAoY29udGV4dC5jb21wcmVzcyB8fCBpc1ZhcmlhYmxlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyeVZhbHVlRmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuYW5vbnltb3VzVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFub255bW91cyB2YWx1ZXMgYWJzb3JiIHRoZSBlbmQgJzsnIHdoaWNoIGlzIHJlcXVpcmVkIGZvciB0aGVtIHRvIHdvcmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5SdWxlKShuYW1lLCB2YWx1ZSwgZmFsc2UsIG1lcmdlLCBzdGFydE9mUnVsZSwgZmlsZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJ5VmFsdWVGaXJzdCAmJiAhdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50ID0gdGhpcy5pbXBvcnRhbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0aGlzLmVuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuUnVsZSkobmFtZSwgdmFsdWUsIGltcG9ydGFudCwgbWVyZ2UsIHN0YXJ0T2ZSdWxlLCBmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgIXRyeUFub255bW91cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYW5vbnltb3VzVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBwYXJzZXJJbnB1dC4kcmUoL14oW15AK1xcLydcIipgKDt7fS1dKik7Lyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5Bbm9ueW1vdXMpKG1hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQW4gQGltcG9ydCBkaXJlY3RpdmVcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgQGltcG9ydCBcImxpYlwiO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiBvdXIgZW52aXJvbm1lbnQsIGltcG9ydGluZyBpcyBkb25lIGRpZmZlcmVudGx5OlxuICAgICAgICAgICAgLy8gSW4gdGhlIGJyb3dzZXIsIGl0J3MgYW4gWEhSIHJlcXVlc3QsIGluIE5vZGUsIGl0IHdvdWxkIGJlIGFcbiAgICAgICAgICAgIC8vIGZpbGUtc3lzdGVtIG9wZXJhdGlvbi4gVGhlIGZ1bmN0aW9uIHVzZWQgZm9yIGltcG9ydGluZyBpc1xuICAgICAgICAgICAgLy8gc3RvcmVkIGluIGBpbXBvcnRgLCB3aGljaCB3ZSBwYXNzIHRvIHRoZSBJbXBvcnQgY29uc3RydWN0b3IuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgXCJpbXBvcnRcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoLCBmZWF0dXJlcywgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRpciA9IHBhcnNlcklucHV0LiRyZSgvXkBpbXBvcnQ/XFxzKy8pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IChkaXIgPyB0aGlzLmltcG9ydE9wdGlvbnMoKSA6IG51bGwpIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgocGF0aCA9IHRoaXMuZW50aXRpZXMucXVvdGVkKCkgfHwgdGhpcy5lbnRpdGllcy51cmwoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzID0gdGhpcy5tZWRpYUZlYXR1cmVzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJzsnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcIm1pc3Npbmcgc2VtaS1jb2xvbiBvciB1bnJlY29nbmlzZWQgbWVkaWEgZmVhdHVyZXMgb24gaW1wb3J0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMgPSBmZWF0dXJlcyAmJiBuZXcodHJlZS5WYWx1ZSkoZmVhdHVyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkltcG9ydCkocGF0aCwgZmVhdHVyZXMsIG9wdGlvbnMsIGluZGV4LCBmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcIm1hbGZvcm1lZCBpbXBvcnQgc3RhdGVtZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaW1wb3J0T3B0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG8sIG9wdGlvbnMgPSB7fSwgb3B0aW9uTmFtZSwgdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIG9wdGlvbnMsIHN1cnJvdW5kZWQgYnkgcGFyZW5zXG4gICAgICAgICAgICAgICAgaWYgKCEgcGFyc2VySW5wdXQuJGNoYXIoJygnKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgbyA9IHRoaXMuaW1wb3J0T3B0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25OYW1lID0gbztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaChvcHRpb25OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25OYW1lID0gXCJsZXNzXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvbmNlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbk5hbWUgPSBcIm11bHRpcGxlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEgcGFyc2VySW5wdXQuJGNoYXIoJywnKSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAobyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0Q2hhcignKScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaW1wb3J0T3B0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0ID0gcGFyc2VySW5wdXQuJHJlKC9eKGxlc3N8Y3NzfG11bHRpcGxlfG9uY2V8aW5saW5lfHJlZmVyZW5jZXxvcHRpb25hbCkvKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbWVkaWFGZWF0dXJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudGl0aWVzID0gdGhpcy5lbnRpdGllcywgbm9kZXMgPSBbXSwgZSwgcDtcbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBlID0gZW50aXRpZXMua2V5d29yZCgpIHx8IGVudGl0aWVzLnZhcmlhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlcklucHV0LiRjaGFyKCcoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSB0aGlzLnByb3BlcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocCAmJiBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3KHRyZWUuUGFyZW4pKG5ldyh0cmVlLlJ1bGUpKHAsIGUsIG51bGwsIG51bGwsIHBhcnNlcklucHV0LmksIGZpbGVJbmZvLCB0cnVlKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyh0cmVlLlBhcmVuKShlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJiYWRseSBmb3JtZWQgbWVkaWEgZmVhdHVyZSBkZWZpbml0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJNaXNzaW5nIGNsb3NpbmcgJyknXCIsIFwiUGFyc2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChlKTtcblxuICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5FeHByZXNzaW9uKShub2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbWVkaWFGZWF0dXJlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRpdGllcyA9IHRoaXMuZW50aXRpZXMsIGZlYXR1cmVzID0gW10sIGU7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5tZWRpYUZlYXR1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISBwYXJzZXJJbnB1dC4kY2hhcignLCcpKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gZW50aXRpZXMudmFyaWFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISBwYXJzZXJJbnB1dC4kY2hhcignLCcpKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlcy5sZW5ndGggPiAwID8gZmVhdHVyZXMgOiBudWxsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbWVkaWE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZXMsIHJ1bGVzLCBtZWRpYSwgZGVidWdJbmZvLCBpbmRleCA9IHBhcnNlcklucHV0Lmk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5kdW1wTGluZU51bWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdJbmZvID0gZ2V0RGVidWdJbmZvKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJHN0cihcIkBtZWRpYVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IHRoaXMubWVkaWFGZWF0dXJlcygpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gdGhpcy5ibG9jaygpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghcnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwibWVkaWEgZGVmaW5pdGlvbnMgcmVxdWlyZSBibG9jayBzdGF0ZW1lbnRzIGFmdGVyIGFueSBmZWF0dXJlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhID0gbmV3KHRyZWUuTWVkaWEpKHJ1bGVzLCBmZWF0dXJlcywgaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuZHVtcExpbmVOdW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYS5kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVkaWE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEEgQHBsdWdpbiBkaXJlY3RpdmUsIHVzZWQgdG8gaW1wb3J0IGNvbXBpbGVyIGV4dGVuc2lvbnMgZHluYW1pY2FsbHkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIEBwbHVnaW4gXCJsaWJcIjtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gb3VyIGVudmlyb25tZW50LCBpbXBvcnRpbmcgaXMgZG9uZSBkaWZmZXJlbnRseTpcbiAgICAgICAgICAgIC8vIEluIHRoZSBicm93c2VyLCBpdCdzIGFuIFhIUiByZXF1ZXN0LCBpbiBOb2RlLCBpdCB3b3VsZCBiZSBhXG4gICAgICAgICAgICAvLyBmaWxlLXN5c3RlbSBvcGVyYXRpb24uIFRoZSBmdW5jdGlvbiB1c2VkIGZvciBpbXBvcnRpbmcgaXNcbiAgICAgICAgICAgIC8vIHN0b3JlZCBpbiBgaW1wb3J0YCwgd2hpY2ggd2UgcGFzcyB0byB0aGUgSW1wb3J0IGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHBsdWdpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHBhcnNlcklucHV0LmksXG4gICAgICAgICAgICAgICAgICAgIGRpciAgID0gcGFyc2VySW5wdXQuJHJlKC9eQHBsdWdpbj9cXHMrLyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0geyBwbHVnaW4gOiB0cnVlIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChwYXRoID0gdGhpcy5lbnRpdGllcy5xdW90ZWQoKSB8fCB0aGlzLmVudGl0aWVzLnVybCgpKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCc7JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJtaXNzaW5nIHNlbWktY29sb24gb24gcGx1Z2luXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuSW1wb3J0KShwYXRoLCBudWxsLCBvcHRpb25zLCBpbmRleCwgZmlsZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuaSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJtYWxmb3JtZWQgcGx1Z2luIHN0YXRlbWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBIENTUyBEaXJlY3RpdmVcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgQGNoYXJzZXQgXCJ1dGYtOFwiO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGRpcmVjdGl2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0LmksIG5hbWUsIHZhbHVlLCBydWxlcywgbm9uVmVuZG9yU3BlY2lmaWNOYW1lLFxuICAgICAgICAgICAgICAgICAgICBoYXNJZGVudGlmaWVyLCBoYXNFeHByZXNzaW9uLCBoYXNVbmtub3duLCBoYXNCbG9jayA9IHRydWUsIGlzUm9vdGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpICE9PSAnQCcpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXNbJ2ltcG9ydCddKCkgfHwgdGhpcy5wbHVnaW4oKSB8fCB0aGlzLm1lZGlhKCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICBuYW1lID0gcGFyc2VySW5wdXQuJHJlKC9eQFthLXotXSsvKTtcblxuICAgICAgICAgICAgICAgIGlmICghbmFtZSkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAgIG5vblZlbmRvclNwZWNpZmljTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDEpID09ICctJyAmJiBuYW1lLmluZGV4T2YoJy0nLCAyKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uVmVuZG9yU3BlY2lmaWNOYW1lID0gXCJAXCIgKyBuYW1lLnNsaWNlKG5hbWUuaW5kZXhPZignLScsIDIpICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3dpdGNoKG5vblZlbmRvclNwZWNpZmljTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQGNoYXJzZXRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0lkZW50aWZpZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQG5hbWVzcGFjZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXhwcmVzc2lvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNCbG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJAa2V5ZnJhbWVzXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJAY291bnRlci1zdHlsZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzSWRlbnRpZmllciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkBkb2N1bWVudFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQHN1cHBvcnRzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNVbmtub3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUm9vdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Vua25vd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuY29tbWVudFN0b3JlLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZW50aXR5KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiZXhwZWN0ZWQgXCIgKyBuYW1lICsgXCIgaWRlbnRpZmllclwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcImV4cGVjdGVkIFwiICsgbmFtZSArIFwiIGV4cHJlc3Npb25cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc1Vua25vd24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAocGFyc2VySW5wdXQuJHJlKC9eW157O10rLykgfHwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgaGFzQmxvY2sgPSAocGFyc2VySW5wdXQuY3VycmVudENoYXIoKSA9PSAneycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3KHRyZWUuQW5vbnltb3VzKSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMgPSB0aGlzLmJsb2NrUnVsZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChydWxlcyB8fCAoIWhhc0Jsb2NrICYmIHZhbHVlICYmIHBhcnNlcklucHV0LiRjaGFyKCc7JykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLkRpcmVjdGl2ZSkobmFtZSwgdmFsdWUsIHJ1bGVzLCBpbmRleCwgZmlsZUluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmR1bXBMaW5lTnVtYmVycyA/IGdldERlYnVnSW5mbyhpbmRleCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSb290ZWRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKFwiZGlyZWN0aXZlIG9wdGlvbnMgbm90IHJlY29nbmlzZWRcIik7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQSBWYWx1ZSBpcyBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIEV4cHJlc3Npb25zXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIGZvbnQtZmFtaWx5OiBCYXNrZXJ2aWxsZSwgR2VvcmdpYSwgc2VyaWY7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSW4gYSBSdWxlLCBhIFZhbHVlIHJlcHJlc2VudHMgZXZlcnl0aGluZyBhZnRlciB0aGUgYDpgLFxuICAgICAgICAgICAgLy8gYW5kIGJlZm9yZSB0aGUgYDtgLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUsIGV4cHJlc3Npb25zID0gW107XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLmV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISBwYXJzZXJJbnB1dC4kY2hhcignLCcpKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChlKTtcblxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5WYWx1ZSkoZXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbXBvcnRhbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuY3VycmVudENoYXIoKSA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXJJbnB1dC4kcmUoL14hICppbXBvcnRhbnQvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3ViOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEsIGU7XG5cbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCcoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IHRoaXMuYWRkaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgJiYgcGFyc2VySW5wdXQuJGNoYXIoJyknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gbmV3KHRyZWUuRXhwcmVzc2lvbikoW2FdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucGFyZW5zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoXCJFeHBlY3RlZCAnKSdcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bHRpcGxpY2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0sIGEsIG9wLCBvcGVyYXRpb24sIGlzU3BhY2VkO1xuICAgICAgICAgICAgICAgIG0gPSB0aGlzLm9wZXJhbmQoKTtcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBpc1NwYWNlZCA9IHBhcnNlcklucHV0LmlzV2hpdGVzcGFjZSgtMSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQucGVlaygvXlxcL1sqXFwvXS8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBwYXJzZXJJbnB1dC4kY2hhcignLycpIHx8IHBhcnNlcklucHV0LiRjaGFyKCcqJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3ApIHsgcGFyc2VySW5wdXQuZm9yZ2V0KCk7IGJyZWFrOyB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSB0aGlzLm9wZXJhbmQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhKSB7IHBhcnNlcklucHV0LnJlc3RvcmUoKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtLnBhcmVuc0luT3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wYXJlbnNJbk9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IG5ldyh0cmVlLk9wZXJhdGlvbikob3AsIFtvcGVyYXRpb24gfHwgbSwgYV0sIGlzU3BhY2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3BhY2VkID0gcGFyc2VySW5wdXQuaXNXaGl0ZXNwYWNlKC0xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uIHx8IG07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZGl0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0sIGEsIG9wLCBvcGVyYXRpb24sIGlzU3BhY2VkO1xuICAgICAgICAgICAgICAgIG0gPSB0aGlzLm11bHRpcGxpY2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXNTcGFjZWQgPSBwYXJzZXJJbnB1dC5pc1doaXRlc3BhY2UoLTEpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBwYXJzZXJJbnB1dC4kcmUoL15bLStdXFxzKy8pIHx8ICghaXNTcGFjZWQgJiYgKHBhcnNlcklucHV0LiRjaGFyKCcrJykgfHwgcGFyc2VySW5wdXQuJGNoYXIoJy0nKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHRoaXMubXVsdGlwbGljYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtLnBhcmVuc0luT3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wYXJlbnNJbk9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IG5ldyh0cmVlLk9wZXJhdGlvbikob3AsIFtvcGVyYXRpb24gfHwgbSwgYV0sIGlzU3BhY2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3BhY2VkID0gcGFyc2VySW5wdXQuaXNXaGl0ZXNwYWNlKC0xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uIHx8IG07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmRpdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSwgYiwgaW5kZXggPSBwYXJzZXJJbnB1dC5pLCBjb25kaXRpb247XG5cbiAgICAgICAgICAgICAgICBhID0gdGhpcy5jb25kaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC5wZWVrKC9eLFxccyoobm90XFxzKik/XFwoLykgfHwgIXBhcnNlcklucHV0LiRjaGFyKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSB0aGlzLmNvbmRpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24gPSBuZXcodHJlZS5Db25kaXRpb24pKCdvcicsIGNvbmRpdGlvbiB8fCBhLCBiLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiB8fCBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25kaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0LCBsb2dpY2FsLCBuZXh0O1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VySW5wdXQuJHN0cihcIm9yXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY29uZGl0aW9uQW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZ2ljYWwgPSBvcigpO1xuICAgICAgICAgICAgICAgIGlmIChsb2dpY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSB0aGlzLmNvbmRpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3KHRyZWUuQ29uZGl0aW9uKShsb2dpY2FsLCByZXN1bHQsIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmRpdGlvbkFuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQsIGxvZ2ljYWwsIG5leHQ7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaW5zaWRlQ29uZGl0aW9uKG1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZS5uZWdhdGVkQ29uZGl0aW9uKCkgfHwgbWUucGFyZW50aGVzaXNDb25kaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYW5kKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VySW5wdXQuJHN0cihcImFuZFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnNpZGVDb25kaXRpb24odGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9naWNhbCA9IGFuZCgpO1xuICAgICAgICAgICAgICAgIGlmIChsb2dpY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSB0aGlzLmNvbmRpdGlvbkFuZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3KHRyZWUuQ29uZGl0aW9uKShsb2dpY2FsLCByZXN1bHQsIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5lZ2F0ZWRDb25kaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJHN0cihcIm5vdFwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJlbnRoZXNpc0NvbmRpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubmVnYXRlID0gIXJlc3VsdC5uZWdhdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyZW50aGVzaXNDb25kaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB0cnlDb25kaXRpb25Gb2xsb3dlZEJ5UGFyZW50aGVzaXMobWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IG1lLmNvbmRpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignKScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYm9keTtcbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kc3RyKFwiKFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvZHkgPSB0cnlDb25kaXRpb25Gb2xsb3dlZEJ5UGFyZW50aGVzaXModGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmF0b21pY0NvbmRpdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJyknKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKFwiZXhwZWN0ZWQgJyknIGdvdCAnXCIgKyBwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdG9taWNDb25kaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50aXRpZXMgPSB0aGlzLmVudGl0aWVzLCBpbmRleCA9IHBhcnNlcklucHV0LmksIGEsIGIsIGMsIG9wO1xuXG4gICAgICAgICAgICAgICAgYSA9IHRoaXMuYWRkaXRpb24oKSB8fCBlbnRpdGllcy5rZXl3b3JkKCkgfHwgZW50aXRpZXMucXVvdGVkKCk7XG4gICAgICAgICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc+JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBcIj49XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gJz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc8JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBcIjw9XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gJzwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignPicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBcIj0+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc8JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9ICc9PCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gJz0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMuYWRkaXRpb24oKSB8fCBlbnRpdGllcy5rZXl3b3JkKCkgfHwgZW50aXRpZXMucXVvdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBuZXcodHJlZS5Db25kaXRpb24pKG9wLCBhLCBiLCBpbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignZXhwZWN0ZWQgZXhwcmVzc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IG5ldyh0cmVlLkNvbmRpdGlvbikoJz0nLCBhLCBuZXcodHJlZS5LZXl3b3JkKSgndHJ1ZScpLCBpbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBbiBvcGVyYW5kIGlzIGFueXRoaW5nIHRoYXQgY2FuIGJlIHBhcnQgb2YgYW4gb3BlcmF0aW9uLFxuICAgICAgICAgICAgLy8gc3VjaCBhcyBhIENvbG9yLCBvciBhIFZhcmlhYmxlXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgb3BlcmFuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRpdGllcyA9IHRoaXMuZW50aXRpZXMsIG5lZ2F0ZTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5wZWVrKC9eLVtAXFwoXS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5lZ2F0ZSA9IHBhcnNlcklucHV0LiRjaGFyKCctJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG8gPSB0aGlzLnN1YigpIHx8IGVudGl0aWVzLmRpbWVuc2lvbigpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRpdGllcy5jb2xvcigpIHx8IGVudGl0aWVzLnZhcmlhYmxlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLmNhbGwoKSB8fCBlbnRpdGllcy5jb2xvcktleXdvcmQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgby5wYXJlbnNJbk9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbyA9IG5ldyh0cmVlLk5lZ2F0aXZlKShvKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBFeHByZXNzaW9ucyBlaXRoZXIgcmVwcmVzZW50IG1hdGhlbWF0aWNhbCBvcGVyYXRpb25zLFxuICAgICAgICAgICAgLy8gb3Igd2hpdGUtc3BhY2UgZGVsaW1pdGVkIEVudGl0aWVzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICAxcHggc29saWQgYmxhY2tcbiAgICAgICAgICAgIC8vICAgICBAdmFyICogMlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50aXRpZXMgPSBbXSwgZSwgZGVsaW07XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLmNvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5hZGRpdGlvbigpIHx8IHRoaXMuZW50aXR5KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRpdGllcy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3BlcmF0aW9ucyBkbyBub3QgYWxsb3cga2V5d29yZCBcIi9cIiBkaW1lbnNpb24gKGUuZy4gc21hbGwvMjBweCkgc28gd2Ugc3VwcG9ydCB0aGF0IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQucGVlaygvXlxcL1tcXC8qXS8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW0gPSBwYXJzZXJJbnB1dC4kY2hhcignLycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxpbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRpdGllcy5wdXNoKG5ldyh0cmVlLkFub255bW91cykoZGVsaW0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChlKTtcbiAgICAgICAgICAgICAgICBpZiAoZW50aXRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuRXhwcmVzc2lvbikoZW50aXRpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9wZXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gcGFyc2VySW5wdXQuJHJlKC9eKFxcKj8tP1tfYS16QS1aMC05LV0rKVxccyo6Lyk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWVbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bGVQcm9wZXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gW10sIGluZGV4ID0gW10sIHMsIGs7XG5cbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2ltcGxlUHJvcGVydHkgPSBwYXJzZXJJbnB1dC4kcmUoL14oW19hLXpBLVowLTktXSspXFxzKjovKTtcbiAgICAgICAgICAgICAgICBpZiAoc2ltcGxlUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFtuZXcodHJlZS5LZXl3b3JkKShzaW1wbGVQcm9wZXJ0eVsxXSldO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2gocmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBwYXJzZXJJbnB1dC5pLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSBwYXJzZXJJbnB1dC4kcmUocmUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZS5wdXNoKGNodW5rWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1hdGNoKC9eKFxcKj8pLyk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgvXigoPzpbXFx3LV0rKXwoPzpAXFx7W1xcdy1dK1xcfSkpLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKChuYW1lLmxlbmd0aCA+IDEpICYmIG1hdGNoKC9eKCg/OlxcK198XFwrKT8pXFxzKjovKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhdCBsYXN0LCB3ZSBoYXZlIHRoZSBjb21wbGV0ZSBtYXRjaCBub3cuIG1vdmUgZm9yd2FyZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCBuYW1lIHBhcnRpY2xlcyB0byB0cmVlIG9iamVjdHMgYW5kIHJldHVybjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBuYW1lLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gbmFtZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVba10gPSAocy5jaGFyQXQoMCkgIT09ICdAJykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyh0cmVlLktleXdvcmQpKHMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcodHJlZS5WYXJpYWJsZSkoJ0AnICsgcy5zbGljZSgyLCAtMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4W2tdLCBmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuUGFyc2VyLnNlcmlhbGl6ZVZhcnMgPSBmdW5jdGlvbih2YXJzKSB7XG4gICAgdmFyIHMgPSAnJztcblxuICAgIGZvciAodmFyIG5hbWUgaW4gdmFycykge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodmFycywgbmFtZSkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhcnNbbmFtZV07XG4gICAgICAgICAgICBzICs9ICgobmFtZVswXSA9PT0gJ0AnKSA/ICcnIDogJ0AnKSArIG5hbWUgKyAnOiAnICsgdmFsdWUgK1xuICAgICAgICAgICAgICAgICgoU3RyaW5nKHZhbHVlKS5zbGljZSgtMSkgPT09ICc7JykgPyAnJyA6ICc7Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VyO1xuXG59LHtcIi4uL2xlc3MtZXJyb3JcIjozMixcIi4uL3RyZWVcIjo2MixcIi4uL3V0aWxzXCI6ODMsXCIuLi92aXNpdG9yc1wiOjg3LFwiLi9wYXJzZXItaW5wdXRcIjozN31dLDM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogUGx1Z2luIE1hbmFnZXJcbiAqL1xudmFyIFBsdWdpbk1hbmFnZXIgPSBmdW5jdGlvbihsZXNzKSB7XG4gICAgdGhpcy5sZXNzID0gbGVzcztcbiAgICB0aGlzLnZpc2l0b3JzID0gW107XG4gICAgdGhpcy5wcmVQcm9jZXNzb3JzID0gW107XG4gICAgdGhpcy5wb3N0UHJvY2Vzc29ycyA9IFtdO1xuICAgIHRoaXMuaW5zdGFsbGVkUGx1Z2lucyA9IFtdO1xuICAgIHRoaXMuZmlsZU1hbmFnZXJzID0gW107XG59O1xuLyoqXG4gKiBBZGRzIGFsbCB0aGUgcGx1Z2lucyBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IHBsdWdpbnNcbiAqL1xuUGx1Z2luTWFuYWdlci5wcm90b3R5cGUuYWRkUGx1Z2lucyA9IGZ1bmN0aW9uKHBsdWdpbnMpIHtcbiAgICBpZiAocGx1Z2lucykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYWRkUGx1Z2luKHBsdWdpbnNbaV0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICpcbiAqIEBwYXJhbSBwbHVnaW5cbiAqL1xuUGx1Z2luTWFuYWdlci5wcm90b3R5cGUuYWRkUGx1Z2luID0gZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgdGhpcy5pbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICBwbHVnaW4uaW5zdGFsbCh0aGlzLmxlc3MsIHRoaXMpO1xufTtcbi8qKlxuICogQWRkcyBhIHZpc2l0b3IuIFRoZSB2aXNpdG9yIG9iamVjdCBoYXMgb3B0aW9ucyBvbiBpdHNlbGYgdG8gZGV0ZXJtaW5lXG4gKiB3aGVuIGl0IHNob3VsZCBydW4uXG4gKiBAcGFyYW0gdmlzaXRvclxuICovXG5QbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5hZGRWaXNpdG9yID0gZnVuY3Rpb24odmlzaXRvcikge1xuICAgIHRoaXMudmlzaXRvcnMucHVzaCh2aXNpdG9yKTtcbn07XG4vKipcbiAqIEFkZHMgYSBwcmUgcHJvY2Vzc29yIG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IHByZVByb2Nlc3NvclxuICogQHBhcmFtIHtudW1iZXJ9IHByaW9yaXR5IC0gZ3VpZGVsaW5lcyAxID0gYmVmb3JlIGltcG9ydCwgMTAwMCA9IGltcG9ydCwgMjAwMCA9IGFmdGVyIGltcG9ydFxuICovXG5QbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5hZGRQcmVQcm9jZXNzb3IgPSBmdW5jdGlvbihwcmVQcm9jZXNzb3IsIHByaW9yaXR5KSB7XG4gICAgdmFyIGluZGV4VG9JbnNlcnRBdDtcbiAgICBmb3IgKGluZGV4VG9JbnNlcnRBdCA9IDA7IGluZGV4VG9JbnNlcnRBdCA8IHRoaXMucHJlUHJvY2Vzc29ycy5sZW5ndGg7IGluZGV4VG9JbnNlcnRBdCsrKSB7XG4gICAgICAgIGlmICh0aGlzLnByZVByb2Nlc3NvcnNbaW5kZXhUb0luc2VydEF0XS5wcmlvcml0eSA+PSBwcmlvcml0eSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcmVQcm9jZXNzb3JzLnNwbGljZShpbmRleFRvSW5zZXJ0QXQsIDAsIHtwcmVQcm9jZXNzb3I6IHByZVByb2Nlc3NvciwgcHJpb3JpdHk6IHByaW9yaXR5fSk7XG59O1xuLyoqXG4gKiBBZGRzIGEgcG9zdCBwcm9jZXNzb3Igb2JqZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gcG9zdFByb2Nlc3NvclxuICogQHBhcmFtIHtudW1iZXJ9IHByaW9yaXR5IC0gZ3VpZGVsaW5lcyAxID0gYmVmb3JlIGNvbXByZXNzaW9uLCAxMDAwID0gY29tcHJlc3Npb24sIDIwMDAgPSBhZnRlciBjb21wcmVzc2lvblxuICovXG5QbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5hZGRQb3N0UHJvY2Vzc29yID0gZnVuY3Rpb24ocG9zdFByb2Nlc3NvciwgcHJpb3JpdHkpIHtcbiAgICB2YXIgaW5kZXhUb0luc2VydEF0O1xuICAgIGZvciAoaW5kZXhUb0luc2VydEF0ID0gMDsgaW5kZXhUb0luc2VydEF0IDwgdGhpcy5wb3N0UHJvY2Vzc29ycy5sZW5ndGg7IGluZGV4VG9JbnNlcnRBdCsrKSB7XG4gICAgICAgIGlmICh0aGlzLnBvc3RQcm9jZXNzb3JzW2luZGV4VG9JbnNlcnRBdF0ucHJpb3JpdHkgPj0gcHJpb3JpdHkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMucG9zdFByb2Nlc3NvcnMuc3BsaWNlKGluZGV4VG9JbnNlcnRBdCwgMCwge3Bvc3RQcm9jZXNzb3I6IHBvc3RQcm9jZXNzb3IsIHByaW9yaXR5OiBwcmlvcml0eX0pO1xufTtcbi8qKlxuICpcbiAqIEBwYXJhbSBtYW5hZ2VyXG4gKi9cblBsdWdpbk1hbmFnZXIucHJvdG90eXBlLmFkZEZpbGVNYW5hZ2VyID0gZnVuY3Rpb24obWFuYWdlcikge1xuICAgIHRoaXMuZmlsZU1hbmFnZXJzLnB1c2gobWFuYWdlcik7XG59O1xuLyoqXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuUGx1Z2luTWFuYWdlci5wcm90b3R5cGUuZ2V0UHJlUHJvY2Vzc29ycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcmVQcm9jZXNzb3JzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByZVByb2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlUHJvY2Vzc29ycy5wdXNoKHRoaXMucHJlUHJvY2Vzc29yc1tpXS5wcmVQcm9jZXNzb3IpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlUHJvY2Vzc29ycztcbn07XG4vKipcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5QbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5nZXRQb3N0UHJvY2Vzc29ycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwb3N0UHJvY2Vzc29ycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb3N0UHJvY2Vzc29ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb3N0UHJvY2Vzc29ycy5wdXNoKHRoaXMucG9zdFByb2Nlc3NvcnNbaV0ucG9zdFByb2Nlc3Nvcik7XG4gICAgfVxuICAgIHJldHVybiBwb3N0UHJvY2Vzc29ycztcbn07XG4vKipcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5QbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5nZXRWaXNpdG9ycyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnZpc2l0b3JzO1xufTtcbi8qKlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cblBsdWdpbk1hbmFnZXIucHJvdG90eXBlLmdldEZpbGVNYW5hZ2VycyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVNYW5hZ2Vycztcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFBsdWdpbk1hbmFnZXI7XG5cbn0se31dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBMZXNzRXJyb3IgPSByZXF1aXJlKCcuLi9sZXNzLWVycm9yJyksXG4gICAgdHJlZSA9IHJlcXVpcmUoXCIuLi90cmVlXCIpO1xuXG52YXIgRnVuY3Rpb25JbXBvcnRlciA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRnVuY3Rpb25JbXBvcnRlcihjb250ZXh0LCBmaWxlSW5mbykge1xuICAgIHRoaXMuZmlsZUluZm8gPSBmaWxlSW5mbztcbn07XG5cbkZ1bmN0aW9uSW1wb3J0ZXIucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbihjb250ZW50cywgY2FsbGJhY2spIHtcbiAgICB2YXIgbG9hZGVkID0ge30sXG4gICAgICAgIGxvYWRlcixcbiAgICAgICAgcmVnaXN0cnk7XG5cbiAgICByZWdpc3RyeSA9IHtcbiAgICAgICAgYWRkOiBmdW5jdGlvbihuYW1lLCBmdW5jKSB7XG4gICAgICAgICAgICBsb2FkZWRbbmFtZV0gPSBmdW5jO1xuICAgICAgICB9LFxuICAgICAgICBhZGRNdWx0aXBsZTogZnVuY3Rpb24oZnVuY3Rpb25zKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhmdW5jdGlvbnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIGxvYWRlZFtuYW1lXSA9IGZ1bmN0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICAgIGxvYWRlciA9IG5ldyBGdW5jdGlvbihcImZ1bmN0aW9uc1wiLCBcInRyZWVcIiwgXCJmaWxlSW5mb1wiLCBjb250ZW50cyk7XG4gICAgICAgIGxvYWRlcihyZWdpc3RyeSwgdHJlZSwgdGhpcy5maWxlSW5mbyk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBMZXNzRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJQbHVnaW4gZXZhbHVhdGlvbiBlcnJvcjogJ1wiICsgZS5uYW1lICsgJzogJyArIGUubWVzc2FnZS5yZXBsYWNlKC9bXCJdL2csIFwiJ1wiKSArIFwiJ1wiICxcbiAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvLmZpbGVuYW1lXG4gICAgICAgIH0pLCBudWxsICk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgeyBmdW5jdGlvbnM6IGxvYWRlZCB9KTtcbn07XG5cbn0se1wiLi4vbGVzcy1lcnJvclwiOjMyLFwiLi4vdHJlZVwiOjYyfV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIFByb21pc2VDb25zdHJ1Y3RvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbnZpcm9ubWVudCwgUGFyc2VUcmVlLCBJbXBvcnRNYW5hZ2VyKSB7XG4gICAgdmFyIHJlbmRlciA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoIVByb21pc2VDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIFByb21pc2VDb25zdHJ1Y3RvciA9IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHJlcXVpcmUoJ3Byb21pc2UnKSA6IFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2VDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyLmNhbGwoc2VsZiwgaW5wdXQsIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2UoaW5wdXQsIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgcm9vdCwgaW1wb3J0cywgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH1cblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlVHJlZSA9IG5ldyBQYXJzZVRyZWUocm9vdCwgaW1wb3J0cyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlVHJlZS50b0NTUyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfVxuXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiByZW5kZXI7XG59O1xuXG59LHtcInByb21pc2VcIjp1bmRlZmluZWR9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTb3VyY2VNYXBPdXRwdXQsIGVudmlyb25tZW50KSB7XG5cbiAgICB2YXIgU291cmNlTWFwQnVpbGRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfTtcblxuICAgIFNvdXJjZU1hcEJ1aWxkZXIucHJvdG90eXBlLnRvQ1NTID0gZnVuY3Rpb24ocm9vdE5vZGUsIG9wdGlvbnMsIGltcG9ydHMpIHtcbiAgICAgICAgdmFyIHNvdXJjZU1hcE91dHB1dCA9IG5ldyBTb3VyY2VNYXBPdXRwdXQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGVudHNJZ25vcmVkQ2hhcnNNYXA6IGltcG9ydHMuY29udGVudHNJZ25vcmVkQ2hhcnMsXG4gICAgICAgICAgICAgICAgcm9vdE5vZGU6IHJvb3ROb2RlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRzTWFwOiBpbXBvcnRzLmNvbnRlbnRzLFxuICAgICAgICAgICAgICAgIHNvdXJjZU1hcEZpbGVuYW1lOiB0aGlzLm9wdGlvbnMuc291cmNlTWFwRmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgc291cmNlTWFwVVJMOiB0aGlzLm9wdGlvbnMuc291cmNlTWFwVVJMLFxuICAgICAgICAgICAgICAgIG91dHB1dEZpbGVuYW1lOiB0aGlzLm9wdGlvbnMuc291cmNlTWFwT3V0cHV0RmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgc291cmNlTWFwQmFzZXBhdGg6IHRoaXMub3B0aW9ucy5zb3VyY2VNYXBCYXNlcGF0aCxcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBSb290cGF0aDogdGhpcy5vcHRpb25zLnNvdXJjZU1hcFJvb3RwYXRoLFxuICAgICAgICAgICAgICAgIG91dHB1dFNvdXJjZUZpbGVzOiB0aGlzLm9wdGlvbnMub3V0cHV0U291cmNlRmlsZXMsXG4gICAgICAgICAgICAgICAgc291cmNlTWFwR2VuZXJhdG9yOiB0aGlzLm9wdGlvbnMuc291cmNlTWFwR2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIHNvdXJjZU1hcEZpbGVJbmxpbmU6IHRoaXMub3B0aW9ucy5zb3VyY2VNYXBGaWxlSW5saW5lXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB2YXIgY3NzID0gc291cmNlTWFwT3V0cHV0LnRvQ1NTKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNvdXJjZU1hcCA9IHNvdXJjZU1hcE91dHB1dC5zb3VyY2VNYXA7XG4gICAgICAgIHRoaXMuc291cmNlTWFwVVJMID0gc291cmNlTWFwT3V0cHV0LnNvdXJjZU1hcFVSTDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb3VyY2VNYXBJbnB1dEZpbGVuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZU1hcElucHV0RmlsZW5hbWUgPSBzb3VyY2VNYXBPdXRwdXQubm9ybWFsaXplRmlsZW5hbWUodGhpcy5vcHRpb25zLnNvdXJjZU1hcElucHV0RmlsZW5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjc3MgKyB0aGlzLmdldENTU0FwcGVuZGFnZSgpO1xuICAgIH07XG5cbiAgICBTb3VyY2VNYXBCdWlsZGVyLnByb3RvdHlwZS5nZXRDU1NBcHBlbmRhZ2UgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc291cmNlTWFwVVJMID0gdGhpcy5zb3VyY2VNYXBVUkw7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc291cmNlTWFwRmlsZUlubGluZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlTWFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZU1hcFVSTCA9IFwiZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGVudmlyb25tZW50LmVuY29kZUJhc2U2NCh0aGlzLnNvdXJjZU1hcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc291cmNlTWFwVVJMKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIvKiMgc291cmNlTWFwcGluZ1VSTD1cIiArIHNvdXJjZU1hcFVSTCArIFwiICovXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfTtcblxuICAgIFNvdXJjZU1hcEJ1aWxkZXIucHJvdG90eXBlLmdldEV4dGVybmFsU291cmNlTWFwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZU1hcDtcbiAgICB9O1xuICAgIFNvdXJjZU1hcEJ1aWxkZXIucHJvdG90eXBlLnNldEV4dGVybmFsU291cmNlTWFwID0gZnVuY3Rpb24oc291cmNlTWFwKSB7XG4gICAgICAgIHRoaXMuc291cmNlTWFwID0gc291cmNlTWFwO1xuICAgIH07XG5cbiAgICBTb3VyY2VNYXBCdWlsZGVyLnByb3RvdHlwZS5pc0lubGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNvdXJjZU1hcEZpbGVJbmxpbmU7XG4gICAgfTtcbiAgICBTb3VyY2VNYXBCdWlsZGVyLnByb3RvdHlwZS5nZXRTb3VyY2VNYXBVUkwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlTWFwVVJMO1xuICAgIH07XG4gICAgU291cmNlTWFwQnVpbGRlci5wcm90b3R5cGUuZ2V0T3V0cHV0RmlsZW5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zb3VyY2VNYXBPdXRwdXRGaWxlbmFtZTtcbiAgICB9O1xuICAgIFNvdXJjZU1hcEJ1aWxkZXIucHJvdG90eXBlLmdldElucHV0RmlsZW5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlTWFwSW5wdXRGaWxlbmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNvdXJjZU1hcEJ1aWxkZXI7XG59O1xuXG59LHt9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuXG4gICAgdmFyIFNvdXJjZU1hcE91dHB1dCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2NzcyA9IFtdO1xuICAgICAgICB0aGlzLl9yb290Tm9kZSA9IG9wdGlvbnMucm9vdE5vZGU7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRzTWFwID0gb3B0aW9ucy5jb250ZW50c01hcDtcbiAgICAgICAgdGhpcy5fY29udGVudHNJZ25vcmVkQ2hhcnNNYXAgPSBvcHRpb25zLmNvbnRlbnRzSWdub3JlZENoYXJzTWFwO1xuICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2VNYXBGaWxlbmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwRmlsZW5hbWUgPSBvcHRpb25zLnNvdXJjZU1hcEZpbGVuYW1lLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vdXRwdXRGaWxlbmFtZSA9IG9wdGlvbnMub3V0cHV0RmlsZW5hbWU7XG4gICAgICAgIHRoaXMuc291cmNlTWFwVVJMID0gb3B0aW9ucy5zb3VyY2VNYXBVUkw7XG4gICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcEJhc2VwYXRoKSB7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBCYXNlcGF0aCA9IG9wdGlvbnMuc291cmNlTWFwQmFzZXBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcFJvb3RwYXRoKSB7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBSb290cGF0aCA9IG9wdGlvbnMuc291cmNlTWFwUm9vdHBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZU1hcFJvb3RwYXRoLmNoYXJBdCh0aGlzLl9zb3VyY2VNYXBSb290cGF0aC5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwUm9vdHBhdGggKz0gJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwUm9vdHBhdGggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX291dHB1dFNvdXJjZUZpbGVzID0gb3B0aW9ucy5vdXRwdXRTb3VyY2VGaWxlcztcbiAgICAgICAgdGhpcy5fc291cmNlTWFwR2VuZXJhdG9yQ29uc3RydWN0b3IgPSBlbnZpcm9ubWVudC5nZXRTb3VyY2VNYXBHZW5lcmF0b3IoKTtcblxuICAgICAgICB0aGlzLl9saW5lTnVtYmVyID0gMDtcbiAgICAgICAgdGhpcy5fY29sdW1uID0gMDtcbiAgICB9O1xuXG4gICAgU291cmNlTWFwT3V0cHV0LnByb3RvdHlwZS5ub3JtYWxpemVGaWxlbmFtZSA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gICAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuXG4gICAgICAgIGlmICh0aGlzLl9zb3VyY2VNYXBCYXNlcGF0aCAmJiBmaWxlbmFtZS5pbmRleE9mKHRoaXMuX3NvdXJjZU1hcEJhc2VwYXRoKSA9PT0gMCkge1xuICAgICAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZS5zdWJzdHJpbmcodGhpcy5fc291cmNlTWFwQmFzZXBhdGgubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChmaWxlbmFtZS5jaGFyQXQoMCkgPT09ICdcXFxcJyB8fCBmaWxlbmFtZS5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5fc291cmNlTWFwUm9vdHBhdGggfHwgXCJcIikgKyBmaWxlbmFtZTtcbiAgICB9O1xuXG4gICAgU291cmNlTWFwT3V0cHV0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihjaHVuaywgZmlsZUluZm8sIGluZGV4LCBtYXBMaW5lcykge1xuXG4gICAgICAgIC8vaWdub3JlIGFkZGluZyBlbXB0eSBzdHJpbmdzXG4gICAgICAgIGlmICghY2h1bmspIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5lcyxcbiAgICAgICAgICAgIHNvdXJjZUxpbmVzLFxuICAgICAgICAgICAgY29sdW1ucyxcbiAgICAgICAgICAgIHNvdXJjZUNvbHVtbnMsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGlmIChmaWxlSW5mbykge1xuICAgICAgICAgICAgdmFyIGlucHV0U291cmNlID0gdGhpcy5fY29udGVudHNNYXBbZmlsZUluZm8uZmlsZW5hbWVdO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdmFycy9iYW5uZXIgYWRkZWQgdG8gdGhlIHRvcCBvZiB0aGUgZmlsZVxuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnRzSWdub3JlZENoYXJzTWFwW2ZpbGVJbmZvLmZpbGVuYW1lXSkge1xuICAgICAgICAgICAgICAgIC8vIGFkanVzdCB0aGUgaW5kZXhcbiAgICAgICAgICAgICAgICBpbmRleCAtPSB0aGlzLl9jb250ZW50c0lnbm9yZWRDaGFyc01hcFtmaWxlSW5mby5maWxlbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkgeyBpbmRleCA9IDA7IH1cbiAgICAgICAgICAgICAgICAvLyBhZGp1c3QgdGhlIHNvdXJjZVxuICAgICAgICAgICAgICAgIGlucHV0U291cmNlID0gaW5wdXRTb3VyY2Uuc2xpY2UodGhpcy5fY29udGVudHNJZ25vcmVkQ2hhcnNNYXBbZmlsZUluZm8uZmlsZW5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0U291cmNlID0gaW5wdXRTb3VyY2Uuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgIHNvdXJjZUxpbmVzID0gaW5wdXRTb3VyY2Uuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICBzb3VyY2VDb2x1bW5zID0gc291cmNlTGluZXNbc291cmNlTGluZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lcyA9IGNodW5rLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICBjb2x1bW5zID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGZpbGVJbmZvKSB7XG4gICAgICAgICAgICBpZiAoIW1hcExpbmVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwR2VuZXJhdG9yLmFkZE1hcHBpbmcoeyBnZW5lcmF0ZWQ6IHsgbGluZTogdGhpcy5fbGluZU51bWJlciArIDEsIGNvbHVtbjogdGhpcy5fY29sdW1ufSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWw6IHsgbGluZTogc291cmNlTGluZXMubGVuZ3RoLCBjb2x1bW46IHNvdXJjZUNvbHVtbnMubGVuZ3RofSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLm5vcm1hbGl6ZUZpbGVuYW1lKGZpbGVJbmZvLmZpbGVuYW1lKX0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwR2VuZXJhdG9yLmFkZE1hcHBpbmcoeyBnZW5lcmF0ZWQ6IHsgbGluZTogdGhpcy5fbGluZU51bWJlciArIGkgKyAxLCBjb2x1bW46IGkgPT09IDAgPyB0aGlzLl9jb2x1bW4gOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsOiB7IGxpbmU6IHNvdXJjZUxpbmVzLmxlbmd0aCArIGksIGNvbHVtbjogaSA9PT0gMCA/IHNvdXJjZUNvbHVtbnMubGVuZ3RoIDogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMubm9ybWFsaXplRmlsZW5hbWUoZmlsZUluZm8uZmlsZW5hbWUpfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fY29sdW1uICs9IGNvbHVtbnMubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbGluZU51bWJlciArPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdGhpcy5fY29sdW1uID0gY29sdW1ucy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jc3MucHVzaChjaHVuayk7XG4gICAgfTtcblxuICAgIFNvdXJjZU1hcE91dHB1dC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3NzLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuXG4gICAgU291cmNlTWFwT3V0cHV0LnByb3RvdHlwZS50b0NTUyA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fc291cmNlTWFwR2VuZXJhdG9yID0gbmV3IHRoaXMuX3NvdXJjZU1hcEdlbmVyYXRvckNvbnN0cnVjdG9yKHsgZmlsZTogdGhpcy5fb3V0cHV0RmlsZW5hbWUsIHNvdXJjZVJvb3Q6IG51bGwgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX291dHB1dFNvdXJjZUZpbGVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBmaWxlbmFtZSBpbiB0aGlzLl9jb250ZW50c01hcCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb250ZW50c01hcC5oYXNPd25Qcm9wZXJ0eShmaWxlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuX2NvbnRlbnRzTWFwW2ZpbGVuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnRzSWdub3JlZENoYXJzTWFwW2ZpbGVuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gc291cmNlLnNsaWNlKHRoaXMuX2NvbnRlbnRzSWdub3JlZENoYXJzTWFwW2ZpbGVuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwR2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQodGhpcy5ub3JtYWxpemVGaWxlbmFtZShmaWxlbmFtZSksIHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcm9vdE5vZGUuZ2VuQ1NTKGNvbnRleHQsIHRoaXMpO1xuXG4gICAgICAgIGlmICh0aGlzLl9jc3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZU1hcFVSTCxcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodGhpcy5fc291cmNlTWFwR2VuZXJhdG9yLnRvSlNPTigpKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlTWFwVVJMKSB7XG4gICAgICAgICAgICAgICAgc291cmNlTWFwVVJMID0gdGhpcy5zb3VyY2VNYXBVUkw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZU1hcEZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgc291cmNlTWFwVVJMID0gdGhpcy5fc291cmNlTWFwRmlsZW5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvdXJjZU1hcFVSTCA9IHNvdXJjZU1hcFVSTDtcblxuICAgICAgICAgICAgdGhpcy5zb3VyY2VNYXAgPSBzb3VyY2VNYXBDb250ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nzcy5qb2luKCcnKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNvdXJjZU1hcE91dHB1dDtcbn07XG5cbn0se31dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBjb250ZXh0cyA9IHJlcXVpcmUoXCIuL2NvbnRleHRzXCIpLFxuICAgIHZpc2l0b3IgPSByZXF1aXJlKFwiLi92aXNpdG9yc1wiKSxcbiAgICB0cmVlID0gcmVxdWlyZShcIi4vdHJlZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyb290LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGV2YWxkUm9vdCxcbiAgICAgICAgdmFyaWFibGVzID0gb3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgIGV2YWxFbnYgPSBuZXcgY29udGV4dHMuRXZhbChvcHRpb25zKTtcblxuICAgIC8vXG4gICAgLy8gQWxsb3dzIHNldHRpbmcgdmFyaWFibGVzIHdpdGggYSBoYXNoLCBzbzpcbiAgICAvL1xuICAgIC8vICAgYHsgY29sb3I6IG5ldyB0cmVlLkNvbG9yKCcjZjAxJykgfWAgd2lsbCBiZWNvbWU6XG4gICAgLy9cbiAgICAvLyAgIG5ldyB0cmVlLlJ1bGUoJ0Bjb2xvcicsXG4gICAgLy8gICAgIG5ldyB0cmVlLlZhbHVlKFtcbiAgICAvLyAgICAgICBuZXcgdHJlZS5FeHByZXNzaW9uKFtcbiAgICAvLyAgICAgICAgIG5ldyB0cmVlLkNvbG9yKCcjZjAxJylcbiAgICAvLyAgICAgICBdKVxuICAgIC8vICAgICBdKVxuICAgIC8vICAgKVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiB2YXJpYWJsZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhcmlhYmxlcykpIHtcbiAgICAgICAgdmFyaWFibGVzID0gT2JqZWN0LmtleXModmFyaWFibGVzKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhcmlhYmxlc1trXTtcblxuICAgICAgICAgICAgaWYgKCEgKHZhbHVlIGluc3RhbmNlb2YgdHJlZS5WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoISAodmFsdWUgaW5zdGFuY2VvZiB0cmVlLkV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IHRyZWUuRXhwcmVzc2lvbihbdmFsdWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgdHJlZS5WYWx1ZShbdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5SdWxlKCdAJyArIGssIHZhbHVlLCBmYWxzZSwgbnVsbCwgMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBldmFsRW52LmZyYW1lcyA9IFtuZXcgdHJlZS5SdWxlc2V0KG51bGwsIHZhcmlhYmxlcyldO1xuICAgIH1cblxuICAgIHZhciBwcmVFdmFsVmlzaXRvcnMgPSBbXSxcbiAgICAgICAgdmlzaXRvcnMgPSBbXG4gICAgICAgICAgICBuZXcgdmlzaXRvci5Kb2luU2VsZWN0b3JWaXNpdG9yKCksXG4gICAgICAgICAgICBuZXcgdmlzaXRvci5NYXJrVmlzaWJsZVNlbGVjdG9yc1Zpc2l0b3IodHJ1ZSksXG4gICAgICAgICAgICBuZXcgdmlzaXRvci5FeHRlbmRWaXNpdG9yKCksXG4gICAgICAgICAgICBuZXcgdmlzaXRvci5Ub0NTU1Zpc2l0b3Ioe2NvbXByZXNzOiBCb29sZWFuKG9wdGlvbnMuY29tcHJlc3MpfSlcbiAgICAgICAgXSwgaTtcblxuICAgIGlmIChvcHRpb25zLnBsdWdpbk1hbmFnZXIpIHtcbiAgICAgICAgdmFyIHBsdWdpblZpc2l0b3JzID0gb3B0aW9ucy5wbHVnaW5NYW5hZ2VyLmdldFZpc2l0b3JzKCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwbHVnaW5WaXNpdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBsdWdpblZpc2l0b3IgPSBwbHVnaW5WaXNpdG9yc1tpXTtcbiAgICAgICAgICAgIGlmIChwbHVnaW5WaXNpdG9yLmlzUHJlRXZhbFZpc2l0b3IpIHtcbiAgICAgICAgICAgICAgICBwcmVFdmFsVmlzaXRvcnMucHVzaChwbHVnaW5WaXNpdG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpblZpc2l0b3IuaXNQcmVWaXNpdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0b3JzLnNwbGljZSgwLCAwLCBwbHVnaW5WaXNpdG9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2aXNpdG9ycy5wdXNoKHBsdWdpblZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBwcmVFdmFsVmlzaXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlRXZhbFZpc2l0b3JzW2ldLnJ1bihyb290KTtcbiAgICB9XG5cbiAgICBldmFsZFJvb3QgPSByb290LmV2YWwoZXZhbEVudik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdmlzaXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmlzaXRvcnNbaV0ucnVuKGV2YWxkUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2YWxkUm9vdDtcbn07XG5cbn0se1wiLi9jb250ZXh0c1wiOjExLFwiLi90cmVlXCI6NjIsXCIuL3Zpc2l0b3JzXCI6ODd9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIik7XG5cbnZhciBBbHBoYSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsO1xufTtcbkFscGhhLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5BbHBoYS5wcm90b3R5cGUudHlwZSA9IFwiQWxwaGFcIjtcblxuQWxwaGEucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZpc2l0b3IudmlzaXQodGhpcy52YWx1ZSk7XG59O1xuQWxwaGEucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmICh0aGlzLnZhbHVlLmV2YWwpIHsgcmV0dXJuIG5ldyBBbHBoYSh0aGlzLnZhbHVlLmV2YWwoY29udGV4dCkpOyB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuQWxwaGEucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICBvdXRwdXQuYWRkKFwiYWxwaGEob3BhY2l0eT1cIik7XG5cbiAgICBpZiAodGhpcy52YWx1ZS5nZW5DU1MpIHtcbiAgICAgICAgdGhpcy52YWx1ZS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQuYWRkKHRoaXMudmFsdWUpO1xuICAgIH1cblxuICAgIG91dHB1dC5hZGQoXCIpXCIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbHBoYTtcblxufSx7XCIuL25vZGVcIjo3MH1dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKTtcblxudmFyIEFub255bW91cyA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgbWFwTGluZXMsIHJ1bGVzZXRMaWtlLCB2aXNpYmlsaXR5SW5mbykge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5tYXBMaW5lcyA9IG1hcExpbmVzO1xuICAgIHRoaXMuY3VycmVudEZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xuICAgIHRoaXMucnVsZXNldExpa2UgPSAodHlwZW9mIHJ1bGVzZXRMaWtlID09PSAndW5kZWZpbmVkJykgPyBmYWxzZSA6IHJ1bGVzZXRMaWtlO1xuICAgIHRoaXMuYWxsb3dSb290ID0gdHJ1ZTtcbiAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XG59O1xuQW5vbnltb3VzLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5Bbm9ueW1vdXMucHJvdG90eXBlLnR5cGUgPSBcIkFub255bW91c1wiO1xuQW5vbnltb3VzLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzKHRoaXMudmFsdWUsIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvLCB0aGlzLm1hcExpbmVzLCB0aGlzLnJ1bGVzZXRMaWtlLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xufTtcbkFub255bW91cy5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHJldHVybiBvdGhlci50b0NTUyAmJiB0aGlzLnRvQ1NTKCkgPT09IG90aGVyLnRvQ1NTKCkgPyAwIDogdW5kZWZpbmVkO1xufTtcbkFub255bW91cy5wcm90b3R5cGUuaXNSdWxlc2V0TGlrZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzZXRMaWtlO1xufTtcbkFub255bW91cy5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIG91dHB1dC5hZGQodGhpcy52YWx1ZSwgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRoaXMuaW5kZXgsIHRoaXMubWFwTGluZXMpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQW5vbnltb3VzO1xuXG59LHtcIi4vbm9kZVwiOjcwfV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuXG52YXIgQXNzaWdubWVudCA9IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMudmFsdWUgPSB2YWw7XG59O1xuXG5Bc3NpZ25tZW50LnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5Bc3NpZ25tZW50LnByb3RvdHlwZS50eXBlID0gXCJBc3NpZ25tZW50XCI7XG5Bc3NpZ25tZW50LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgIHRoaXMudmFsdWUgPSB2aXNpdG9yLnZpc2l0KHRoaXMudmFsdWUpO1xufTtcbkFzc2lnbm1lbnQucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmICh0aGlzLnZhbHVlLmV2YWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3NpZ25tZW50KHRoaXMua2V5LCB0aGlzLnZhbHVlLmV2YWwoY29udGV4dCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5Bc3NpZ25tZW50LnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LmFkZCh0aGlzLmtleSArICc9Jyk7XG4gICAgaWYgKHRoaXMudmFsdWUuZ2VuQ1NTKSB7XG4gICAgICAgIHRoaXMudmFsdWUuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LmFkZCh0aGlzLnZhbHVlKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBc3NpZ25tZW50O1xuXG59LHtcIi4vbm9kZVwiOjcwfV0sNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuXG52YXIgQXR0cmlidXRlID0gZnVuY3Rpb24gKGtleSwgb3AsIHZhbHVlKSB7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcCA9IG9wO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn07XG5BdHRyaWJ1dGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbkF0dHJpYnV0ZS5wcm90b3R5cGUudHlwZSA9IFwiQXR0cmlidXRlXCI7XG5BdHRyaWJ1dGUucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQXR0cmlidXRlKHRoaXMua2V5LmV2YWwgPyB0aGlzLmtleS5ldmFsKGNvbnRleHQpIDogdGhpcy5rZXksXG4gICAgICAgIHRoaXMub3AsICh0aGlzLnZhbHVlICYmIHRoaXMudmFsdWUuZXZhbCkgPyB0aGlzLnZhbHVlLmV2YWwoY29udGV4dCkgOiB0aGlzLnZhbHVlKTtcbn07XG5BdHRyaWJ1dGUucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICBvdXRwdXQuYWRkKHRoaXMudG9DU1MoY29udGV4dCkpO1xufTtcbkF0dHJpYnV0ZS5wcm90b3R5cGUudG9DU1MgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMua2V5LnRvQ1NTID8gdGhpcy5rZXkudG9DU1MoY29udGV4dCkgOiB0aGlzLmtleTtcblxuICAgIGlmICh0aGlzLm9wKSB7XG4gICAgICAgIHZhbHVlICs9IHRoaXMub3A7XG4gICAgICAgIHZhbHVlICs9ICh0aGlzLnZhbHVlLnRvQ1NTID8gdGhpcy52YWx1ZS50b0NTUyhjb250ZXh0KSA6IHRoaXMudmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiAnWycgKyB2YWx1ZSArICddJztcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEF0dHJpYnV0ZTtcblxufSx7XCIuL25vZGVcIjo3MH1dLDQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICBGdW5jdGlvbkNhbGxlciA9IHJlcXVpcmUoXCIuLi9mdW5jdGlvbnMvZnVuY3Rpb24tY2FsbGVyXCIpO1xuLy9cbi8vIEEgZnVuY3Rpb24gY2FsbCBub2RlLlxuLy9cbnZhciBDYWxsID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MsIGluZGV4LCBjdXJyZW50RmlsZUluZm8pIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY3VycmVudEZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xufTtcbkNhbGwucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbkNhbGwucHJvdG90eXBlLnR5cGUgPSBcIkNhbGxcIjtcbkNhbGwucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgaWYgKHRoaXMuYXJncykge1xuICAgICAgICB0aGlzLmFyZ3MgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy5hcmdzKTtcbiAgICB9XG59O1xuLy9cbi8vIFdoZW4gZXZhbHVhdGluZyBhIGZ1bmN0aW9uIGNhbGwsXG4vLyB3ZSBlaXRoZXIgZmluZCB0aGUgZnVuY3Rpb24gaW4gdGhlIGZ1bmN0aW9uUmVnaXN0cnksXG4vLyBpbiB3aGljaCBjYXNlIHdlIGNhbGwgaXQsIHBhc3NpbmcgdGhlICBldmFsdWF0ZWQgYXJndW1lbnRzLFxuLy8gaWYgdGhpcyByZXR1cm5zIG51bGwgb3Igd2UgY2Fubm90IGZpbmQgdGhlIGZ1bmN0aW9uLCB3ZVxuLy8gc2ltcGx5IHByaW50IGl0IG91dCBhcyBpdCBhcHBlYXJlZCBvcmlnaW5hbGx5IFsyXS5cbi8vXG4vLyBUaGUgcmVhc29uIHdoeSB3ZSBldmFsdWF0ZSB0aGUgYXJndW1lbnRzLCBpcyBpbiB0aGUgY2FzZSB3aGVyZVxuLy8gd2UgdHJ5IHRvIHBhc3MgYSB2YXJpYWJsZSB0byBhIGZ1bmN0aW9uLCBsaWtlOiBgc2F0dXJhdGUoQGNvbG9yKWAuXG4vLyBUaGUgZnVuY3Rpb24gc2hvdWxkIHJlY2VpdmUgdGhlIHZhbHVlLCBub3QgdGhlIHZhcmlhYmxlLlxuLy9cbkNhbGwucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBhcmdzID0gdGhpcy5hcmdzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5ldmFsKGNvbnRleHQpOyB9KSxcbiAgICAgICAgcmVzdWx0LCBmdW5jQ2FsbGVyID0gbmV3IEZ1bmN0aW9uQ2FsbGVyKHRoaXMubmFtZSwgY29udGV4dCwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pO1xuXG4gICAgaWYgKGZ1bmNDYWxsZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jQ2FsbGVyLmNhbGwoYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IHsgdHlwZTogZS50eXBlIHx8IFwiUnVudGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcImVycm9yIGV2YWx1YXRpbmcgZnVuY3Rpb24gYFwiICsgdGhpcy5uYW1lICsgXCJgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZS5tZXNzYWdlID8gJzogJyArIGUubWVzc2FnZSA6ICcnKSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsIGZpbGVuYW1lOiB0aGlzLmN1cnJlbnRGaWxlSW5mby5maWxlbmFtZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgcmVzdWx0LmN1cnJlbnRGaWxlSW5mbyA9IHRoaXMuY3VycmVudEZpbGVJbmZvO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ2FsbCh0aGlzLm5hbWUsIGFyZ3MsIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvKTtcbn07XG5DYWxsLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LmFkZCh0aGlzLm5hbWUgKyBcIihcIiwgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRoaXMuaW5kZXgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hcmdzW2ldLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgICAgICBpZiAoaSArIDEgPCB0aGlzLmFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXRwdXQuYWRkKFwiLCBcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvdXRwdXQuYWRkKFwiKVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IENhbGw7XG5cbn0se1wiLi4vZnVuY3Rpb25zL2Z1bmN0aW9uLWNhbGxlclwiOjIxLFwiLi9ub2RlXCI6NzB9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIiksXG4gICAgY29sb3JzID0gcmVxdWlyZShcIi4uL2RhdGEvY29sb3JzXCIpO1xuXG4vL1xuLy8gUkdCIENvbG9ycyAtICNmZjAwMTQsICNlZWVcbi8vXG52YXIgQ29sb3IgPSBmdW5jdGlvbiAocmdiLCBhLCBvcmlnaW5hbEZvcm0pIHtcbiAgICAvL1xuICAgIC8vIFRoZSBlbmQgZ29hbCBoZXJlLCBpcyB0byBwYXJzZSB0aGUgYXJndW1lbnRzXG4gICAgLy8gaW50byBhbiBpbnRlZ2VyIHRyaXBsZXQsIHN1Y2ggYXMgYDEyOCwgMjU1LCAwYFxuICAgIC8vXG4gICAgLy8gVGhpcyBmYWNpbGl0YXRlcyBvcGVyYXRpb25zIGFuZCBjb252ZXJzaW9ucy5cbiAgICAvL1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJnYikpIHtcbiAgICAgICAgdGhpcy5yZ2IgPSByZ2I7XG4gICAgfSBlbHNlIGlmIChyZ2IubGVuZ3RoID09IDYpIHtcbiAgICAgICAgdGhpcy5yZ2IgPSByZ2IubWF0Y2goLy57Mn0vZykubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoYywgMTYpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJnYiA9IHJnYi5zcGxpdCgnJykubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoYyArIGMsIDE2KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuYWxwaGEgPSB0eXBlb2YgYSA9PT0gJ251bWJlcicgPyBhIDogMTtcbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsRm9ybSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG9yaWdpbmFsRm9ybTtcbiAgICB9XG59O1xuXG5Db2xvci5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuQ29sb3IucHJvdG90eXBlLnR5cGUgPSBcIkNvbG9yXCI7XG5cbmZ1bmN0aW9uIGNsYW1wKHYsIG1heCkge1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2LCAwKSwgbWF4KTtcbn1cblxuZnVuY3Rpb24gdG9IZXgodikge1xuICAgIHJldHVybiAnIycgKyB2Lm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICBjID0gY2xhbXAoTWF0aC5yb3VuZChjKSwgMjU1KTtcbiAgICAgICAgcmV0dXJuIChjIDwgMTYgPyAnMCcgOiAnJykgKyBjLnRvU3RyaW5nKDE2KTtcbiAgICB9KS5qb2luKCcnKTtcbn1cblxuQ29sb3IucHJvdG90eXBlLmx1bWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHIgPSB0aGlzLnJnYlswXSAvIDI1NSxcbiAgICAgICAgZyA9IHRoaXMucmdiWzFdIC8gMjU1LFxuICAgICAgICBiID0gdGhpcy5yZ2JbMl0gLyAyNTU7XG5cbiAgICByID0gKHIgPD0gMC4wMzkyOCkgPyByIC8gMTIuOTIgOiBNYXRoLnBvdygoKHIgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCk7XG4gICAgZyA9IChnIDw9IDAuMDM5MjgpID8gZyAvIDEyLjkyIDogTWF0aC5wb3coKChnICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO1xuICAgIGIgPSAoYiA8PSAwLjAzOTI4KSA/IGIgLyAxMi45MiA6IE1hdGgucG93KCgoYiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTtcblxuICAgIHJldHVybiAwLjIxMjYgKiByICsgMC43MTUyICogZyArIDAuMDcyMiAqIGI7XG59O1xuQ29sb3IucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICBvdXRwdXQuYWRkKHRoaXMudG9DU1MoY29udGV4dCkpO1xufTtcbkNvbG9yLnByb3RvdHlwZS50b0NTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBkb05vdENvbXByZXNzKSB7XG4gICAgdmFyIGNvbXByZXNzID0gY29udGV4dCAmJiBjb250ZXh0LmNvbXByZXNzICYmICFkb05vdENvbXByZXNzLCBjb2xvciwgYWxwaGE7XG5cbiAgICAvLyBgdmFsdWVgIGlzIHNldCBpZiB0aGlzIGNvbG9yIHdhcyBvcmlnaW5hbGx5XG4gICAgLy8gY29udmVydGVkIGZyb20gYSBuYW1lZCBjb2xvciBzdHJpbmcgc28gd2UgbmVlZFxuICAgIC8vIHRvIHJlc3BlY3QgdGhpcyBhbmQgdHJ5IHRvIG91dHB1dCBuYW1lZCBjb2xvciB0b28uXG4gICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBzb21lIHRyYW5zcGFyZW5jeSwgdGhlIG9ubHkgd2F5IHRvIHJlcHJlc2VudCBpdFxuICAgIC8vIGlzIHZpYSBgcmdiYWAuIE90aGVyd2lzZSwgd2UgdXNlIHRoZSBoZXggcmVwcmVzZW50YXRpb24sXG4gICAgLy8gd2hpY2ggaGFzIGJldHRlciBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgYnJvd3NlcnMuXG4gICAgLy8gVmFsdWVzIGFyZSBjYXBwZWQgYmV0d2VlbiBgMGAgYW5kIGAyNTVgLCByb3VuZGVkIGFuZCB6ZXJvLXBhZGRlZC5cbiAgICBhbHBoYSA9IHRoaXMuZnJvdW5kKGNvbnRleHQsIHRoaXMuYWxwaGEpO1xuICAgIGlmIChhbHBoYSA8IDEpIHtcbiAgICAgICAgcmV0dXJuIFwicmdiYShcIiArIHRoaXMucmdiLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIGNsYW1wKE1hdGgucm91bmQoYyksIDI1NSk7XG4gICAgICAgIH0pLmNvbmNhdChjbGFtcChhbHBoYSwgMSkpXG4gICAgICAgICAgICAuam9pbignLCcgKyAoY29tcHJlc3MgPyAnJyA6ICcgJykpICsgXCIpXCI7XG4gICAgfVxuXG4gICAgY29sb3IgPSB0aGlzLnRvUkdCKCk7XG5cbiAgICBpZiAoY29tcHJlc3MpIHtcbiAgICAgICAgdmFyIHNwbGl0Y29sb3IgPSBjb2xvci5zcGxpdCgnJyk7XG5cbiAgICAgICAgLy8gQ29udmVydCBjb2xvciB0byBzaG9ydCBmb3JtYXRcbiAgICAgICAgaWYgKHNwbGl0Y29sb3JbMV0gPT09IHNwbGl0Y29sb3JbMl0gJiYgc3BsaXRjb2xvclszXSA9PT0gc3BsaXRjb2xvcls0XSAmJiBzcGxpdGNvbG9yWzVdID09PSBzcGxpdGNvbG9yWzZdKSB7XG4gICAgICAgICAgICBjb2xvciA9ICcjJyArIHNwbGl0Y29sb3JbMV0gKyBzcGxpdGNvbG9yWzNdICsgc3BsaXRjb2xvcls1XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb2xvcjtcbn07XG5cbi8vXG4vLyBPcGVyYXRpb25zIGhhdmUgdG8gYmUgZG9uZSBwZXItY2hhbm5lbCwgaWYgbm90LFxuLy8gY2hhbm5lbHMgd2lsbCBzcGlsbCBvbnRvIGVhY2ggb3RoZXIuIE9uY2Ugd2UgaGF2ZVxuLy8gb3VyIHJlc3VsdCwgaW4gdGhlIGZvcm0gb2YgYW4gaW50ZWdlciB0cmlwbGV0LFxuLy8gd2UgY3JlYXRlIGEgbmV3IENvbG9yIG5vZGUgdG8gaG9sZCB0aGUgcmVzdWx0LlxuLy9cbkNvbG9yLnByb3RvdHlwZS5vcGVyYXRlID0gZnVuY3Rpb24gKGNvbnRleHQsIG9wLCBvdGhlcikge1xuICAgIHZhciByZ2IgPSBbXTtcbiAgICB2YXIgYWxwaGEgPSB0aGlzLmFscGhhICogKDEgLSBvdGhlci5hbHBoYSkgKyBvdGhlci5hbHBoYTtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IDM7IGMrKykge1xuICAgICAgICByZ2JbY10gPSB0aGlzLl9vcGVyYXRlKGNvbnRleHQsIG9wLCB0aGlzLnJnYltjXSwgb3RoZXIucmdiW2NdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb2xvcihyZ2IsIGFscGhhKTtcbn07XG5Db2xvci5wcm90b3R5cGUudG9SR0IgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRvSGV4KHRoaXMucmdiKTtcbn07XG5Db2xvci5wcm90b3R5cGUudG9IU0wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHIgPSB0aGlzLnJnYlswXSAvIDI1NSxcbiAgICAgICAgZyA9IHRoaXMucmdiWzFdIC8gMjU1LFxuICAgICAgICBiID0gdGhpcy5yZ2JbMl0gLyAyNTUsXG4gICAgICAgIGEgPSB0aGlzLmFscGhhO1xuXG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICB2YXIgaCwgcywgbCA9IChtYXggKyBtaW4pIC8gMiwgZCA9IG1heCAtIG1pbjtcblxuICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICBoID0gcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuXG4gICAgICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICAgICAgICBjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGc6IGggPSAoYiAtIHIpIC8gZCArIDI7ICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGI6IGggPSAociAtIGcpIC8gZCArIDQ7ICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaCAvPSA2O1xuICAgIH1cbiAgICByZXR1cm4geyBoOiBoICogMzYwLCBzOiBzLCBsOiBsLCBhOiBhIH07XG59O1xuLy9BZGFwdGVkIGZyb20gaHR0cDovL21qaWphY2tzb24uY29tLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdFxuQ29sb3IucHJvdG90eXBlLnRvSFNWID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByID0gdGhpcy5yZ2JbMF0gLyAyNTUsXG4gICAgICAgIGcgPSB0aGlzLnJnYlsxXSAvIDI1NSxcbiAgICAgICAgYiA9IHRoaXMucmdiWzJdIC8gMjU1LFxuICAgICAgICBhID0gdGhpcy5hbHBoYTtcblxuICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSwgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgdmFyIGgsIHMsIHYgPSBtYXg7XG5cbiAgICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgICBpZiAobWF4ID09PSAwKSB7XG4gICAgICAgIHMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSBkIC8gbWF4O1xuICAgIH1cblxuICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICBoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2gobWF4KSB7XG4gICAgICAgICAgICBjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGc6IGggPSAoYiAtIHIpIC8gZCArIDI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBoIC89IDY7XG4gICAgfVxuICAgIHJldHVybiB7IGg6IGggKiAzNjAsIHM6IHMsIHY6IHYsIGE6IGEgfTtcbn07XG5Db2xvci5wcm90b3R5cGUudG9BUkdCID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0b0hleChbdGhpcy5hbHBoYSAqIDI1NV0uY29uY2F0KHRoaXMucmdiKSk7XG59O1xuQ29sb3IucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiAoeC5yZ2IgJiZcbiAgICAgICAgeC5yZ2JbMF0gPT09IHRoaXMucmdiWzBdICYmXG4gICAgICAgIHgucmdiWzFdID09PSB0aGlzLnJnYlsxXSAmJlxuICAgICAgICB4LnJnYlsyXSA9PT0gdGhpcy5yZ2JbMl0gJiZcbiAgICAgICAgeC5hbHBoYSAgPT09IHRoaXMuYWxwaGEpID8gMCA6IHVuZGVmaW5lZDtcbn07XG5cbkNvbG9yLmZyb21LZXl3b3JkID0gZnVuY3Rpb24oa2V5d29yZCkge1xuICAgIHZhciBjLCBrZXkgPSBrZXl3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGNvbG9ycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGMgPSBuZXcgQ29sb3IoY29sb3JzW2tleV0uc2xpY2UoMSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXkgPT09IFwidHJhbnNwYXJlbnRcIikge1xuICAgICAgICBjID0gbmV3IENvbG9yKFswLCAwLCAwXSwgMCk7XG4gICAgfVxuXG4gICAgaWYgKGMpIHtcbiAgICAgICAgYy52YWx1ZSA9IGtleXdvcmQ7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xuXG59LHtcIi4uL2RhdGEvY29sb3JzXCI6MTIsXCIuL25vZGVcIjo3MH1dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKTtcblxudmFyIENvbWJpbmF0b3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09ICcgJykge1xuICAgICAgICB0aGlzLnZhbHVlID0gJyAnO1xuICAgICAgICB0aGlzLmVtcHR5T3JXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWUgPyB2YWx1ZS50cmltKCkgOiBcIlwiO1xuICAgICAgICB0aGlzLmVtcHR5T3JXaGl0ZXNwYWNlID0gdGhpcy52YWx1ZSA9PT0gXCJcIjtcbiAgICB9XG59O1xuQ29tYmluYXRvci5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuQ29tYmluYXRvci5wcm90b3R5cGUudHlwZSA9IFwiQ29tYmluYXRvclwiO1xudmFyIF9ub1NwYWNlQ29tYmluYXRvcnMgPSB7XG4gICAgJyc6IHRydWUsXG4gICAgJyAnOiB0cnVlLFxuICAgICd8JzogdHJ1ZVxufTtcbkNvbWJpbmF0b3IucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICB2YXIgc3BhY2VPckVtcHR5ID0gKGNvbnRleHQuY29tcHJlc3MgfHwgX25vU3BhY2VDb21iaW5hdG9yc1t0aGlzLnZhbHVlXSkgPyAnJyA6ICcgJztcbiAgICBvdXRwdXQuYWRkKHNwYWNlT3JFbXB0eSArIHRoaXMudmFsdWUgKyBzcGFjZU9yRW1wdHkpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ29tYmluYXRvcjtcblxufSx7XCIuL25vZGVcIjo3MH1dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICBnZXREZWJ1Z0luZm8gPSByZXF1aXJlKFwiLi9kZWJ1Zy1pbmZvXCIpO1xuXG52YXIgQ29tbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSwgaXNMaW5lQ29tbWVudCwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbykge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmlzTGluZUNvbW1lbnQgPSBpc0xpbmVDb21tZW50O1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmN1cnJlbnRGaWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcbiAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XG59O1xuQ29tbWVudC5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuQ29tbWVudC5wcm90b3R5cGUudHlwZSA9IFwiQ29tbWVudFwiO1xuQ29tbWVudC5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIGlmICh0aGlzLmRlYnVnSW5mbykge1xuICAgICAgICBvdXRwdXQuYWRkKGdldERlYnVnSW5mbyhjb250ZXh0LCB0aGlzKSwgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICBvdXRwdXQuYWRkKHRoaXMudmFsdWUpO1xufTtcbkNvbW1lbnQucHJvdG90eXBlLmlzU2lsZW50ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBpc0NvbXByZXNzZWQgPSBjb250ZXh0LmNvbXByZXNzICYmIHRoaXMudmFsdWVbMl0gIT09IFwiIVwiO1xuICAgIHJldHVybiB0aGlzLmlzTGluZUNvbW1lbnQgfHwgaXNDb21wcmVzc2VkO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ29tbWVudDtcblxufSx7XCIuL2RlYnVnLWluZm9cIjo1NCxcIi4vbm9kZVwiOjcwfV0sNTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuXG52YXIgQ29uZGl0aW9uID0gZnVuY3Rpb24gKG9wLCBsLCByLCBpLCBuZWdhdGUpIHtcbiAgICB0aGlzLm9wID0gb3AudHJpbSgpO1xuICAgIHRoaXMubHZhbHVlID0gbDtcbiAgICB0aGlzLnJ2YWx1ZSA9IHI7XG4gICAgdGhpcy5pbmRleCA9IGk7XG4gICAgdGhpcy5uZWdhdGUgPSBuZWdhdGU7XG59O1xuQ29uZGl0aW9uLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5Db25kaXRpb24ucHJvdG90eXBlLnR5cGUgPSBcIkNvbmRpdGlvblwiO1xuQ29uZGl0aW9uLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgIHRoaXMubHZhbHVlID0gdmlzaXRvci52aXNpdCh0aGlzLmx2YWx1ZSk7XG4gICAgdGhpcy5ydmFsdWUgPSB2aXNpdG9yLnZpc2l0KHRoaXMucnZhbHVlKTtcbn07XG5Db25kaXRpb24ucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAoZnVuY3Rpb24gKG9wLCBhLCBiKSB7XG4gICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgIGNhc2UgJ2FuZCc6IHJldHVybiBhICYmIGI7XG4gICAgICAgICAgICBjYXNlICdvcic6ICByZXR1cm4gYSB8fCBiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKE5vZGUuY29tcGFyZShhLCBiKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wID09PSAnPCcgfHwgb3AgPT09ICc9PCcgfHwgb3AgPT09ICc8PSc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcCA9PT0gJz0nIHx8IG9wID09PSAnPj0nIHx8IG9wID09PSAnPTwnIHx8IG9wID09PSAnPD0nO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3AgPT09ICc+JyB8fCBvcCA9PT0gJz49JztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSh0aGlzLm9wLCB0aGlzLmx2YWx1ZS5ldmFsKGNvbnRleHQpLCB0aGlzLnJ2YWx1ZS5ldmFsKGNvbnRleHQpKTtcblxuICAgIHJldHVybiB0aGlzLm5lZ2F0ZSA/ICFyZXN1bHQgOiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDb25kaXRpb247XG5cbn0se1wiLi9ub2RlXCI6NzB9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZGVidWdJbmZvID0gZnVuY3Rpb24oY29udGV4dCwgY3R4LCBsaW5lU2VwYXJhdG9yKSB7XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgaWYgKGNvbnRleHQuZHVtcExpbmVOdW1iZXJzICYmICFjb250ZXh0LmNvbXByZXNzKSB7XG4gICAgICAgIHN3aXRjaChjb250ZXh0LmR1bXBMaW5lTnVtYmVycykge1xuICAgICAgICAgICAgY2FzZSAnY29tbWVudHMnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlYnVnSW5mby5hc0NvbW1lbnQoY3R4KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21lZGlhcXVlcnknOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlYnVnSW5mby5hc01lZGlhUXVlcnkoY3R4KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVidWdJbmZvLmFzQ29tbWVudChjdHgpICsgKGxpbmVTZXBhcmF0b3IgfHwgXCJcIikgKyBkZWJ1Z0luZm8uYXNNZWRpYVF1ZXJ5KGN0eCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmRlYnVnSW5mby5hc0NvbW1lbnQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICByZXR1cm4gJy8qIGxpbmUgJyArIGN0eC5kZWJ1Z0luZm8ubGluZU51bWJlciArICcsICcgKyBjdHguZGVidWdJbmZvLmZpbGVOYW1lICsgJyAqL1xcbic7XG59O1xuXG5kZWJ1Z0luZm8uYXNNZWRpYVF1ZXJ5ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgdmFyIGZpbGVuYW1lV2l0aFByb3RvY29sID0gY3R4LmRlYnVnSW5mby5maWxlTmFtZTtcbiAgICBpZiAoIS9eW2Etel0rOlxcL1xcLy9pLnRlc3QoZmlsZW5hbWVXaXRoUHJvdG9jb2wpKSB7XG4gICAgICAgIGZpbGVuYW1lV2l0aFByb3RvY29sID0gJ2ZpbGU6Ly8nICsgZmlsZW5hbWVXaXRoUHJvdG9jb2w7XG4gICAgfVxuICAgIHJldHVybiAnQG1lZGlhIC1zYXNzLWRlYnVnLWluZm97ZmlsZW5hbWV7Zm9udC1mYW1pbHk6JyArXG4gICAgICAgIGZpbGVuYW1lV2l0aFByb3RvY29sLnJlcGxhY2UoLyhbLjpcXC9cXFxcXSkvZywgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGlmIChhID09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGEgPSAnXFwvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnXFxcXCcgKyBhO1xuICAgICAgICB9KSArXG4gICAgICAgICd9bGluZXtmb250LWZhbWlseTpcXFxcMDAwMDMnICsgY3R4LmRlYnVnSW5mby5saW5lTnVtYmVyICsgJ319XFxuJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidWdJbmZvO1xuXG59LHt9XSw1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIiksXG4gICAgY29udGV4dHMgPSByZXF1aXJlKFwiLi4vY29udGV4dHNcIik7XG5cbnZhciBEZXRhY2hlZFJ1bGVzZXQgPSBmdW5jdGlvbiAocnVsZXNldCwgZnJhbWVzKSB7XG4gICAgdGhpcy5ydWxlc2V0ID0gcnVsZXNldDtcbiAgICB0aGlzLmZyYW1lcyA9IGZyYW1lcztcbn07XG5EZXRhY2hlZFJ1bGVzZXQucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbkRldGFjaGVkUnVsZXNldC5wcm90b3R5cGUudHlwZSA9IFwiRGV0YWNoZWRSdWxlc2V0XCI7XG5EZXRhY2hlZFJ1bGVzZXQucHJvdG90eXBlLmV2YWxGaXJzdCA9IHRydWU7XG5EZXRhY2hlZFJ1bGVzZXQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgdGhpcy5ydWxlc2V0ID0gdmlzaXRvci52aXNpdCh0aGlzLnJ1bGVzZXQpO1xufTtcbkRldGFjaGVkUnVsZXNldC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzIHx8IGNvbnRleHQuZnJhbWVzLnNsaWNlKDApO1xuICAgIHJldHVybiBuZXcgRGV0YWNoZWRSdWxlc2V0KHRoaXMucnVsZXNldCwgZnJhbWVzKTtcbn07XG5EZXRhY2hlZFJ1bGVzZXQucHJvdG90eXBlLmNhbGxFdmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlc2V0LmV2YWwodGhpcy5mcmFtZXMgPyBuZXcgY29udGV4dHMuRXZhbChjb250ZXh0LCB0aGlzLmZyYW1lcy5jb25jYXQoY29udGV4dC5mcmFtZXMpKSA6IGNvbnRleHQpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gRGV0YWNoZWRSdWxlc2V0O1xuXG59LHtcIi4uL2NvbnRleHRzXCI6MTEsXCIuL25vZGVcIjo3MH1dLDU2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICB1bml0Q29udmVyc2lvbnMgPSByZXF1aXJlKFwiLi4vZGF0YS91bml0LWNvbnZlcnNpb25zXCIpLFxuICAgIFVuaXQgPSByZXF1aXJlKFwiLi91bml0XCIpLFxuICAgIENvbG9yID0gcmVxdWlyZShcIi4vY29sb3JcIik7XG5cbi8vXG4vLyBBIG51bWJlciB3aXRoIGEgdW5pdFxuLy9cbnZhciBEaW1lbnNpb24gPSBmdW5jdGlvbiAodmFsdWUsIHVuaXQpIHtcbiAgICB0aGlzLnZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgdGhpcy51bml0ID0gKHVuaXQgJiYgdW5pdCBpbnN0YW5jZW9mIFVuaXQpID8gdW5pdCA6XG4gICAgICBuZXcgVW5pdCh1bml0ID8gW3VuaXRdIDogdW5kZWZpbmVkKTtcbn07XG5cbkRpbWVuc2lvbi5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuRGltZW5zaW9uLnByb3RvdHlwZS50eXBlID0gXCJEaW1lbnNpb25cIjtcbkRpbWVuc2lvbi5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICB0aGlzLnVuaXQgPSB2aXNpdG9yLnZpc2l0KHRoaXMudW5pdCk7XG59O1xuRGltZW5zaW9uLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcztcbn07XG5EaW1lbnNpb24ucHJvdG90eXBlLnRvQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcihbdGhpcy52YWx1ZSwgdGhpcy52YWx1ZSwgdGhpcy52YWx1ZV0pO1xufTtcbkRpbWVuc2lvbi5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIGlmICgoY29udGV4dCAmJiBjb250ZXh0LnN0cmljdFVuaXRzKSAmJiAhdGhpcy51bml0LmlzU2luZ3VsYXIoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aXBsZSB1bml0cyBpbiBkaW1lbnNpb24uIENvcnJlY3QgdGhlIHVuaXRzIG9yIHVzZSB0aGUgdW5pdCBmdW5jdGlvbi4gQmFkIHVuaXQ6IFwiICsgdGhpcy51bml0LnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHRoaXMuZnJvdW5kKGNvbnRleHQsIHRoaXMudmFsdWUpLFxuICAgICAgICBzdHJWYWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG5cbiAgICBpZiAodmFsdWUgIT09IDAgJiYgdmFsdWUgPCAwLjAwMDAwMSAmJiB2YWx1ZSA+IC0wLjAwMDAwMSkge1xuICAgICAgICAvLyB3b3VsZCBiZSBvdXRwdXQgMWUtNiBldGMuXG4gICAgICAgIHN0clZhbHVlID0gdmFsdWUudG9GaXhlZCgyMCkucmVwbGFjZSgvMCskLywgXCJcIik7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5jb21wcmVzcykge1xuICAgICAgICAvLyBaZXJvIHZhbHVlcyBkb2Vzbid0IG5lZWQgYSB1bml0XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiB0aGlzLnVuaXQuaXNMZW5ndGgoKSkge1xuICAgICAgICAgICAgb3V0cHV0LmFkZChzdHJWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGbG9hdCB2YWx1ZXMgZG9lc24ndCBuZWVkIGEgbGVhZGluZyB6ZXJvXG4gICAgICAgIGlmICh2YWx1ZSA+IDAgJiYgdmFsdWUgPCAxKSB7XG4gICAgICAgICAgICBzdHJWYWx1ZSA9IChzdHJWYWx1ZSkuc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3V0cHV0LmFkZChzdHJWYWx1ZSk7XG4gICAgdGhpcy51bml0LmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xufTtcblxuLy8gSW4gYW4gb3BlcmF0aW9uIGJldHdlZW4gdHdvIERpbWVuc2lvbnMsXG4vLyB3ZSBkZWZhdWx0IHRvIHRoZSBmaXJzdCBEaW1lbnNpb24ncyB1bml0LFxuLy8gc28gYDFweCArIDJgIHdpbGwgeWllbGQgYDNweGAuXG5EaW1lbnNpb24ucHJvdG90eXBlLm9wZXJhdGUgPSBmdW5jdGlvbiAoY29udGV4dCwgb3AsIG90aGVyKSB7XG4gICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSAqL1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuX29wZXJhdGUoY29udGV4dCwgb3AsIHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKSxcbiAgICAgICAgdW5pdCA9IHRoaXMudW5pdC5jbG9uZSgpO1xuXG4gICAgaWYgKG9wID09PSAnKycgfHwgb3AgPT09ICctJykge1xuICAgICAgICBpZiAodW5pdC5udW1lcmF0b3IubGVuZ3RoID09PSAwICYmIHVuaXQuZGVub21pbmF0b3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB1bml0ID0gb3RoZXIudW5pdC5jbG9uZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMudW5pdC5iYWNrdXBVbml0KSB7XG4gICAgICAgICAgICAgICAgdW5pdC5iYWNrdXBVbml0ID0gdGhpcy51bml0LmJhY2t1cFVuaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3RoZXIudW5pdC5udW1lcmF0b3IubGVuZ3RoID09PSAwICYmIHVuaXQuZGVub21pbmF0b3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlciA9IG90aGVyLmNvbnZlcnRUbyh0aGlzLnVuaXQudXNlZFVuaXRzKCkpO1xuXG4gICAgICAgICAgICBpZiAoY29udGV4dC5zdHJpY3RVbml0cyAmJiBvdGhlci51bml0LnRvU3RyaW5nKCkgIT09IHVuaXQudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGF0aWJsZSB1bml0cy4gQ2hhbmdlIHRoZSB1bml0cyBvciB1c2UgdGhlIHVuaXQgZnVuY3Rpb24uIEJhZCB1bml0czogJ1wiICsgdW5pdC50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgXCInIGFuZCAnXCIgKyBvdGhlci51bml0LnRvU3RyaW5nKCkgKyBcIicuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX29wZXJhdGUoY29udGV4dCwgb3AsIHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3AgPT09ICcqJykge1xuICAgICAgICB1bml0Lm51bWVyYXRvciA9IHVuaXQubnVtZXJhdG9yLmNvbmNhdChvdGhlci51bml0Lm51bWVyYXRvcikuc29ydCgpO1xuICAgICAgICB1bml0LmRlbm9taW5hdG9yID0gdW5pdC5kZW5vbWluYXRvci5jb25jYXQob3RoZXIudW5pdC5kZW5vbWluYXRvcikuc29ydCgpO1xuICAgICAgICB1bml0LmNhbmNlbCgpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICcvJykge1xuICAgICAgICB1bml0Lm51bWVyYXRvciA9IHVuaXQubnVtZXJhdG9yLmNvbmNhdChvdGhlci51bml0LmRlbm9taW5hdG9yKS5zb3J0KCk7XG4gICAgICAgIHVuaXQuZGVub21pbmF0b3IgPSB1bml0LmRlbm9taW5hdG9yLmNvbmNhdChvdGhlci51bml0Lm51bWVyYXRvcikuc29ydCgpO1xuICAgICAgICB1bml0LmNhbmNlbCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERpbWVuc2lvbih2YWx1ZSwgdW5pdCk7XG59O1xuRGltZW5zaW9uLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdmFyIGEsIGI7XG5cbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIERpbWVuc2lvbikpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy51bml0LmlzRW1wdHkoKSB8fCBvdGhlci51bml0LmlzRW1wdHkoKSkge1xuICAgICAgICBhID0gdGhpcztcbiAgICAgICAgYiA9IG90aGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGEgPSB0aGlzLnVuaWZ5KCk7XG4gICAgICAgIGIgPSBvdGhlci51bmlmeSgpO1xuICAgICAgICBpZiAoYS51bml0LmNvbXBhcmUoYi51bml0KSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBOb2RlLm51bWVyaWNDb21wYXJlKGEudmFsdWUsIGIudmFsdWUpO1xufTtcbkRpbWVuc2lvbi5wcm90b3R5cGUudW5pZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udmVydFRvKHsgbGVuZ3RoOiAncHgnLCBkdXJhdGlvbjogJ3MnLCBhbmdsZTogJ3JhZCcgfSk7XG59O1xuRGltZW5zaW9uLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiAoY29udmVyc2lvbnMpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLCB1bml0ID0gdGhpcy51bml0LmNsb25lKCksXG4gICAgICAgIGksIGdyb3VwTmFtZSwgZ3JvdXAsIHRhcmdldFVuaXQsIGRlcml2ZWRDb252ZXJzaW9ucyA9IHt9LCBhcHBseVVuaXQ7XG5cbiAgICBpZiAodHlwZW9mIGNvbnZlcnNpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3IgKGkgaW4gdW5pdENvbnZlcnNpb25zKSB7XG4gICAgICAgICAgICBpZiAodW5pdENvbnZlcnNpb25zW2ldLmhhc093blByb3BlcnR5KGNvbnZlcnNpb25zKSkge1xuICAgICAgICAgICAgICAgIGRlcml2ZWRDb252ZXJzaW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIGRlcml2ZWRDb252ZXJzaW9uc1tpXSA9IGNvbnZlcnNpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnZlcnNpb25zID0gZGVyaXZlZENvbnZlcnNpb25zO1xuICAgIH1cbiAgICBhcHBseVVuaXQgPSBmdW5jdGlvbiAoYXRvbWljVW5pdCwgZGVub21pbmF0b3IpIHtcbiAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cbiAgICAgICAgaWYgKGdyb3VwLmhhc093blByb3BlcnR5KGF0b21pY1VuaXQpKSB7XG4gICAgICAgICAgICBpZiAoZGVub21pbmF0b3IpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gKGdyb3VwW2F0b21pY1VuaXRdIC8gZ3JvdXBbdGFyZ2V0VW5pdF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICogKGdyb3VwW2F0b21pY1VuaXRdIC8gZ3JvdXBbdGFyZ2V0VW5pdF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0VW5pdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhdG9taWNVbml0O1xuICAgIH07XG5cbiAgICBmb3IgKGdyb3VwTmFtZSBpbiBjb252ZXJzaW9ucykge1xuICAgICAgICBpZiAoY29udmVyc2lvbnMuaGFzT3duUHJvcGVydHkoZ3JvdXBOYW1lKSkge1xuICAgICAgICAgICAgdGFyZ2V0VW5pdCA9IGNvbnZlcnNpb25zW2dyb3VwTmFtZV07XG4gICAgICAgICAgICBncm91cCA9IHVuaXRDb252ZXJzaW9uc1tncm91cE5hbWVdO1xuXG4gICAgICAgICAgICB1bml0Lm1hcChhcHBseVVuaXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdW5pdC5jYW5jZWwoKTtcblxuICAgIHJldHVybiBuZXcgRGltZW5zaW9uKHZhbHVlLCB1bml0KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERpbWVuc2lvbjtcblxufSx7XCIuLi9kYXRhL3VuaXQtY29udmVyc2lvbnNcIjoxNCxcIi4vY29sb3JcIjo1MCxcIi4vbm9kZVwiOjcwLFwiLi91bml0XCI6Nzl9XSw1NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIiksXG4gICAgU2VsZWN0b3IgPSByZXF1aXJlKFwiLi9zZWxlY3RvclwiKSxcbiAgICBSdWxlc2V0ID0gcmVxdWlyZShcIi4vcnVsZXNldFwiKTtcblxudmFyIERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcnVsZXMsIGluZGV4LCBjdXJyZW50RmlsZUluZm8sIGRlYnVnSW5mbywgaXNSb290ZWQsIHZpc2liaWxpdHlJbmZvKSB7XG4gICAgdmFyIGk7XG5cbiAgICB0aGlzLm5hbWUgID0gbmFtZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHJ1bGVzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJ1bGVzKSkge1xuICAgICAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ydWxlcyA9IFtydWxlc107XG4gICAgICAgICAgICB0aGlzLnJ1bGVzWzBdLnNlbGVjdG9ycyA9IChuZXcgU2VsZWN0b3IoW10sIG51bGwsIG51bGwsIHRoaXMuaW5kZXgsIGN1cnJlbnRGaWxlSW5mbykpLmNyZWF0ZUVtcHR5U2VsZWN0b3JzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucnVsZXNbaV0uYWxsb3dJbXBvcnRzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5jdXJyZW50RmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XG4gICAgdGhpcy5kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgdGhpcy5pc1Jvb3RlZCA9IGlzUm9vdGVkIHx8IGZhbHNlO1xuICAgIHRoaXMuY29weVZpc2liaWxpdHlJbmZvKHZpc2liaWxpdHlJbmZvKTtcbiAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XG59O1xuXG5EaXJlY3RpdmUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbkRpcmVjdGl2ZS5wcm90b3R5cGUudHlwZSA9IFwiRGlyZWN0aXZlXCI7XG5EaXJlY3RpdmUucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSwgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuICAgIGlmIChydWxlcykge1xuICAgICAgICB0aGlzLnJ1bGVzID0gdmlzaXRvci52aXNpdEFycmF5KHJ1bGVzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2aXNpdG9yLnZpc2l0KHZhbHVlKTtcbiAgICB9XG59O1xuRGlyZWN0aXZlLnByb3RvdHlwZS5pc1J1bGVzZXRMaWtlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMgfHwgIXRoaXMuaXNDaGFyc2V0KCk7XG59O1xuRGlyZWN0aXZlLnByb3RvdHlwZS5pc0NoYXJzZXQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJAY2hhcnNldFwiID09PSB0aGlzLm5hbWU7XG59O1xuRGlyZWN0aXZlLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSwgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuICAgIG91dHB1dC5hZGQodGhpcy5uYW1lLCB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy5pbmRleCk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIG91dHB1dC5hZGQoJyAnKTtcbiAgICAgICAgdmFsdWUuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgfVxuICAgIGlmIChydWxlcykge1xuICAgICAgICB0aGlzLm91dHB1dFJ1bGVzZXQoY29udGV4dCwgb3V0cHV0LCBydWxlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LmFkZCgnOycpO1xuICAgIH1cbn07XG5EaXJlY3RpdmUucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtZWRpYVBhdGhCYWNrdXAsIG1lZGlhQmxvY2tzQmFja3VwLCB2YWx1ZSA9IHRoaXMudmFsdWUsIHJ1bGVzID0gdGhpcy5ydWxlcztcblxuICAgIC8vbWVkaWEgc3RvcmVkIGluc2lkZSBvdGhlciBkaXJlY3RpdmUgc2hvdWxkIG5vdCBidWJibGUgb3ZlciBpdFxuICAgIC8vYmFja3B1cCBtZWRpYSBidWJibGluZyBpbmZvcm1hdGlvblxuICAgIG1lZGlhUGF0aEJhY2t1cCA9IGNvbnRleHQubWVkaWFQYXRoO1xuICAgIG1lZGlhQmxvY2tzQmFja3VwID0gY29udGV4dC5tZWRpYUJsb2NrcztcbiAgICAvL2RlbGV0ZWQgbWVkaWEgYnViYmxpbmcgaW5mb3JtYXRpb25cbiAgICBjb250ZXh0Lm1lZGlhUGF0aCA9IFtdO1xuICAgIGNvbnRleHQubWVkaWFCbG9ja3MgPSBbXTtcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLmV2YWwoY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChydWxlcykge1xuICAgICAgICAvLyBhc3N1bWluZyB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIHJ1bGUgYXQgdGhpcyBwb2ludCAtIHRoYXQgaXMgaG93IHBhcnNlciBjb25zdHJ1Y3RzIHRoZSBydWxlXG4gICAgICAgIHJ1bGVzID0gW3J1bGVzWzBdLmV2YWwoY29udGV4dCldO1xuICAgICAgICBydWxlc1swXS5yb290ID0gdHJ1ZTtcbiAgICB9XG4gICAgLy9yZXN0b3JlIG1lZGlhIGJ1YmJsaW5nIGluZm9ybWF0aW9uXG4gICAgY29udGV4dC5tZWRpYVBhdGggPSBtZWRpYVBhdGhCYWNrdXA7XG4gICAgY29udGV4dC5tZWRpYUJsb2NrcyA9IG1lZGlhQmxvY2tzQmFja3VwO1xuXG4gICAgcmV0dXJuIG5ldyBEaXJlY3RpdmUodGhpcy5uYW1lLCB2YWx1ZSwgcnVsZXMsXG4gICAgICAgIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvLCB0aGlzLmRlYnVnSW5mbywgdGhpcy5pc1Jvb3RlZCwgdGhpcy52aXNpYmlsaXR5SW5mbygpKTtcbn07XG5EaXJlY3RpdmUucHJvdG90eXBlLnZhcmlhYmxlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAodGhpcy5ydWxlcykge1xuICAgICAgICAvLyBhc3N1bWluZyB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIHJ1bGUgYXQgdGhpcyBwb2ludCAtIHRoYXQgaXMgaG93IHBhcnNlciBjb25zdHJ1Y3RzIHRoZSBydWxlXG4gICAgICAgIHJldHVybiBSdWxlc2V0LnByb3RvdHlwZS52YXJpYWJsZS5jYWxsKHRoaXMucnVsZXNbMF0sIG5hbWUpO1xuICAgIH1cbn07XG5EaXJlY3RpdmUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucnVsZXMpIHtcbiAgICAgICAgLy8gYXNzdW1pbmcgdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBydWxlIGF0IHRoaXMgcG9pbnQgLSB0aGF0IGlzIGhvdyBwYXJzZXIgY29uc3RydWN0cyB0aGUgcnVsZVxuICAgICAgICByZXR1cm4gUnVsZXNldC5wcm90b3R5cGUuZmluZC5hcHBseSh0aGlzLnJ1bGVzWzBdLCBhcmd1bWVudHMpO1xuICAgIH1cbn07XG5EaXJlY3RpdmUucHJvdG90eXBlLnJ1bGVzZXRzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnJ1bGVzKSB7XG4gICAgICAgIC8vIGFzc3VtaW5nIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgcnVsZSBhdCB0aGlzIHBvaW50IC0gdGhhdCBpcyBob3cgcGFyc2VyIGNvbnN0cnVjdHMgdGhlIHJ1bGVcbiAgICAgICAgcmV0dXJuIFJ1bGVzZXQucHJvdG90eXBlLnJ1bGVzZXRzLmFwcGx5KHRoaXMucnVsZXNbMF0pO1xuICAgIH1cbn07XG5EaXJlY3RpdmUucHJvdG90eXBlLm91dHB1dFJ1bGVzZXQgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0LCBydWxlcykge1xuICAgIHZhciBydWxlQ250ID0gcnVsZXMubGVuZ3RoLCBpO1xuICAgIGNvbnRleHQudGFiTGV2ZWwgPSAoY29udGV4dC50YWJMZXZlbCB8IDApICsgMTtcblxuICAgIC8vIENvbXByZXNzZWRcbiAgICBpZiAoY29udGV4dC5jb21wcmVzcykge1xuICAgICAgICBvdXRwdXQuYWRkKCd7Jyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBydWxlQ250OyBpKyspIHtcbiAgICAgICAgICAgIHJ1bGVzW2ldLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5hZGQoJ30nKTtcbiAgICAgICAgY29udGV4dC50YWJMZXZlbC0tO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTm9uLWNvbXByZXNzZWRcbiAgICB2YXIgdGFiU2V0U3RyID0gJ1xcbicgKyBBcnJheShjb250ZXh0LnRhYkxldmVsKS5qb2luKFwiICBcIiksIHRhYlJ1bGVTdHIgPSB0YWJTZXRTdHIgKyBcIiAgXCI7XG4gICAgaWYgKCFydWxlQ250KSB7XG4gICAgICAgIG91dHB1dC5hZGQoXCIge1wiICsgdGFiU2V0U3RyICsgJ30nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQuYWRkKFwiIHtcIiArIHRhYlJ1bGVTdHIpO1xuICAgICAgICBydWxlc1swXS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHJ1bGVDbnQ7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0LmFkZCh0YWJSdWxlU3RyKTtcbiAgICAgICAgICAgIHJ1bGVzW2ldLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5hZGQodGFiU2V0U3RyICsgJ30nKTtcbiAgICB9XG5cbiAgICBjb250ZXh0LnRhYkxldmVsLS07XG59O1xubW9kdWxlLmV4cG9ydHMgPSBEaXJlY3RpdmU7XG5cbn0se1wiLi9ub2RlXCI6NzAsXCIuL3J1bGVzZXRcIjo3NixcIi4vc2VsZWN0b3JcIjo3N31dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICBQYXJlbiA9IHJlcXVpcmUoXCIuL3BhcmVuXCIpLFxuICAgIENvbWJpbmF0b3IgPSByZXF1aXJlKFwiLi9jb21iaW5hdG9yXCIpO1xuXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uIChjb21iaW5hdG9yLCB2YWx1ZSwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgaW5mbykge1xuICAgIHRoaXMuY29tYmluYXRvciA9IGNvbWJpbmF0b3IgaW5zdGFuY2VvZiBDb21iaW5hdG9yID9cbiAgICAgICAgICAgICAgICAgICAgICBjb21iaW5hdG9yIDogbmV3IENvbWJpbmF0b3IoY29tYmluYXRvcik7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgIH1cbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5jdXJyZW50RmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XG4gICAgdGhpcy5jb3B5VmlzaWJpbGl0eUluZm8oaW5mbyk7XG59O1xuRWxlbWVudC5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuRWxlbWVudC5wcm90b3R5cGUudHlwZSA9IFwiRWxlbWVudFwiO1xuRWxlbWVudC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIHRoaXMuY29tYmluYXRvciA9IHZpc2l0b3IudmlzaXQodGhpcy5jb21iaW5hdG9yKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2aXNpdG9yLnZpc2l0KHZhbHVlKTtcbiAgICB9XG59O1xuRWxlbWVudC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50KHRoaXMuY29tYmluYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5ldmFsID8gdGhpcy52YWx1ZS5ldmFsKGNvbnRleHQpIDogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XG59O1xuRWxlbWVudC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50KHRoaXMuY29tYmluYXRvcixcbiAgICAgICAgdGhpcy52YWx1ZSxcbiAgICAgICAgdGhpcy5pbmRleCxcbiAgICAgICAgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XG59O1xuRWxlbWVudC5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIG91dHB1dC5hZGQodGhpcy50b0NTUyhjb250ZXh0KSwgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRoaXMuaW5kZXgpO1xufTtcbkVsZW1lbnQucHJvdG90eXBlLnRvQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCB7fTtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLCBmaXJzdFNlbGVjdG9yID0gY29udGV4dC5maXJzdFNlbGVjdG9yO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFBhcmVuKSB7XG4gICAgICAgIC8vIHNlbGVjdG9yIGluIHBhcmVucyBzaG91bGQgbm90IGJlIGFmZmVjdGVkIGJ5IG91dGVyIHNlbGVjdG9yXG4gICAgICAgIC8vIGZsYWdzIChicmVha3Mgb25seSBpbnRlcnBvbGF0ZWQgc2VsZWN0b3JzIC0gc2VlICMxOTczKVxuICAgICAgICBjb250ZXh0LmZpcnN0U2VsZWN0b3IgPSB0cnVlO1xuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLnRvQ1NTID8gdmFsdWUudG9DU1MoY29udGV4dCkgOiB2YWx1ZTtcbiAgICBjb250ZXh0LmZpcnN0U2VsZWN0b3IgPSBmaXJzdFNlbGVjdG9yO1xuICAgIGlmICh2YWx1ZSA9PT0gJycgJiYgdGhpcy5jb21iaW5hdG9yLnZhbHVlLmNoYXJBdCgwKSA9PT0gJyYnKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21iaW5hdG9yLnRvQ1NTKGNvbnRleHQpICsgdmFsdWU7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudDtcblxufSx7XCIuL2NvbWJpbmF0b3JcIjo1MSxcIi4vbm9kZVwiOjcwLFwiLi9wYXJlblwiOjcyfV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpLFxuICAgIFBhcmVuID0gcmVxdWlyZShcIi4vcGFyZW5cIiksXG4gICAgQ29tbWVudCA9IHJlcXVpcmUoXCIuL2NvbW1lbnRcIik7XG5cbnZhciBFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwcmVzc2lvbiByZXF1aXJlcyBhbiBhcnJheSBwYXJhbWV0ZXJcIik7XG4gICAgfVxufTtcbkV4cHJlc3Npb24ucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbkV4cHJlc3Npb24ucHJvdG90eXBlLnR5cGUgPSBcIkV4cHJlc3Npb25cIjtcbkV4cHJlc3Npb24ucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLnZhbHVlKTtcbn07XG5FeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWUsXG4gICAgICAgIGluUGFyZW50aGVzaXMgPSB0aGlzLnBhcmVucyAmJiAhdGhpcy5wYXJlbnNJbk9wLFxuICAgICAgICBkb3VibGVQYXJlbiA9IGZhbHNlO1xuICAgIGlmIChpblBhcmVudGhlc2lzKSB7XG4gICAgICAgIGNvbnRleHQuaW5QYXJlbnRoZXNpcygpO1xuICAgIH1cbiAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gbmV3IEV4cHJlc3Npb24odGhpcy52YWx1ZS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmV2YWwoY29udGV4dCk7XG4gICAgICAgIH0pKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlWzBdLnBhcmVucyAmJiAhdGhpcy52YWx1ZVswXS5wYXJlbnNJbk9wKSB7XG4gICAgICAgICAgICBkb3VibGVQYXJlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuVmFsdWUgPSB0aGlzLnZhbHVlWzBdLmV2YWwoY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSB0aGlzO1xuICAgIH1cbiAgICBpZiAoaW5QYXJlbnRoZXNpcykge1xuICAgICAgICBjb250ZXh0Lm91dE9mUGFyZW50aGVzaXMoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW5zICYmIHRoaXMucGFyZW5zSW5PcCAmJiAhKGNvbnRleHQuaXNNYXRoT24oKSkgJiYgIWRvdWJsZVBhcmVuKSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gbmV3IFBhcmVuKHJldHVyblZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcbkV4cHJlc3Npb24ucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy52YWx1ZVtpXS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICAgICAgaWYgKGkgKyAxIDwgdGhpcy52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dHB1dC5hZGQoXCIgXCIpO1xuICAgICAgICB9XG4gICAgfVxufTtcbkV4cHJlc3Npb24ucHJvdG90eXBlLnRocm93QXdheUNvbW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiAhKHYgaW5zdGFuY2VvZiBDb21tZW50KTtcbiAgICB9KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJlc3Npb247XG5cbn0se1wiLi9jb21tZW50XCI6NTIsXCIuL25vZGVcIjo3MCxcIi4vcGFyZW5cIjo3Mn1dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICBTZWxlY3RvciA9IHJlcXVpcmUoXCIuL3NlbGVjdG9yXCIpO1xuXG52YXIgRXh0ZW5kID0gZnVuY3Rpb24gRXh0ZW5kKHNlbGVjdG9yLCBvcHRpb24sIGluZGV4LCBjdXJyZW50RmlsZUluZm8sIHZpc2liaWxpdHlJbmZvKSB7XG4gICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgIHRoaXMub3B0aW9uID0gb3B0aW9uO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLm9iamVjdF9pZCA9IEV4dGVuZC5uZXh0X2lkKys7XG4gICAgdGhpcy5wYXJlbnRfaWRzID0gW3RoaXMub2JqZWN0X2lkXTtcbiAgICB0aGlzLmN1cnJlbnRGaWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbyB8fCB7fTtcbiAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XG4gICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xuXG4gICAgc3dpdGNoKG9wdGlvbikge1xuICAgICAgICBjYXNlIFwiYWxsXCI6XG4gICAgICAgICAgICB0aGlzLmFsbG93QmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dBZnRlciA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuYWxsb3dCZWZvcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dBZnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcbkV4dGVuZC5uZXh0X2lkID0gMDtcblxuRXh0ZW5kLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5FeHRlbmQucHJvdG90eXBlLnR5cGUgPSBcIkV4dGVuZFwiO1xuRXh0ZW5kLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgIHRoaXMuc2VsZWN0b3IgPSB2aXNpdG9yLnZpc2l0KHRoaXMuc2VsZWN0b3IpO1xufTtcbkV4dGVuZC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBFeHRlbmQodGhpcy5zZWxlY3Rvci5ldmFsKGNvbnRleHQpLCB0aGlzLm9wdGlvbiwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XG59O1xuRXh0ZW5kLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBFeHRlbmQodGhpcy5zZWxlY3RvciwgdGhpcy5vcHRpb24sIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xufTtcbi8vaXQgY29uY2F0ZW5hdGVzIChqb2lucykgYWxsIHNlbGVjdG9ycyBpbiBzZWxlY3RvciBhcnJheVxuRXh0ZW5kLnByb3RvdHlwZS5maW5kU2VsZlNlbGVjdG9ycyA9IGZ1bmN0aW9uIChzZWxlY3RvcnMpIHtcbiAgICB2YXIgc2VsZkVsZW1lbnRzID0gW10sXG4gICAgICAgIGksXG4gICAgICAgIHNlbGVjdG9yRWxlbWVudHM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGVjdG9yRWxlbWVudHMgPSBzZWxlY3RvcnNbaV0uZWxlbWVudHM7XG4gICAgICAgIC8vIGR1cGxpY2F0ZSB0aGUgbG9naWMgaW4gZ2VuQ1NTIGZ1bmN0aW9uIGluc2lkZSB0aGUgc2VsZWN0b3Igbm9kZS5cbiAgICAgICAgLy8gZnV0dXJlIFRPRE8gLSBtb3ZlIGJvdGggbG9naWNzIGludG8gdGhlIHNlbGVjdG9yIGpvaW5lciB2aXNpdG9yXG4gICAgICAgIGlmIChpID4gMCAmJiBzZWxlY3RvckVsZW1lbnRzLmxlbmd0aCAmJiBzZWxlY3RvckVsZW1lbnRzWzBdLmNvbWJpbmF0b3IudmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHNlbGVjdG9yRWxlbWVudHNbMF0uY29tYmluYXRvci52YWx1ZSA9ICcgJztcbiAgICAgICAgfVxuICAgICAgICBzZWxmRWxlbWVudHMgPSBzZWxmRWxlbWVudHMuY29uY2F0KHNlbGVjdG9yc1tpXS5lbGVtZW50cyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZWxmU2VsZWN0b3JzID0gW25ldyBTZWxlY3RvcihzZWxmRWxlbWVudHMpXTtcbiAgICB0aGlzLnNlbGZTZWxlY3RvcnNbMF0uY29weVZpc2liaWxpdHlJbmZvKHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBFeHRlbmQ7XG5cbn0se1wiLi9ub2RlXCI6NzAsXCIuL3NlbGVjdG9yXCI6Nzd9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIiksXG4gICAgTWVkaWEgPSByZXF1aXJlKFwiLi9tZWRpYVwiKSxcbiAgICBVUkwgPSByZXF1aXJlKFwiLi91cmxcIiksXG4gICAgUXVvdGVkID0gcmVxdWlyZShcIi4vcXVvdGVkXCIpLFxuICAgIFJ1bGVzZXQgPSByZXF1aXJlKFwiLi9ydWxlc2V0XCIpLFxuICAgIEFub255bW91cyA9IHJlcXVpcmUoXCIuL2Fub255bW91c1wiKTtcblxuLy9cbi8vIENTUyBAaW1wb3J0IG5vZGVcbi8vXG4vLyBUaGUgZ2VuZXJhbCBzdHJhdGVneSBoZXJlIGlzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byB3YWl0XG4vLyBmb3IgdGhlIHBhcnNpbmcgdG8gYmUgY29tcGxldGVkLCBiZWZvcmUgd2Ugc3RhcnQgaW1wb3J0aW5nXG4vLyB0aGUgZmlsZS4gVGhhdCdzIGJlY2F1c2UgaW4gdGhlIGNvbnRleHQgb2YgYSBicm93c2VyLFxuLy8gbW9zdCBvZiB0aGUgdGltZSB3aWxsIGJlIHNwZW50IHdhaXRpbmcgZm9yIHRoZSBzZXJ2ZXIgdG8gcmVzcG9uZC5cbi8vXG4vLyBPbiBjcmVhdGlvbiwgd2UgcHVzaCB0aGUgaW1wb3J0IHBhdGggdG8gb3VyIGltcG9ydCBxdWV1ZSwgdGhvdWdoXG4vLyBgaW1wb3J0LHB1c2hgLCB3ZSBhbHNvIHBhc3MgaXQgYSBjYWxsYmFjaywgd2hpY2ggaXQnbGwgY2FsbCBvbmNlXG4vLyB0aGUgZmlsZSBoYXMgYmVlbiBmZXRjaGVkLCBhbmQgcGFyc2VkLlxuLy9cbnZhciBJbXBvcnQgPSBmdW5jdGlvbiAocGF0aCwgZmVhdHVyZXMsIG9wdGlvbnMsIGluZGV4LCBjdXJyZW50RmlsZUluZm8sIHZpc2liaWxpdHlJbmZvKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XG4gICAgdGhpcy5jdXJyZW50RmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XG4gICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5sZXNzICE9PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLmlubGluZSkge1xuICAgICAgICB0aGlzLmNzcyA9ICF0aGlzLm9wdGlvbnMubGVzcyB8fCB0aGlzLm9wdGlvbnMuaW5saW5lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXRoVmFsdWUgPSB0aGlzLmdldFBhdGgoKTtcbiAgICAgICAgaWYgKHBhdGhWYWx1ZSAmJiAvWyNcXC5cXCZcXD9cXC9dY3NzKFtcXD87XS4qKT8kLy50ZXN0KHBhdGhWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY3NzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XG59O1xuXG4vL1xuLy8gVGhlIGFjdHVhbCBpbXBvcnQgbm9kZSBkb2Vzbid0IHJldHVybiBhbnl0aGluZywgd2hlbiBjb252ZXJ0ZWQgdG8gQ1NTLlxuLy8gVGhlIHJlYXNvbiBpcyB0aGF0IGl0J3MgdXNlZCBhdCB0aGUgZXZhbHVhdGlvbiBzdGFnZSwgc28gdGhhdCB0aGUgcnVsZXNcbi8vIGl0IGltcG9ydHMgY2FuIGJlIHRyZWF0ZWQgbGlrZSBhbnkgb3RoZXIgcnVsZXMuXG4vL1xuLy8gSW4gYGV2YWxgLCB3ZSBtYWtlIHN1cmUgYWxsIEltcG9ydCBub2RlcyBnZXQgZXZhbHVhdGVkLCByZWN1cnNpdmVseSwgc29cbi8vIHdlIGVuZCB1cCB3aXRoIGEgZmxhdCBzdHJ1Y3R1cmUsIHdoaWNoIGNhbiBlYXNpbHkgYmUgaW1wb3J0ZWQgaW4gdGhlIHBhcmVudFxuLy8gcnVsZXNldC5cbi8vXG5JbXBvcnQucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbkltcG9ydC5wcm90b3R5cGUudHlwZSA9IFwiSW1wb3J0XCI7XG5JbXBvcnQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgaWYgKHRoaXMuZmVhdHVyZXMpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IHZpc2l0b3IudmlzaXQodGhpcy5mZWF0dXJlcyk7XG4gICAgfVxuICAgIHRoaXMucGF0aCA9IHZpc2l0b3IudmlzaXQodGhpcy5wYXRoKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5wbHVnaW4gJiYgIXRoaXMub3B0aW9ucy5pbmxpbmUgJiYgdGhpcy5yb290KSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHZpc2l0b3IudmlzaXQodGhpcy5yb290KTtcbiAgICB9XG59O1xuSW1wb3J0LnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgaWYgKHRoaXMuY3NzICYmIHRoaXMucGF0aC5jdXJyZW50RmlsZUluZm8ucmVmZXJlbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0cHV0LmFkZChcIkBpbXBvcnQgXCIsIHRoaXMuY3VycmVudEZpbGVJbmZvLCB0aGlzLmluZGV4KTtcbiAgICAgICAgdGhpcy5wYXRoLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlcykge1xuICAgICAgICAgICAgb3V0cHV0LmFkZChcIiBcIik7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5hZGQoJzsnKTtcbiAgICB9XG59O1xuSW1wb3J0LnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5wYXRoIGluc3RhbmNlb2YgVVJMKSA/XG4gICAgICAgIHRoaXMucGF0aC52YWx1ZS52YWx1ZSA6IHRoaXMucGF0aC52YWx1ZTtcbn07XG5JbXBvcnQucHJvdG90eXBlLmlzVmFyaWFibGVJbXBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgcGF0aCA9IHBhdGgudmFsdWU7XG4gICAgfVxuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgUXVvdGVkKSB7XG4gICAgICAgIHJldHVybiBwYXRoLmNvbnRhaW5zVmFyaWFibGVzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuSW1wb3J0LnByb3RvdHlwZS5ldmFsRm9ySW1wb3J0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcblxuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSW1wb3J0KHBhdGguZXZhbChjb250ZXh0KSwgdGhpcy5mZWF0dXJlcywgdGhpcy5vcHRpb25zLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy52aXNpYmlsaXR5SW5mbygpKTtcbn07XG5JbXBvcnQucHJvdG90eXBlLmV2YWxQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aC5ldmFsKGNvbnRleHQpO1xuICAgIHZhciByb290cGF0aCA9IHRoaXMuY3VycmVudEZpbGVJbmZvICYmIHRoaXMuY3VycmVudEZpbGVJbmZvLnJvb3RwYXRoO1xuXG4gICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgaWYgKHJvb3RwYXRoKSB7XG4gICAgICAgICAgICB2YXIgcGF0aFZhbHVlID0gcGF0aC52YWx1ZTtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgYmFzZSBwYXRoIGlmIHRoZSBpbXBvcnQgaXMgcmVsYXRpdmVcbiAgICAgICAgICAgIGlmIChwYXRoVmFsdWUgJiYgY29udGV4dC5pc1BhdGhSZWxhdGl2ZShwYXRoVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcGF0aC52YWx1ZSA9IHJvb3RwYXRoICsgcGF0aFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhdGgudmFsdWUgPSBjb250ZXh0Lm5vcm1hbGl6ZVBhdGgocGF0aC52YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG59O1xuSW1wb3J0LnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kb0V2YWwoY29udGV4dCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZWZlcmVuY2UgfHwgdGhpcy5ibG9ja3NWaXNpYmlsaXR5KCkpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggfHwgcmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRWaXNpYmlsaXR5QmxvY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmFkZFZpc2liaWxpdHlCbG9jaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuSW1wb3J0LnByb3RvdHlwZS5kb0V2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBydWxlc2V0LCByZWdpc3RyeSxcbiAgICAgICAgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzICYmIHRoaXMuZmVhdHVyZXMuZXZhbChjb250ZXh0KTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGx1Z2luKSB7XG4gICAgICAgIHJlZ2lzdHJ5ID0gY29udGV4dC5mcmFtZXNbMF0gJiYgY29udGV4dC5mcmFtZXNbMF0uZnVuY3Rpb25SZWdpc3RyeTtcbiAgICAgICAgaWYgKCByZWdpc3RyeSAmJiB0aGlzLnJvb3QgJiYgdGhpcy5yb290LmZ1bmN0aW9ucyApIHtcbiAgICAgICAgICAgIHJlZ2lzdHJ5LmFkZE11bHRpcGxlKCB0aGlzLnJvb3QuZnVuY3Rpb25zICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNraXApIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNraXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5za2lwID0gdGhpcy5za2lwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2tpcCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuaW5saW5lKSB7XG4gICAgICAgIHZhciBjb250ZW50cyA9IG5ldyBBbm9ueW1vdXModGhpcy5yb290LCAwLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuaW1wb3J0ZWRGaWxlbmFtZSxcbiAgICAgICAgICAgICAgcmVmZXJlbmNlOiB0aGlzLnBhdGguY3VycmVudEZpbGVJbmZvICYmIHRoaXMucGF0aC5jdXJyZW50RmlsZUluZm8ucmVmZXJlbmNlXG4gICAgICAgICAgfSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXMgPyBuZXcgTWVkaWEoW2NvbnRlbnRzXSwgdGhpcy5mZWF0dXJlcy52YWx1ZSkgOiBbY29udGVudHNdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jc3MpIHtcbiAgICAgICAgdmFyIG5ld0ltcG9ydCA9IG5ldyBJbXBvcnQodGhpcy5ldmFsUGF0aChjb250ZXh0KSwgZmVhdHVyZXMsIHRoaXMub3B0aW9ucywgdGhpcy5pbmRleCk7XG4gICAgICAgIGlmICghbmV3SW1wb3J0LmNzcyAmJiB0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdJbXBvcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcnVsZXNldCA9IG5ldyBSdWxlc2V0KG51bGwsIHRoaXMucm9vdC5ydWxlcy5zbGljZSgwKSk7XG4gICAgICAgIHJ1bGVzZXQuZXZhbEltcG9ydHMoY29udGV4dCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXMgPyBuZXcgTWVkaWEocnVsZXNldC5ydWxlcywgdGhpcy5mZWF0dXJlcy52YWx1ZSkgOiBydWxlc2V0LnJ1bGVzO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IEltcG9ydDtcblxufSx7XCIuL2Fub255bW91c1wiOjQ2LFwiLi9tZWRpYVwiOjY2LFwiLi9ub2RlXCI6NzAsXCIuL3F1b3RlZFwiOjczLFwiLi9ydWxlc2V0XCI6NzYsXCIuL3VybFwiOjgwfV0sNjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHRyZWUgPSB7fTtcblxudHJlZS5Ob2RlID0gcmVxdWlyZSgnLi9ub2RlJyk7XG50cmVlLkFscGhhID0gcmVxdWlyZSgnLi9hbHBoYScpO1xudHJlZS5Db2xvciA9IHJlcXVpcmUoJy4vY29sb3InKTtcbnRyZWUuRGlyZWN0aXZlID0gcmVxdWlyZSgnLi9kaXJlY3RpdmUnKTtcbnRyZWUuRGV0YWNoZWRSdWxlc2V0ID0gcmVxdWlyZSgnLi9kZXRhY2hlZC1ydWxlc2V0Jyk7XG50cmVlLk9wZXJhdGlvbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9uJyk7XG50cmVlLkRpbWVuc2lvbiA9IHJlcXVpcmUoJy4vZGltZW5zaW9uJyk7XG50cmVlLlVuaXQgPSByZXF1aXJlKCcuL3VuaXQnKTtcbnRyZWUuS2V5d29yZCA9IHJlcXVpcmUoJy4va2V5d29yZCcpO1xudHJlZS5WYXJpYWJsZSA9IHJlcXVpcmUoJy4vdmFyaWFibGUnKTtcbnRyZWUuUnVsZXNldCA9IHJlcXVpcmUoJy4vcnVsZXNldCcpO1xudHJlZS5FbGVtZW50ID0gcmVxdWlyZSgnLi9lbGVtZW50Jyk7XG50cmVlLkF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vYXR0cmlidXRlJyk7XG50cmVlLkNvbWJpbmF0b3IgPSByZXF1aXJlKCcuL2NvbWJpbmF0b3InKTtcbnRyZWUuU2VsZWN0b3IgPSByZXF1aXJlKCcuL3NlbGVjdG9yJyk7XG50cmVlLlF1b3RlZCA9IHJlcXVpcmUoJy4vcXVvdGVkJyk7XG50cmVlLkV4cHJlc3Npb24gPSByZXF1aXJlKCcuL2V4cHJlc3Npb24nKTtcbnRyZWUuUnVsZSA9IHJlcXVpcmUoJy4vcnVsZScpO1xudHJlZS5DYWxsID0gcmVxdWlyZSgnLi9jYWxsJyk7XG50cmVlLlVSTCA9IHJlcXVpcmUoJy4vdXJsJyk7XG50cmVlLkltcG9ydCA9IHJlcXVpcmUoJy4vaW1wb3J0Jyk7XG50cmVlLm1peGluID0ge1xuICAgIENhbGw6IHJlcXVpcmUoJy4vbWl4aW4tY2FsbCcpLFxuICAgIERlZmluaXRpb246IHJlcXVpcmUoJy4vbWl4aW4tZGVmaW5pdGlvbicpXG59O1xudHJlZS5Db21tZW50ID0gcmVxdWlyZSgnLi9jb21tZW50Jyk7XG50cmVlLkFub255bW91cyA9IHJlcXVpcmUoJy4vYW5vbnltb3VzJyk7XG50cmVlLlZhbHVlID0gcmVxdWlyZSgnLi92YWx1ZScpO1xudHJlZS5KYXZhU2NyaXB0ID0gcmVxdWlyZSgnLi9qYXZhc2NyaXB0Jyk7XG50cmVlLkFzc2lnbm1lbnQgPSByZXF1aXJlKCcuL2Fzc2lnbm1lbnQnKTtcbnRyZWUuQ29uZGl0aW9uID0gcmVxdWlyZSgnLi9jb25kaXRpb24nKTtcbnRyZWUuUGFyZW4gPSByZXF1aXJlKCcuL3BhcmVuJyk7XG50cmVlLk1lZGlhID0gcmVxdWlyZSgnLi9tZWRpYScpO1xudHJlZS5Vbmljb2RlRGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vdW5pY29kZS1kZXNjcmlwdG9yJyk7XG50cmVlLk5lZ2F0aXZlID0gcmVxdWlyZSgnLi9uZWdhdGl2ZScpO1xudHJlZS5FeHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xudHJlZS5SdWxlc2V0Q2FsbCA9IHJlcXVpcmUoJy4vcnVsZXNldC1jYWxsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdHJlZTtcblxufSx7XCIuL2FscGhhXCI6NDUsXCIuL2Fub255bW91c1wiOjQ2LFwiLi9hc3NpZ25tZW50XCI6NDcsXCIuL2F0dHJpYnV0ZVwiOjQ4LFwiLi9jYWxsXCI6NDksXCIuL2NvbG9yXCI6NTAsXCIuL2NvbWJpbmF0b3JcIjo1MSxcIi4vY29tbWVudFwiOjUyLFwiLi9jb25kaXRpb25cIjo1MyxcIi4vZGV0YWNoZWQtcnVsZXNldFwiOjU1LFwiLi9kaW1lbnNpb25cIjo1NixcIi4vZGlyZWN0aXZlXCI6NTcsXCIuL2VsZW1lbnRcIjo1OCxcIi4vZXhwcmVzc2lvblwiOjU5LFwiLi9leHRlbmRcIjo2MCxcIi4vaW1wb3J0XCI6NjEsXCIuL2phdmFzY3JpcHRcIjo2MyxcIi4va2V5d29yZFwiOjY1LFwiLi9tZWRpYVwiOjY2LFwiLi9taXhpbi1jYWxsXCI6NjcsXCIuL21peGluLWRlZmluaXRpb25cIjo2OCxcIi4vbmVnYXRpdmVcIjo2OSxcIi4vbm9kZVwiOjcwLFwiLi9vcGVyYXRpb25cIjo3MSxcIi4vcGFyZW5cIjo3MixcIi4vcXVvdGVkXCI6NzMsXCIuL3J1bGVcIjo3NCxcIi4vcnVsZXNldFwiOjc2LFwiLi9ydWxlc2V0LWNhbGxcIjo3NSxcIi4vc2VsZWN0b3JcIjo3NyxcIi4vdW5pY29kZS1kZXNjcmlwdG9yXCI6NzgsXCIuL3VuaXRcIjo3OSxcIi4vdXJsXCI6ODAsXCIuL3ZhbHVlXCI6ODEsXCIuL3ZhcmlhYmxlXCI6ODJ9XSw2MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgSnNFdmFsTm9kZSA9IHJlcXVpcmUoXCIuL2pzLWV2YWwtbm9kZVwiKSxcbiAgICBEaW1lbnNpb24gPSByZXF1aXJlKFwiLi9kaW1lbnNpb25cIiksXG4gICAgUXVvdGVkID0gcmVxdWlyZShcIi4vcXVvdGVkXCIpLFxuICAgIEFub255bW91cyA9IHJlcXVpcmUoXCIuL2Fub255bW91c1wiKTtcblxudmFyIEphdmFTY3JpcHQgPSBmdW5jdGlvbiAoc3RyaW5nLCBlc2NhcGVkLCBpbmRleCwgY3VycmVudEZpbGVJbmZvKSB7XG4gICAgdGhpcy5lc2NhcGVkID0gZXNjYXBlZDtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBzdHJpbmc7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY3VycmVudEZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xufTtcbkphdmFTY3JpcHQucHJvdG90eXBlID0gbmV3IEpzRXZhbE5vZGUoKTtcbkphdmFTY3JpcHQucHJvdG90eXBlLnR5cGUgPSBcIkphdmFTY3JpcHRcIjtcbkphdmFTY3JpcHQucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZXZhbHVhdGVKYXZhU2NyaXB0KHRoaXMuZXhwcmVzc2lvbiwgY29udGV4dCk7XG5cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24ocmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVvdGVkKCdcIicgKyByZXN1bHQgKyAnXCInLCByZXN1bHQsIHRoaXMuZXNjYXBlZCwgdGhpcy5pbmRleCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXMocmVzdWx0LmpvaW4oJywgJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzKHJlc3VsdCk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKYXZhU2NyaXB0O1xuXG59LHtcIi4vYW5vbnltb3VzXCI6NDYsXCIuL2RpbWVuc2lvblwiOjU2LFwiLi9qcy1ldmFsLW5vZGVcIjo2NCxcIi4vcXVvdGVkXCI6NzN9XSw2NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIiksXG4gICAgVmFyaWFibGUgPSByZXF1aXJlKFwiLi92YXJpYWJsZVwiKTtcblxudmFyIEpzRXZhbE5vZGUgPSBmdW5jdGlvbigpIHtcbn07XG5Kc0V2YWxOb2RlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5cbkpzRXZhbE5vZGUucHJvdG90eXBlLmV2YWx1YXRlSmF2YVNjcmlwdCA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICAgIGV2YWxDb250ZXh0ID0ge307XG5cbiAgICBpZiAoY29udGV4dC5qYXZhc2NyaXB0RW5hYmxlZCAhPT0gdW5kZWZpbmVkICYmICFjb250ZXh0LmphdmFzY3JpcHRFbmFibGVkKSB7XG4gICAgICAgIHRocm93IHsgbWVzc2FnZTogXCJZb3UgYXJlIHVzaW5nIEphdmFTY3JpcHQsIHdoaWNoIGhhcyBiZWVuIGRpc2FibGVkLlwiLFxuICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuY3VycmVudEZpbGVJbmZvLmZpbGVuYW1lLFxuICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXggfTtcbiAgICB9XG5cbiAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5yZXBsYWNlKC9AXFx7KFtcXHctXSspXFx9L2csIGZ1bmN0aW9uIChfLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGF0LmpzaWZ5KG5ldyBWYXJpYWJsZSgnQCcgKyBuYW1lLCB0aGF0LmluZGV4LCB0aGF0LmN1cnJlbnRGaWxlSW5mbykuZXZhbChjb250ZXh0KSk7XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgICBleHByZXNzaW9uID0gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gKCcgKyBleHByZXNzaW9uICsgJyknKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IHsgbWVzc2FnZTogXCJKYXZhU2NyaXB0IGV2YWx1YXRpb24gZXJyb3I6IFwiICsgZS5tZXNzYWdlICsgXCIgZnJvbSBgXCIgKyBleHByZXNzaW9uICsgXCJgXCIgLFxuICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuY3VycmVudEZpbGVJbmZvLmZpbGVuYW1lLFxuICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXggfTtcbiAgICB9XG5cbiAgICB2YXIgdmFyaWFibGVzID0gY29udGV4dC5mcmFtZXNbMF0udmFyaWFibGVzKCk7XG4gICAgZm9yICh2YXIgayBpbiB2YXJpYWJsZXMpIHtcbiAgICAgICAgaWYgKHZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgLypqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSAqL1xuICAgICAgICAgICAgZXZhbENvbnRleHRbay5zbGljZSgxKV0gPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhcmlhYmxlc1trXS52YWx1ZSxcbiAgICAgICAgICAgICAgICB0b0pTOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmV2YWwoY29udGV4dCkudG9DU1MoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gZXhwcmVzc2lvbi5jYWxsKGV2YWxDb250ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IHsgbWVzc2FnZTogXCJKYXZhU2NyaXB0IGV2YWx1YXRpb24gZXJyb3I6ICdcIiArIGUubmFtZSArICc6ICcgKyBlLm1lc3NhZ2UucmVwbGFjZSgvW1wiXS9nLCBcIidcIikgKyBcIidcIiAsXG4gICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5jdXJyZW50RmlsZUluZm8uZmlsZW5hbWUsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbkpzRXZhbE5vZGUucHJvdG90eXBlLmpzaWZ5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iai52YWx1ZSkgJiYgKG9iai52YWx1ZS5sZW5ndGggPiAxKSkge1xuICAgICAgICByZXR1cm4gJ1snICsgb2JqLnZhbHVlLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdi50b0NTUygpOyB9KS5qb2luKCcsICcpICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvYmoudG9DU1MoKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzRXZhbE5vZGU7XG5cbn0se1wiLi9ub2RlXCI6NzAsXCIuL3ZhcmlhYmxlXCI6ODJ9XSw2NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIik7XG5cbnZhciBLZXl3b3JkID0gZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMudmFsdWUgPSB2YWx1ZTsgfTtcbktleXdvcmQucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbktleXdvcmQucHJvdG90eXBlLnR5cGUgPSBcIktleXdvcmRcIjtcbktleXdvcmQucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gJyUnKSB7IHRocm93IHsgdHlwZTogXCJTeW50YXhcIiwgbWVzc2FnZTogXCJJbnZhbGlkICUgd2l0aG91dCBudW1iZXJcIiB9OyB9XG4gICAgb3V0cHV0LmFkZCh0aGlzLnZhbHVlKTtcbn07XG5cbktleXdvcmQuVHJ1ZSA9IG5ldyBLZXl3b3JkKCd0cnVlJyk7XG5LZXl3b3JkLkZhbHNlID0gbmV3IEtleXdvcmQoJ2ZhbHNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5d29yZDtcblxufSx7XCIuL25vZGVcIjo3MH1dLDY2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBSdWxlc2V0ID0gcmVxdWlyZShcIi4vcnVsZXNldFwiKSxcbiAgICBWYWx1ZSA9IHJlcXVpcmUoXCIuL3ZhbHVlXCIpLFxuICAgIFNlbGVjdG9yID0gcmVxdWlyZShcIi4vc2VsZWN0b3JcIiksXG4gICAgQW5vbnltb3VzID0gcmVxdWlyZShcIi4vYW5vbnltb3VzXCIpLFxuICAgIEV4cHJlc3Npb24gPSByZXF1aXJlKFwiLi9leHByZXNzaW9uXCIpLFxuICAgIERpcmVjdGl2ZSA9IHJlcXVpcmUoXCIuL2RpcmVjdGl2ZVwiKTtcblxudmFyIE1lZGlhID0gZnVuY3Rpb24gKHZhbHVlLCBmZWF0dXJlcywgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgdmlzaWJpbGl0eUluZm8pIHtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5jdXJyZW50RmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XG5cbiAgICB2YXIgc2VsZWN0b3JzID0gKG5ldyBTZWxlY3RvcihbXSwgbnVsbCwgbnVsbCwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pKS5jcmVhdGVFbXB0eVNlbGVjdG9ycygpO1xuXG4gICAgdGhpcy5mZWF0dXJlcyA9IG5ldyBWYWx1ZShmZWF0dXJlcyk7XG4gICAgdGhpcy5ydWxlcyA9IFtuZXcgUnVsZXNldChzZWxlY3RvcnMsIHZhbHVlKV07XG4gICAgdGhpcy5ydWxlc1swXS5hbGxvd0ltcG9ydHMgPSB0cnVlO1xuICAgIHRoaXMuY29weVZpc2liaWxpdHlJbmZvKHZpc2liaWxpdHlJbmZvKTtcbiAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XG59O1xuTWVkaWEucHJvdG90eXBlID0gbmV3IERpcmVjdGl2ZSgpO1xuTWVkaWEucHJvdG90eXBlLnR5cGUgPSBcIk1lZGlhXCI7XG5NZWRpYS5wcm90b3R5cGUuaXNSdWxlc2V0TGlrZSA9IHRydWU7XG5NZWRpYS5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICBpZiAodGhpcy5mZWF0dXJlcykge1xuICAgICAgICB0aGlzLmZlYXR1cmVzID0gdmlzaXRvci52aXNpdCh0aGlzLmZlYXR1cmVzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucnVsZXMpIHtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLnJ1bGVzKTtcbiAgICB9XG59O1xuTWVkaWEucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICBvdXRwdXQuYWRkKCdAbWVkaWEgJywgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuZmVhdHVyZXMuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgdGhpcy5vdXRwdXRSdWxlc2V0KGNvbnRleHQsIG91dHB1dCwgdGhpcy5ydWxlcyk7XG59O1xuTWVkaWEucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmICghY29udGV4dC5tZWRpYUJsb2Nrcykge1xuICAgICAgICBjb250ZXh0Lm1lZGlhQmxvY2tzID0gW107XG4gICAgICAgIGNvbnRleHQubWVkaWFQYXRoID0gW107XG4gICAgfVxuXG4gICAgdmFyIG1lZGlhID0gbmV3IE1lZGlhKG51bGwsIFtdLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy52aXNpYmlsaXR5SW5mbygpKTtcbiAgICBpZiAodGhpcy5kZWJ1Z0luZm8pIHtcbiAgICAgICAgdGhpcy5ydWxlc1swXS5kZWJ1Z0luZm8gPSB0aGlzLmRlYnVnSW5mbztcbiAgICAgICAgbWVkaWEuZGVidWdJbmZvID0gdGhpcy5kZWJ1Z0luZm87XG4gICAgfVxuICAgIHZhciBzdHJpY3RNYXRoQnlwYXNzID0gZmFsc2U7XG4gICAgaWYgKCFjb250ZXh0LnN0cmljdE1hdGgpIHtcbiAgICAgICAgc3RyaWN0TWF0aEJ5cGFzcyA9IHRydWU7XG4gICAgICAgIGNvbnRleHQuc3RyaWN0TWF0aCA9IHRydWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIG1lZGlhLmZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcy5ldmFsKGNvbnRleHQpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHN0cmljdE1hdGhCeXBhc3MpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3RyaWN0TWF0aCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dC5tZWRpYVBhdGgucHVzaChtZWRpYSk7XG4gICAgY29udGV4dC5tZWRpYUJsb2Nrcy5wdXNoKG1lZGlhKTtcblxuICAgIHRoaXMucnVsZXNbMF0uZnVuY3Rpb25SZWdpc3RyeSA9IGNvbnRleHQuZnJhbWVzWzBdLmZ1bmN0aW9uUmVnaXN0cnkuaW5oZXJpdCgpO1xuICAgIGNvbnRleHQuZnJhbWVzLnVuc2hpZnQodGhpcy5ydWxlc1swXSk7XG4gICAgbWVkaWEucnVsZXMgPSBbdGhpcy5ydWxlc1swXS5ldmFsKGNvbnRleHQpXTtcbiAgICBjb250ZXh0LmZyYW1lcy5zaGlmdCgpO1xuXG4gICAgY29udGV4dC5tZWRpYVBhdGgucG9wKCk7XG5cbiAgICByZXR1cm4gY29udGV4dC5tZWRpYVBhdGgubGVuZ3RoID09PSAwID8gbWVkaWEuZXZhbFRvcChjb250ZXh0KSA6XG4gICAgICAgICAgICAgICAgbWVkaWEuZXZhbE5lc3RlZChjb250ZXh0KTtcbn07XG5NZWRpYS5wcm90b3R5cGUuZXZhbFRvcCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXM7XG5cbiAgICAvLyBSZW5kZXIgYWxsIGRlcGVuZGVudCBNZWRpYSBibG9ja3MuXG4gICAgaWYgKGNvbnRleHQubWVkaWFCbG9ja3MubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgc2VsZWN0b3JzID0gKG5ldyBTZWxlY3RvcihbXSwgbnVsbCwgbnVsbCwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pKS5jcmVhdGVFbXB0eVNlbGVjdG9ycygpO1xuICAgICAgICByZXN1bHQgPSBuZXcgUnVsZXNldChzZWxlY3RvcnMsIGNvbnRleHQubWVkaWFCbG9ja3MpO1xuICAgICAgICByZXN1bHQubXVsdGlNZWRpYSA9IHRydWU7XG4gICAgICAgIHJlc3VsdC5jb3B5VmlzaWJpbGl0eUluZm8odGhpcy52aXNpYmlsaXR5SW5mbygpKTtcbiAgICB9XG5cbiAgICBkZWxldGUgY29udGV4dC5tZWRpYUJsb2NrcztcbiAgICBkZWxldGUgY29udGV4dC5tZWRpYVBhdGg7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk1lZGlhLnByb3RvdHlwZS5ldmFsTmVzdGVkID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgaSwgdmFsdWUsXG4gICAgICAgIHBhdGggPSBjb250ZXh0Lm1lZGlhUGF0aC5jb25jYXQoW3RoaXNdKTtcblxuICAgIC8vIEV4dHJhY3QgdGhlIG1lZGlhLXF1ZXJ5IGNvbmRpdGlvbnMgc2VwYXJhdGVkIHdpdGggYCxgIChPUikuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBwYXRoW2ldLmZlYXR1cmVzIGluc3RhbmNlb2YgVmFsdWUgP1xuICAgICAgICAgICAgICAgICAgICBwYXRoW2ldLmZlYXR1cmVzLnZhbHVlIDogcGF0aFtpXS5mZWF0dXJlcztcbiAgICAgICAgcGF0aFtpXSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgIH1cblxuICAgIC8vIFRyYWNlIGFsbCBwZXJtdXRhdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIHJlc3VsdGluZyBtZWRpYS1xdWVyeS5cbiAgICAvL1xuICAgIC8vIChhLCBiIGFuZCBjKSB3aXRoIG5lc3RlZCAoZCwgZSkgLT5cbiAgICAvLyAgICBhIGFuZCBkXG4gICAgLy8gICAgYSBhbmQgZVxuICAgIC8vICAgIGIgYW5kIGMgYW5kIGRcbiAgICAvLyAgICBiIGFuZCBjIGFuZCBlXG4gICAgdGhpcy5mZWF0dXJlcyA9IG5ldyBWYWx1ZSh0aGlzLnBlcm11dGUocGF0aCkubWFwKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLm1hcChmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudC50b0NTUyA/IGZyYWdtZW50IDogbmV3IEFub255bW91cyhmcmFnbWVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgcGF0aC5zcGxpY2UoaSwgMCwgbmV3IEFub255bW91cyhcImFuZFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb24ocGF0aCk7XG4gICAgfSkpO1xuXG4gICAgLy8gRmFrZSBhIHRyZWUtbm9kZSB0aGF0IGRvZXNuJ3Qgb3V0cHV0IGFueXRoaW5nLlxuICAgIHJldHVybiBuZXcgUnVsZXNldChbXSwgW10pO1xufTtcbk1lZGlhLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gKGFycikge1xuICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKGFyci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGFyclswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5wZXJtdXRlKGFyci5zbGljZSgxKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcnJbMF0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbYXJyWzBdW2pdXS5jb25jYXQocmVzdFtpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcbk1lZGlhLnByb3RvdHlwZS5idWJibGVTZWxlY3RvcnMgPSBmdW5jdGlvbiAoc2VsZWN0b3JzKSB7XG4gICAgaWYgKCFzZWxlY3RvcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJ1bGVzID0gW25ldyBSdWxlc2V0KHNlbGVjdG9ycy5zbGljZSgwKSwgW3RoaXMucnVsZXNbMF1dKV07XG59O1xubW9kdWxlLmV4cG9ydHMgPSBNZWRpYTtcblxufSx7XCIuL2Fub255bW91c1wiOjQ2LFwiLi9kaXJlY3RpdmVcIjo1NyxcIi4vZXhwcmVzc2lvblwiOjU5LFwiLi9ydWxlc2V0XCI6NzYsXCIuL3NlbGVjdG9yXCI6NzcsXCIuL3ZhbHVlXCI6ODF9XSw2NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIiksXG4gICAgU2VsZWN0b3IgPSByZXF1aXJlKFwiLi9zZWxlY3RvclwiKSxcbiAgICBNaXhpbkRlZmluaXRpb24gPSByZXF1aXJlKFwiLi9taXhpbi1kZWZpbml0aW9uXCIpLFxuICAgIGRlZmF1bHRGdW5jID0gcmVxdWlyZShcIi4uL2Z1bmN0aW9ucy9kZWZhdWx0XCIpO1xuXG52YXIgTWl4aW5DYWxsID0gZnVuY3Rpb24gKGVsZW1lbnRzLCBhcmdzLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCBpbXBvcnRhbnQpIHtcbiAgICB0aGlzLnNlbGVjdG9yID0gbmV3IFNlbGVjdG9yKGVsZW1lbnRzKTtcbiAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3MgfHwgW107XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY3VycmVudEZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xuICAgIHRoaXMuaW1wb3J0YW50ID0gaW1wb3J0YW50O1xuICAgIHRoaXMuYWxsb3dSb290ID0gdHJ1ZTtcbn07XG5NaXhpbkNhbGwucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbk1peGluQ2FsbC5wcm90b3R5cGUudHlwZSA9IFwiTWl4aW5DYWxsXCI7XG5NaXhpbkNhbGwucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHZpc2l0b3IudmlzaXQodGhpcy5zZWxlY3Rvcik7XG4gICAgfVxuICAgIGlmICh0aGlzLmFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5hcmd1bWVudHMgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy5hcmd1bWVudHMpO1xuICAgIH1cbn07XG5NaXhpbkNhbGwucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtaXhpbnMsIG1peGluLCBtaXhpblBhdGgsIGFyZ3MgPSBbXSwgYXJnLCBhcmdWYWx1ZSxcbiAgICAgICAgcnVsZXMgPSBbXSwgbWF0Y2ggPSBmYWxzZSwgaSwgbSwgZiwgaXNSZWN1cnNpdmUsIGlzT25lRm91bmQsXG4gICAgICAgIGNhbmRpZGF0ZXMgPSBbXSwgY2FuZGlkYXRlLCBjb25kaXRpb25SZXN1bHQgPSBbXSwgZGVmYXVsdFJlc3VsdCwgZGVmRmFsc2VFaXRoZXJDYXNlID0gLTEsXG4gICAgICAgIGRlZk5vbmUgPSAwLCBkZWZUcnVlID0gMSwgZGVmRmFsc2UgPSAyLCBjb3VudCwgb3JpZ2luYWxSdWxlc2V0LCBub0FyZ3VtZW50c0ZpbHRlcjtcblxuICAgIGZ1bmN0aW9uIGNhbGNEZWZHcm91cChtaXhpbiwgbWl4aW5QYXRoKSB7XG4gICAgICAgIHZhciBmLCBwLCBuYW1lc3BhY2U7XG5cbiAgICAgICAgZm9yIChmID0gMDsgZiA8IDI7IGYrKykge1xuICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0W2ZdID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlZmF1bHRGdW5jLnZhbHVlKGYpO1xuICAgICAgICAgICAgZm9yIChwID0gMDsgcCA8IG1peGluUGF0aC5sZW5ndGggJiYgY29uZGl0aW9uUmVzdWx0W2ZdOyBwKyspIHtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2UgPSBtaXhpblBhdGhbcF07XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVzcGFjZS5tYXRjaENvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25SZXN1bHRbZl0gPSBjb25kaXRpb25SZXN1bHRbZl0gJiYgbmFtZXNwYWNlLm1hdGNoQ29uZGl0aW9uKG51bGwsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaXhpbi5tYXRjaENvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvblJlc3VsdFtmXSA9IGNvbmRpdGlvblJlc3VsdFtmXSAmJiBtaXhpbi5tYXRjaENvbmRpdGlvbihhcmdzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZGl0aW9uUmVzdWx0WzBdIHx8IGNvbmRpdGlvblJlc3VsdFsxXSkge1xuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJlc3VsdFswXSAhPSBjb25kaXRpb25SZXN1bHRbMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uUmVzdWx0WzFdID9cbiAgICAgICAgICAgICAgICAgICAgZGVmVHJ1ZSA6IGRlZkZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGVmTm9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmRmFsc2VFaXRoZXJDYXNlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcmcgPSB0aGlzLmFyZ3VtZW50c1tpXTtcbiAgICAgICAgYXJnVmFsdWUgPSBhcmcudmFsdWUuZXZhbChjb250ZXh0KTtcbiAgICAgICAgaWYgKGFyZy5leHBhbmQgJiYgQXJyYXkuaXNBcnJheShhcmdWYWx1ZS52YWx1ZSkpIHtcbiAgICAgICAgICAgIGFyZ1ZhbHVlID0gYXJnVmFsdWUudmFsdWU7XG4gICAgICAgICAgICBmb3IgKG0gPSAwOyBtIDwgYXJnVmFsdWUubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goe3ZhbHVlOiBhcmdWYWx1ZVttXX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJncy5wdXNoKHtuYW1lOiBhcmcubmFtZSwgdmFsdWU6IGFyZ1ZhbHVlfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBub0FyZ3VtZW50c0ZpbHRlciA9IGZ1bmN0aW9uKHJ1bGUpIHtyZXR1cm4gcnVsZS5tYXRjaEFyZ3MobnVsbCwgY29udGV4dCk7fTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb250ZXh0LmZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKG1peGlucyA9IGNvbnRleHQuZnJhbWVzW2ldLmZpbmQodGhpcy5zZWxlY3RvciwgbnVsbCwgbm9Bcmd1bWVudHNGaWx0ZXIpKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpc09uZUZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gVG8gbWFrZSBgZGVmYXVsdCgpYCBmdW5jdGlvbiBpbmRlcGVuZGVudCBvZiBkZWZpbml0aW9uIG9yZGVyIHdlIGhhdmUgdHdvIFwic3VicGFzc2VzXCIgaGVyZS5cbiAgICAgICAgICAgIC8vIEF0IGZpcnN0IHdlIGV2YWx1YXRlIGVhY2ggZ3VhcmQgKnR3aWNlKiAod2l0aCBgZGVmYXVsdCgpID09IHRydWVgIGFuZCBgZGVmYXVsdCgpID09IGZhbHNlYCksXG4gICAgICAgICAgICAvLyBhbmQgYnVpbGQgY2FuZGlkYXRlIGxpc3Qgd2l0aCBjb3JyZXNwb25kaW5nIGZsYWdzLiBUaGVuLCB3aGVuIHdlIGtub3cgYWxsIHBvc3NpYmxlIG1hdGNoZXMsXG4gICAgICAgICAgICAvLyB3ZSBtYWtlIGEgZmluYWwgZGVjaXNpb24uXG5cbiAgICAgICAgICAgIGZvciAobSA9IDA7IG0gPCBtaXhpbnMubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICAgICAgICBtaXhpbiA9IG1peGluc1ttXS5ydWxlO1xuICAgICAgICAgICAgICAgIG1peGluUGF0aCA9IG1peGluc1ttXS5wYXRoO1xuICAgICAgICAgICAgICAgIGlzUmVjdXJzaXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChmID0gMDsgZiA8IGNvbnRleHQuZnJhbWVzLmxlbmd0aDsgZisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoIShtaXhpbiBpbnN0YW5jZW9mIE1peGluRGVmaW5pdGlvbikpICYmIG1peGluID09PSAoY29udGV4dC5mcmFtZXNbZl0ub3JpZ2luYWxSdWxlc2V0IHx8IGNvbnRleHQuZnJhbWVzW2ZdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZWN1cnNpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVjdXJzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtaXhpbi5tYXRjaEFyZ3MoYXJncywgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlID0ge21peGluOiBtaXhpbiwgZ3JvdXA6IGNhbGNEZWZHcm91cChtaXhpbiwgbWl4aW5QYXRoKX07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS5ncm91cCAhPT0gZGVmRmFsc2VFaXRoZXJDYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHRGdW5jLnJlc2V0KCk7XG5cbiAgICAgICAgICAgIGNvdW50ID0gWzAsIDAsIDBdO1xuICAgICAgICAgICAgZm9yIChtID0gMDsgbSA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudFtjYW5kaWRhdGVzW21dLmdyb3VwXSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY291bnRbZGVmTm9uZV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFJlc3VsdCA9IGRlZkZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0UmVzdWx0ID0gZGVmVHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoKGNvdW50W2RlZlRydWVdICsgY291bnRbZGVmRmFsc2VdKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnUnVudGltZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQW1iaWd1b3VzIHVzZSBvZiBgZGVmYXVsdCgpYCBmb3VuZCB3aGVuIG1hdGNoaW5nIGZvciBgJyArIHRoaXMuZm9ybWF0KGFyZ3MpICsgJ2AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsIGZpbGVuYW1lOiB0aGlzLmN1cnJlbnRGaWxlSW5mby5maWxlbmFtZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChtID0gMDsgbSA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBjYW5kaWRhdGVzW21dLmdyb3VwO1xuICAgICAgICAgICAgICAgIGlmICgoY2FuZGlkYXRlID09PSBkZWZOb25lKSB8fCAoY2FuZGlkYXRlID09PSBkZWZhdWx0UmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWl4aW4gPSBjYW5kaWRhdGVzW21dLm1peGluO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWl4aW4gaW5zdGFuY2VvZiBNaXhpbkRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxSdWxlc2V0ID0gbWl4aW4ub3JpZ2luYWxSdWxlc2V0IHx8IG1peGluO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1peGluID0gbmV3IE1peGluRGVmaW5pdGlvbihcIlwiLCBbXSwgbWl4aW4ucnVsZXMsIG51bGwsIGZhbHNlLCBudWxsLCBvcmlnaW5hbFJ1bGVzZXQudmlzaWJpbGl0eUluZm8oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWl4aW4ub3JpZ2luYWxSdWxlc2V0ID0gb3JpZ2luYWxSdWxlc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1J1bGVzID0gbWl4aW4uZXZhbENhbGwoY29udGV4dCwgYXJncywgdGhpcy5pbXBvcnRhbnQpLnJ1bGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0VmlzaWJpbGl0eVRvUmVwbGFjZW1lbnQobmV3UnVsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocnVsZXMsIG5ld1J1bGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiBlLm1lc3NhZ2UsIGluZGV4OiB0aGlzLmluZGV4LCBmaWxlbmFtZTogdGhpcy5jdXJyZW50RmlsZUluZm8uZmlsZW5hbWUsIHN0YWNrOiBlLnN0YWNrIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBydWxlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNPbmVGb3VuZCkge1xuICAgICAgICB0aHJvdyB7IHR5cGU6ICAgICdSdW50aW1lJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdObyBtYXRjaGluZyBkZWZpbml0aW9uIHdhcyBmb3VuZCBmb3IgYCcgKyB0aGlzLmZvcm1hdChhcmdzKSArICdgJyxcbiAgICAgICAgICAgIGluZGV4OiAgIHRoaXMuaW5kZXgsIGZpbGVuYW1lOiB0aGlzLmN1cnJlbnRGaWxlSW5mby5maWxlbmFtZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHsgdHlwZTogICAgJ05hbWUnLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5zZWxlY3Rvci50b0NTUygpLnRyaW0oKSArIFwiIGlzIHVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgaW5kZXg6ICAgdGhpcy5pbmRleCwgZmlsZW5hbWU6IHRoaXMuY3VycmVudEZpbGVJbmZvLmZpbGVuYW1lIH07XG4gICAgfVxufTtcblxuTWl4aW5DYWxsLnByb3RvdHlwZS5fc2V0VmlzaWJpbGl0eVRvUmVwbGFjZW1lbnQgPSBmdW5jdGlvbiAocmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgaSwgcnVsZTtcbiAgICBpZiAodGhpcy5ibG9ja3NWaXNpYmlsaXR5KCkpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlcGxhY2VtZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBydWxlID0gcmVwbGFjZW1lbnRbaV07XG4gICAgICAgICAgICBydWxlLmFkZFZpc2liaWxpdHlCbG9jaygpO1xuICAgICAgICB9XG4gICAgfVxufTtcbk1peGluQ2FsbC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rvci50b0NTUygpLnRyaW0oKSArICcoJyArXG4gICAgICAgIChhcmdzID8gYXJncy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHZhciBhcmdWYWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoYS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgYXJnVmFsdWUgKz0gYS5uYW1lICsgXCI6XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYS52YWx1ZS50b0NTUykge1xuICAgICAgICAgICAgICAgIGFyZ1ZhbHVlICs9IGEudmFsdWUudG9DU1MoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJnVmFsdWUgKz0gXCI/Pz9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmdWYWx1ZTtcbiAgICAgICAgfSkuam9pbignLCAnKSA6IFwiXCIpICsgXCIpXCI7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBNaXhpbkNhbGw7XG5cbn0se1wiLi4vZnVuY3Rpb25zL2RlZmF1bHRcIjoyMCxcIi4vbWl4aW4tZGVmaW5pdGlvblwiOjY4LFwiLi9ub2RlXCI6NzAsXCIuL3NlbGVjdG9yXCI6Nzd9XSw2ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2VsZWN0b3IgPSByZXF1aXJlKFwiLi9zZWxlY3RvclwiKSxcbiAgICBFbGVtZW50ID0gcmVxdWlyZShcIi4vZWxlbWVudFwiKSxcbiAgICBSdWxlc2V0ID0gcmVxdWlyZShcIi4vcnVsZXNldFwiKSxcbiAgICBSdWxlID0gcmVxdWlyZShcIi4vcnVsZVwiKSxcbiAgICBFeHByZXNzaW9uID0gcmVxdWlyZShcIi4vZXhwcmVzc2lvblwiKSxcbiAgICBjb250ZXh0cyA9IHJlcXVpcmUoXCIuLi9jb250ZXh0c1wiKTtcblxudmFyIERlZmluaXRpb24gPSBmdW5jdGlvbiAobmFtZSwgcGFyYW1zLCBydWxlcywgY29uZGl0aW9uLCB2YXJpYWRpYywgZnJhbWVzLCB2aXNpYmlsaXR5SW5mbykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5zZWxlY3RvcnMgPSBbbmV3IFNlbGVjdG9yKFtuZXcgRWxlbWVudChudWxsLCBuYW1lLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbyldKV07XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgdGhpcy52YXJpYWRpYyA9IHZhcmlhZGljO1xuICAgIHRoaXMuYXJpdHkgPSBwYXJhbXMubGVuZ3RoO1xuICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICB0aGlzLl9sb29rdXBzID0ge307XG4gICAgdmFyIG9wdGlvbmFsUGFyYW1ldGVycyA9IFtdO1xuICAgIHRoaXMucmVxdWlyZWQgPSBwYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChjb3VudCwgcCkge1xuICAgICAgICBpZiAoIXAubmFtZSB8fCAocC5uYW1lICYmICFwLnZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbmFsUGFyYW1ldGVycy5wdXNoKHAubmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH1cbiAgICB9LCAwKTtcbiAgICB0aGlzLm9wdGlvbmFsUGFyYW1ldGVycyA9IG9wdGlvbmFsUGFyYW1ldGVycztcbiAgICB0aGlzLmZyYW1lcyA9IGZyYW1lcztcbiAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XG4gICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xufTtcbkRlZmluaXRpb24ucHJvdG90eXBlID0gbmV3IFJ1bGVzZXQoKTtcbkRlZmluaXRpb24ucHJvdG90eXBlLnR5cGUgPSBcIk1peGluRGVmaW5pdGlvblwiO1xuRGVmaW5pdGlvbi5wcm90b3R5cGUuZXZhbEZpcnN0ID0gdHJ1ZTtcbkRlZmluaXRpb24ucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgaWYgKHRoaXMucGFyYW1zICYmIHRoaXMucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLnBhcmFtcyk7XG4gICAgfVxuICAgIHRoaXMucnVsZXMgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy5ydWxlcyk7XG4gICAgaWYgKHRoaXMuY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gdmlzaXRvci52aXNpdCh0aGlzLmNvbmRpdGlvbik7XG4gICAgfVxufTtcbkRlZmluaXRpb24ucHJvdG90eXBlLmV2YWxQYXJhbXMgPSBmdW5jdGlvbiAoY29udGV4dCwgbWl4aW5FbnYsIGFyZ3MsIGV2YWxkQXJndW1lbnRzKSB7XG4gICAgLypqc2hpbnQgYm9zczp0cnVlICovXG4gICAgdmFyIGZyYW1lID0gbmV3IFJ1bGVzZXQobnVsbCwgbnVsbCksXG4gICAgICAgIHZhcmFyZ3MsIGFyZyxcbiAgICAgICAgcGFyYW1zID0gdGhpcy5wYXJhbXMuc2xpY2UoMCksXG4gICAgICAgIGksIGosIHZhbCwgbmFtZSwgaXNOYW1lZEZvdW5kLCBhcmdJbmRleCwgYXJnc0xlbmd0aCA9IDA7XG5cbiAgICBpZiAobWl4aW5FbnYuZnJhbWVzICYmIG1peGluRW52LmZyYW1lc1swXSAmJiBtaXhpbkVudi5mcmFtZXNbMF0uZnVuY3Rpb25SZWdpc3RyeSkge1xuICAgICAgICBmcmFtZS5mdW5jdGlvblJlZ2lzdHJ5ID0gbWl4aW5FbnYuZnJhbWVzWzBdLmZ1bmN0aW9uUmVnaXN0cnkuaW5oZXJpdCgpO1xuICAgIH1cbiAgICBtaXhpbkVudiA9IG5ldyBjb250ZXh0cy5FdmFsKG1peGluRW52LCBbZnJhbWVdLmNvbmNhdChtaXhpbkVudi5mcmFtZXMpKTtcblxuICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDApO1xuICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3NMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICAgIGlmIChuYW1lID0gKGFyZyAmJiBhcmcubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpc05hbWVkRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGFyYW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZhbGRBcmd1bWVudHNbal0gJiYgbmFtZSA9PT0gcGFyYW1zW2pdLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWxkQXJndW1lbnRzW2pdID0gYXJnLnZhbHVlLmV2YWwoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5wcmVwZW5kUnVsZShuZXcgUnVsZShuYW1lLCBhcmcudmFsdWUuZXZhbChjb250ZXh0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNOYW1lZEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc05hbWVkRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnUnVudGltZScsIG1lc3NhZ2U6IFwiTmFtZWQgYXJndW1lbnQgZm9yIFwiICsgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgJyArIGFyZ3NbaV0ubmFtZSArICcgbm90IGZvdW5kJyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhcmdJbmRleCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZXZhbGRBcmd1bWVudHNbaV0pIHsgY29udGludWU7IH1cblxuICAgICAgICBhcmcgPSBhcmdzICYmIGFyZ3NbYXJnSW5kZXhdO1xuXG4gICAgICAgIGlmIChuYW1lID0gcGFyYW1zW2ldLm5hbWUpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXNbaV0udmFyaWFkaWMpIHtcbiAgICAgICAgICAgICAgICB2YXJhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChqID0gYXJnSW5kZXg7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyYXJncy5wdXNoKGFyZ3Nbal0udmFsdWUuZXZhbChjb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyYW1lLnByZXBlbmRSdWxlKG5ldyBSdWxlKG5hbWUsIG5ldyBFeHByZXNzaW9uKHZhcmFyZ3MpLmV2YWwoY29udGV4dCkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsID0gYXJnICYmIGFyZy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5ldmFsKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zW2ldLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcmFtc1tpXS52YWx1ZS5ldmFsKG1peGluRW52KTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUucmVzZXRDYWNoZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ1J1bnRpbWUnLCBtZXNzYWdlOiBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgZm9yIFwiICsgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgKCcgKyBhcmdzTGVuZ3RoICsgJyBmb3IgJyArIHRoaXMuYXJpdHkgKyAnKScgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmcmFtZS5wcmVwZW5kUnVsZShuZXcgUnVsZShuYW1lLCB2YWwpKTtcbiAgICAgICAgICAgICAgICBldmFsZEFyZ3VtZW50c1tpXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXNbaV0udmFyaWFkaWMgJiYgYXJncykge1xuICAgICAgICAgICAgZm9yIChqID0gYXJnSW5kZXg7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBldmFsZEFyZ3VtZW50c1tqXSA9IGFyZ3Nbal0udmFsdWUuZXZhbChjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcmdJbmRleCsrO1xuICAgIH1cblxuICAgIHJldHVybiBmcmFtZTtcbn07XG5EZWZpbml0aW9uLnByb3RvdHlwZS5tYWtlSW1wb3J0YW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJ1bGVzID0gIXRoaXMucnVsZXMgPyB0aGlzLnJ1bGVzIDogdGhpcy5ydWxlcy5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgaWYgKHIubWFrZUltcG9ydGFudCkge1xuICAgICAgICAgICAgcmV0dXJuIHIubWFrZUltcG9ydGFudCh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBEZWZpbml0aW9uKHRoaXMubmFtZSwgdGhpcy5wYXJhbXMsIHJ1bGVzLCB0aGlzLmNvbmRpdGlvbiwgdGhpcy52YXJpYWRpYywgdGhpcy5mcmFtZXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuRGVmaW5pdGlvbi5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBEZWZpbml0aW9uKHRoaXMubmFtZSwgdGhpcy5wYXJhbXMsIHRoaXMucnVsZXMsIHRoaXMuY29uZGl0aW9uLCB0aGlzLnZhcmlhZGljLCB0aGlzLmZyYW1lcyB8fCBjb250ZXh0LmZyYW1lcy5zbGljZSgwKSk7XG59O1xuRGVmaW5pdGlvbi5wcm90b3R5cGUuZXZhbENhbGwgPSBmdW5jdGlvbiAoY29udGV4dCwgYXJncywgaW1wb3J0YW50KSB7XG4gICAgdmFyIF9hcmd1bWVudHMgPSBbXSxcbiAgICAgICAgbWl4aW5GcmFtZXMgPSB0aGlzLmZyYW1lcyA/IHRoaXMuZnJhbWVzLmNvbmNhdChjb250ZXh0LmZyYW1lcykgOiBjb250ZXh0LmZyYW1lcyxcbiAgICAgICAgZnJhbWUgPSB0aGlzLmV2YWxQYXJhbXMoY29udGV4dCwgbmV3IGNvbnRleHRzLkV2YWwoY29udGV4dCwgbWl4aW5GcmFtZXMpLCBhcmdzLCBfYXJndW1lbnRzKSxcbiAgICAgICAgcnVsZXMsIHJ1bGVzZXQ7XG5cbiAgICBmcmFtZS5wcmVwZW5kUnVsZShuZXcgUnVsZSgnQGFyZ3VtZW50cycsIG5ldyBFeHByZXNzaW9uKF9hcmd1bWVudHMpLmV2YWwoY29udGV4dCkpKTtcblxuICAgIHJ1bGVzID0gdGhpcy5ydWxlcy5zbGljZSgwKTtcblxuICAgIHJ1bGVzZXQgPSBuZXcgUnVsZXNldChudWxsLCBydWxlcyk7XG4gICAgcnVsZXNldC5vcmlnaW5hbFJ1bGVzZXQgPSB0aGlzO1xuICAgIHJ1bGVzZXQgPSBydWxlc2V0LmV2YWwobmV3IGNvbnRleHRzLkV2YWwoY29udGV4dCwgW3RoaXMsIGZyYW1lXS5jb25jYXQobWl4aW5GcmFtZXMpKSk7XG4gICAgaWYgKGltcG9ydGFudCkge1xuICAgICAgICBydWxlc2V0ID0gcnVsZXNldC5tYWtlSW1wb3J0YW50KCk7XG4gICAgfVxuICAgIHJldHVybiBydWxlc2V0O1xufTtcbkRlZmluaXRpb24ucHJvdG90eXBlLm1hdGNoQ29uZGl0aW9uID0gZnVuY3Rpb24gKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5jb25kaXRpb24gJiYgIXRoaXMuY29uZGl0aW9uLmV2YWwoXG4gICAgICAgIG5ldyBjb250ZXh0cy5FdmFsKGNvbnRleHQsXG4gICAgICAgICAgICBbdGhpcy5ldmFsUGFyYW1zKGNvbnRleHQsIC8qIHRoZSBwYXJhbWV0ZXIgdmFyaWFibGVzKi9cbiAgICAgICAgICAgICAgICBuZXcgY29udGV4dHMuRXZhbChjb250ZXh0LCB0aGlzLmZyYW1lcyA/IHRoaXMuZnJhbWVzLmNvbmNhdChjb250ZXh0LmZyYW1lcykgOiBjb250ZXh0LmZyYW1lcyksIGFyZ3MsIFtdKV1cbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5mcmFtZXMgfHwgW10pIC8vIHRoZSBwYXJlbnQgbmFtZXNwYWNlL21peGluIGZyYW1lc1xuICAgICAgICAgICAgLmNvbmNhdChjb250ZXh0LmZyYW1lcykpKSkgeyAvLyB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBmcmFtZXNcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5EZWZpbml0aW9uLnByb3RvdHlwZS5tYXRjaEFyZ3MgPSBmdW5jdGlvbiAoYXJncywgY29udGV4dCkge1xuICAgIHZhciBhbGxBcmdzQ250ID0gKGFyZ3MgJiYgYXJncy5sZW5ndGgpIHx8IDAsIGxlbiwgb3B0aW9uYWxQYXJhbWV0ZXJzID0gdGhpcy5vcHRpb25hbFBhcmFtZXRlcnM7XG4gICAgdmFyIHJlcXVpcmVkQXJnc0NudCA9ICFhcmdzID8gMCA6IGFyZ3MucmVkdWNlKGZ1bmN0aW9uIChjb3VudCwgcCkge1xuICAgICAgICBpZiAob3B0aW9uYWxQYXJhbWV0ZXJzLmluZGV4T2YocC5uYW1lKSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjb3VudCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH1cbiAgICB9LCAwKTtcblxuICAgIGlmICghIHRoaXMudmFyaWFkaWMpIHtcbiAgICAgICAgaWYgKHJlcXVpcmVkQXJnc0NudCA8IHRoaXMucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsQXJnc0NudCA+IHRoaXMucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlcXVpcmVkQXJnc0NudCA8ICh0aGlzLnJlcXVpcmVkIC0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIHBhdHRlcm5zXG4gICAgbGVuID0gTWF0aC5taW4ocmVxdWlyZWRBcmdzQ250LCB0aGlzLmFyaXR5KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmFtc1tpXS5uYW1lICYmICF0aGlzLnBhcmFtc1tpXS52YXJpYWRpYykge1xuICAgICAgICAgICAgaWYgKGFyZ3NbaV0udmFsdWUuZXZhbChjb250ZXh0KS50b0NTUygpICE9IHRoaXMucGFyYW1zW2ldLnZhbHVlLmV2YWwoY29udGV4dCkudG9DU1MoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERlZmluaXRpb247XG5cbn0se1wiLi4vY29udGV4dHNcIjoxMSxcIi4vZWxlbWVudFwiOjU4LFwiLi9leHByZXNzaW9uXCI6NTksXCIuL3J1bGVcIjo3NCxcIi4vcnVsZXNldFwiOjc2LFwiLi9zZWxlY3RvclwiOjc3fV0sNjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpLFxuICAgIE9wZXJhdGlvbiA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKSxcbiAgICBEaW1lbnNpb24gPSByZXF1aXJlKFwiLi9kaW1lbnNpb25cIik7XG5cbnZhciBOZWdhdGl2ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdGhpcy52YWx1ZSA9IG5vZGU7XG59O1xuTmVnYXRpdmUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbk5lZ2F0aXZlLnByb3RvdHlwZS50eXBlID0gXCJOZWdhdGl2ZVwiO1xuTmVnYXRpdmUucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICBvdXRwdXQuYWRkKCctJyk7XG4gICAgdGhpcy52YWx1ZS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbn07XG5OZWdhdGl2ZS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQuaXNNYXRoT24oKSkge1xuICAgICAgICByZXR1cm4gKG5ldyBPcGVyYXRpb24oJyonLCBbbmV3IERpbWVuc2lvbigtMSksIHRoaXMudmFsdWVdKSkuZXZhbChjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOZWdhdGl2ZSh0aGlzLnZhbHVlLmV2YWwoY29udGV4dCkpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gTmVnYXRpdmU7XG5cbn0se1wiLi9kaW1lbnNpb25cIjo1NixcIi4vbm9kZVwiOjcwLFwiLi9vcGVyYXRpb25cIjo3MX1dLDcwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gZnVuY3Rpb24oKSB7XG59O1xuTm9kZS5wcm90b3R5cGUudG9DU1MgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBzdHJzID0gW107XG4gICAgdGhpcy5nZW5DU1MoY29udGV4dCwge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uKGNodW5rLCBmaWxlSW5mbywgaW5kZXgpIHtcbiAgICAgICAgICAgIHN0cnMucHVzaChjaHVuayk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHJzLmpvaW4oJycpO1xufTtcbk5vZGUucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICBvdXRwdXQuYWRkKHRoaXMudmFsdWUpO1xufTtcbk5vZGUucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZpc2l0b3IudmlzaXQodGhpcy52YWx1ZSk7XG59O1xuTm9kZS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5Ob2RlLnByb3RvdHlwZS5fb3BlcmF0ZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBvcCwgYSwgYikge1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgY2FzZSAnKyc6IHJldHVybiBhICsgYjtcbiAgICAgICAgY2FzZSAnLSc6IHJldHVybiBhIC0gYjtcbiAgICAgICAgY2FzZSAnKic6IHJldHVybiBhICogYjtcbiAgICAgICAgY2FzZSAnLyc6IHJldHVybiBhIC8gYjtcbiAgICB9XG59O1xuTm9kZS5wcm90b3R5cGUuZnJvdW5kID0gZnVuY3Rpb24oY29udGV4dCwgdmFsdWUpIHtcbiAgICB2YXIgcHJlY2lzaW9uID0gY29udGV4dCAmJiBjb250ZXh0Lm51bVByZWNpc2lvbjtcbiAgICAvL2FkZCBcImVwc2lsb25cIiB0byBlbnN1cmUgbnVtYmVycyBsaWtlIDEuMDAwMDAwMDA1IChyZXByZXNlbnRlZCBhcyAxLjAwMDAwMDAwNDk5OS4uLi4pIGFyZSBwcm9wZXJseSByb3VuZGVkLi4uXG4gICAgcmV0dXJuIChwcmVjaXNpb24gPT0gbnVsbCkgPyB2YWx1ZSA6IE51bWJlcigodmFsdWUgKyAyZS0xNikudG9GaXhlZChwcmVjaXNpb24pKTtcbn07XG5Ob2RlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8qIHJldHVybnM6XG4gICAgIC0xOiBhIDwgYlxuICAgICAwOiBhID0gYlxuICAgICAxOiBhID4gYlxuICAgICBhbmQgKmFueSogb3RoZXIgdmFsdWUgZm9yIGEgIT0gYiAoZS5nLiB1bmRlZmluZWQsIE5hTiwgLTIgZXRjLikgKi9cblxuICAgIGlmICgoYS5jb21wYXJlKSAmJlxuICAgICAgICAvLyBmb3IgXCJzeW1tZXRyaWMgcmVzdWx0c1wiIGZvcmNlIHRvQ1NTLWJhc2VkIGNvbXBhcmlzb25cbiAgICAgICAgLy8gb2YgUXVvdGVkIG9yIEFub255bW91cyBpZiBlaXRoZXIgdmFsdWUgaXMgb25lIG9mIHRob3NlXG4gICAgICAgICEoYi50eXBlID09PSBcIlF1b3RlZFwiIHx8IGIudHlwZSA9PT0gXCJBbm9ueW1vdXNcIikpIHtcbiAgICAgICAgcmV0dXJuIGEuY29tcGFyZShiKTtcbiAgICB9IGVsc2UgaWYgKGIuY29tcGFyZSkge1xuICAgICAgICByZXR1cm4gLWIuY29tcGFyZShhKTtcbiAgICB9IGVsc2UgaWYgKGEudHlwZSAhPT0gYi50eXBlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgYSA9IGEudmFsdWU7XG4gICAgYiA9IGIudmFsdWU7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiID8gMCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKE5vZGUuY29tcGFyZShhW2ldLCBiW2ldKSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5cbk5vZGUubnVtZXJpY0NvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhICA8ICBiID8gLTFcbiAgICAgICAgOiBhID09PSBiID8gIDBcbiAgICAgICAgOiBhICA+ICBiID8gIDEgOiB1bmRlZmluZWQ7XG59O1xuLy8gUmV0dXJucyB0cnVlIGlmIHRoaXMgbm9kZSByZXByZXNlbnRzIHJvb3Qgb2YgYXN0IGltcG9ydGVkIGJ5IHJlZmVyZW5jZVxuTm9kZS5wcm90b3R5cGUuYmxvY2tzVmlzaWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy52aXNpYmlsaXR5QmxvY2tzID09IG51bGwpIHtcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5QmxvY2tzID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmlzaWJpbGl0eUJsb2NrcyAhPT0gMDtcbn07XG5Ob2RlLnByb3RvdHlwZS5hZGRWaXNpYmlsaXR5QmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9IDA7XG4gICAgfVxuICAgIHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9IHRoaXMudmlzaWJpbGl0eUJsb2NrcyArIDE7XG59O1xuTm9kZS5wcm90b3R5cGUucmVtb3ZlVmlzaWJpbGl0eUJsb2NrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnZpc2liaWxpdHlCbG9ja3MgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlCbG9ja3MgPSAwO1xuICAgIH1cbiAgICB0aGlzLnZpc2liaWxpdHlCbG9ja3MgPSB0aGlzLnZpc2liaWxpdHlCbG9ja3MgLSAxO1xufTtcbi8vVHVybnMgb24gbm9kZSB2aXNpYmlsaXR5IC0gaWYgY2FsbGVkIG5vZGUgd2lsbCBiZSBzaG93biBpbiBvdXRwdXQgcmVnYXJkbGVzc1xuLy9vZiB3aGV0aGVyIGl0IGNvbWVzIGZyb20gaW1wb3J0IGJ5IHJlZmVyZW5jZSBvciBub3Rcbk5vZGUucHJvdG90eXBlLmVuc3VyZVZpc2liaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ub2RlVmlzaWJsZSA9IHRydWU7XG59O1xuLy9UdXJucyBvZmYgbm9kZSB2aXNpYmlsaXR5IC0gaWYgY2FsbGVkIG5vZGUgd2lsbCBOT1QgYmUgc2hvd24gaW4gb3V0cHV0IHJlZ2FyZGxlc3Ncbi8vb2Ygd2hldGhlciBpdCBjb21lcyBmcm9tIGltcG9ydCBieSByZWZlcmVuY2Ugb3Igbm90XG5Ob2RlLnByb3RvdHlwZS5lbnN1cmVJbnZpc2liaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ub2RlVmlzaWJsZSA9IGZhbHNlO1xufTtcbi8vIHJldHVybiB2YWx1ZXM6XG4vLyBmYWxzZSAtIHRoZSBub2RlIG11c3Qgbm90IGJlIHZpc2libGVcbi8vIHRydWUgLSB0aGUgbm9kZSBtdXN0IGJlIHZpc2libGVcbi8vIHVuZGVmaW5lZCBvciBudWxsIC0gdGhlIG5vZGUgaGFzIHRoZSBzYW1lIHZpc2liaWxpdHkgYXMgaXRzIHBhcmVudFxuTm9kZS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVWaXNpYmxlO1xufTtcbk5vZGUucHJvdG90eXBlLnZpc2liaWxpdHlJbmZvID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmlzaWJpbGl0eUJsb2NrczogdGhpcy52aXNpYmlsaXR5QmxvY2tzLFxuICAgICAgICBub2RlVmlzaWJsZTogdGhpcy5ub2RlVmlzaWJsZVxuICAgIH07XG59O1xuTm9kZS5wcm90b3R5cGUuY29weVZpc2liaWxpdHlJbmZvID0gZnVuY3Rpb24oaW5mbykge1xuICAgIGlmICghaW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9IGluZm8udmlzaWJpbGl0eUJsb2NrcztcbiAgICB0aGlzLm5vZGVWaXNpYmxlID0gaW5mby5ub2RlVmlzaWJsZTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IE5vZGU7XG5cbn0se31dLDcxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICBDb2xvciA9IHJlcXVpcmUoXCIuL2NvbG9yXCIpLFxuICAgIERpbWVuc2lvbiA9IHJlcXVpcmUoXCIuL2RpbWVuc2lvblwiKTtcblxudmFyIE9wZXJhdGlvbiA9IGZ1bmN0aW9uIChvcCwgb3BlcmFuZHMsIGlzU3BhY2VkKSB7XG4gICAgdGhpcy5vcCA9IG9wLnRyaW0oKTtcbiAgICB0aGlzLm9wZXJhbmRzID0gb3BlcmFuZHM7XG4gICAgdGhpcy5pc1NwYWNlZCA9IGlzU3BhY2VkO1xufTtcbk9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuT3BlcmF0aW9uLnByb3RvdHlwZS50eXBlID0gXCJPcGVyYXRpb25cIjtcbk9wZXJhdGlvbi5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICB0aGlzLm9wZXJhbmRzID0gdmlzaXRvci52aXNpdCh0aGlzLm9wZXJhbmRzKTtcbn07XG5PcGVyYXRpb24ucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBhID0gdGhpcy5vcGVyYW5kc1swXS5ldmFsKGNvbnRleHQpLFxuICAgICAgICBiID0gdGhpcy5vcGVyYW5kc1sxXS5ldmFsKGNvbnRleHQpO1xuXG4gICAgaWYgKGNvbnRleHQuaXNNYXRoT24oKSkge1xuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIERpbWVuc2lvbiAmJiBiIGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgICAgICAgIGEgPSBhLnRvQ29sb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIERpbWVuc2lvbiAmJiBhIGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgICAgICAgIGIgPSBiLnRvQ29sb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWEub3BlcmF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiBcIk9wZXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIk9wZXJhdGlvbiBvbiBhbiBpbnZhbGlkIHR5cGVcIiB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEub3BlcmF0ZShjb250ZXh0LCB0aGlzLm9wLCBiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IE9wZXJhdGlvbih0aGlzLm9wLCBbYSwgYl0sIHRoaXMuaXNTcGFjZWQpO1xuICAgIH1cbn07XG5PcGVyYXRpb24ucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICB0aGlzLm9wZXJhbmRzWzBdLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgIGlmICh0aGlzLmlzU3BhY2VkKSB7XG4gICAgICAgIG91dHB1dC5hZGQoXCIgXCIpO1xuICAgIH1cbiAgICBvdXRwdXQuYWRkKHRoaXMub3ApO1xuICAgIGlmICh0aGlzLmlzU3BhY2VkKSB7XG4gICAgICAgIG91dHB1dC5hZGQoXCIgXCIpO1xuICAgIH1cbiAgICB0aGlzLm9wZXJhbmRzWzFdLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcGVyYXRpb247XG5cbn0se1wiLi9jb2xvclwiOjUwLFwiLi9kaW1lbnNpb25cIjo1NixcIi4vbm9kZVwiOjcwfV0sNzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuXG52YXIgUGFyZW4gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHRoaXMudmFsdWUgPSBub2RlO1xufTtcblBhcmVuLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5QYXJlbi5wcm90b3R5cGUudHlwZSA9IFwiUGFyZW5cIjtcblBhcmVuLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LmFkZCgnKCcpO1xuICAgIHRoaXMudmFsdWUuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgb3V0cHV0LmFkZCgnKScpO1xufTtcblBhcmVuLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFBhcmVuKHRoaXMudmFsdWUuZXZhbChjb250ZXh0KSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBQYXJlbjtcblxufSx7XCIuL25vZGVcIjo3MH1dLDczOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICBKc0V2YWxOb2RlID0gcmVxdWlyZShcIi4vanMtZXZhbC1ub2RlXCIpLFxuICAgIFZhcmlhYmxlID0gcmVxdWlyZShcIi4vdmFyaWFibGVcIik7XG5cbnZhciBRdW90ZWQgPSBmdW5jdGlvbiAoc3RyLCBjb250ZW50LCBlc2NhcGVkLCBpbmRleCwgY3VycmVudEZpbGVJbmZvKSB7XG4gICAgdGhpcy5lc2NhcGVkID0gKGVzY2FwZWQgPT0gbnVsbCkgPyB0cnVlIDogZXNjYXBlZDtcbiAgICB0aGlzLnZhbHVlID0gY29udGVudCB8fCAnJztcbiAgICB0aGlzLnF1b3RlID0gc3RyLmNoYXJBdCgwKTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5jdXJyZW50RmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XG59O1xuUXVvdGVkLnByb3RvdHlwZSA9IG5ldyBKc0V2YWxOb2RlKCk7XG5RdW90ZWQucHJvdG90eXBlLnR5cGUgPSBcIlF1b3RlZFwiO1xuUXVvdGVkLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgaWYgKCF0aGlzLmVzY2FwZWQpIHtcbiAgICAgICAgb3V0cHV0LmFkZCh0aGlzLnF1b3RlLCB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIG91dHB1dC5hZGQodGhpcy52YWx1ZSk7XG4gICAgaWYgKCF0aGlzLmVzY2FwZWQpIHtcbiAgICAgICAgb3V0cHV0LmFkZCh0aGlzLnF1b3RlKTtcbiAgICB9XG59O1xuUXVvdGVkLnByb3RvdHlwZS5jb250YWluc1ZhcmlhYmxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLm1hdGNoKC8oYChbXmBdKylgKXxAXFx7KFtcXHctXSspXFx9Lyk7XG59O1xuUXVvdGVkLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXMsIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICB2YXIgamF2YXNjcmlwdFJlcGxhY2VtZW50ID0gZnVuY3Rpb24gKF8sIGV4cCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoYXQuZXZhbHVhdGVKYXZhU2NyaXB0KGV4cCwgY29udGV4dCkpO1xuICAgIH07XG4gICAgdmFyIGludGVycG9sYXRpb25SZXBsYWNlbWVudCA9IGZ1bmN0aW9uIChfLCBuYW1lKSB7XG4gICAgICAgIHZhciB2ID0gbmV3IFZhcmlhYmxlKCdAJyArIG5hbWUsIHRoYXQuaW5kZXgsIHRoYXQuY3VycmVudEZpbGVJbmZvKS5ldmFsKGNvbnRleHQsIHRydWUpO1xuICAgICAgICByZXR1cm4gKHYgaW5zdGFuY2VvZiBRdW90ZWQpID8gdi52YWx1ZSA6IHYudG9DU1MoKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGl0ZXJhdGl2ZVJlcGxhY2UodmFsdWUsIHJlZ2V4cCwgcmVwbGFjZW1lbnRGbmMpIHtcbiAgICAgICAgdmFyIGV2YWx1YXRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhbHVlID0gZXZhbHVhdGVkVmFsdWU7XG4gICAgICAgICAgICBldmFsdWF0ZWRWYWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVnZXhwLCByZXBsYWNlbWVudEZuYyk7XG4gICAgICAgIH0gd2hpbGUgKHZhbHVlICE9PSBldmFsdWF0ZWRWYWx1ZSk7XG4gICAgICAgIHJldHVybiBldmFsdWF0ZWRWYWx1ZTtcbiAgICB9XG4gICAgdmFsdWUgPSBpdGVyYXRpdmVSZXBsYWNlKHZhbHVlLCAvYChbXmBdKylgL2csIGphdmFzY3JpcHRSZXBsYWNlbWVudCk7XG4gICAgdmFsdWUgPSBpdGVyYXRpdmVSZXBsYWNlKHZhbHVlLCAvQFxceyhbXFx3LV0rKVxcfS9nLCBpbnRlcnBvbGF0aW9uUmVwbGFjZW1lbnQpO1xuICAgIHJldHVybiBuZXcgUXVvdGVkKHRoaXMucXVvdGUgKyB2YWx1ZSArIHRoaXMucXVvdGUsIHZhbHVlLCB0aGlzLmVzY2FwZWQsIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvKTtcbn07XG5RdW90ZWQucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAvLyB3aGVuIGNvbXBhcmluZyBxdW90ZWQgc3RyaW5ncyBhbGxvdyB0aGUgcXVvdGUgdG8gZGlmZmVyXG4gICAgaWYgKG90aGVyLnR5cGUgPT09IFwiUXVvdGVkXCIgJiYgIXRoaXMuZXNjYXBlZCAmJiAhb3RoZXIuZXNjYXBlZCkge1xuICAgICAgICByZXR1cm4gTm9kZS5udW1lcmljQ29tcGFyZSh0aGlzLnZhbHVlLCBvdGhlci52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLnRvQ1NTICYmIHRoaXMudG9DU1MoKSA9PT0gb3RoZXIudG9DU1MoKSA/IDAgOiB1bmRlZmluZWQ7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gUXVvdGVkO1xuXG59LHtcIi4vanMtZXZhbC1ub2RlXCI6NjQsXCIuL25vZGVcIjo3MCxcIi4vdmFyaWFibGVcIjo4Mn1dLDc0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICBWYWx1ZSA9IHJlcXVpcmUoXCIuL3ZhbHVlXCIpLFxuICAgIEtleXdvcmQgPSByZXF1aXJlKFwiLi9rZXl3b3JkXCIpO1xuXG52YXIgUnVsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgaW1wb3J0YW50LCBtZXJnZSwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgaW5saW5lLCB2YXJpYWJsZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy52YWx1ZSA9ICh2YWx1ZSBpbnN0YW5jZW9mIE5vZGUpID8gdmFsdWUgOiBuZXcgVmFsdWUoW3ZhbHVlXSk7IC8vdmFsdWUgaW5zdGFuY2VvZiB0cmVlLlZhbHVlIHx8IHZhbHVlIGluc3RhbmNlb2YgdHJlZS5SdWxlc2V0ID8/XG4gICAgdGhpcy5pbXBvcnRhbnQgPSBpbXBvcnRhbnQgPyAnICcgKyBpbXBvcnRhbnQudHJpbSgpIDogJyc7XG4gICAgdGhpcy5tZXJnZSA9IG1lcmdlO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmN1cnJlbnRGaWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcbiAgICB0aGlzLmlubGluZSA9IGlubGluZSB8fCBmYWxzZTtcbiAgICB0aGlzLnZhcmlhYmxlID0gKHZhcmlhYmxlICE9PSB1bmRlZmluZWQpID8gdmFyaWFibGVcbiAgICAgICAgOiAobmFtZS5jaGFyQXQgJiYgKG5hbWUuY2hhckF0KDApID09PSAnQCcpKTtcbiAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XG59O1xuXG5mdW5jdGlvbiBldmFsTmFtZShjb250ZXh0LCBuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gXCJcIiwgaSwgbiA9IG5hbWUubGVuZ3RoLFxuICAgICAgICBvdXRwdXQgPSB7YWRkOiBmdW5jdGlvbiAocykge3ZhbHVlICs9IHM7fX07XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBuYW1lW2ldLmV2YWwoY29udGV4dCkuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuUnVsZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuUnVsZS5wcm90b3R5cGUudHlwZSA9IFwiUnVsZVwiO1xuUnVsZS5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIG91dHB1dC5hZGQodGhpcy5uYW1lICsgKGNvbnRleHQuY29tcHJlc3MgPyAnOicgOiAnOiAnKSwgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRoaXMuaW5kZXgpO1xuICAgIHRyeSB7XG4gICAgICAgIHRoaXMudmFsdWUuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgfVxuICAgIGNhdGNoKGUpIHtcbiAgICAgICAgZS5pbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIGUuZmlsZW5hbWUgPSB0aGlzLmN1cnJlbnRGaWxlSW5mby5maWxlbmFtZTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgb3V0cHV0LmFkZCh0aGlzLmltcG9ydGFudCArICgodGhpcy5pbmxpbmUgfHwgKGNvbnRleHQubGFzdFJ1bGUgJiYgY29udGV4dC5jb21wcmVzcykpID8gXCJcIiA6IFwiO1wiKSwgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRoaXMuaW5kZXgpO1xufTtcblJ1bGUucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBzdHJpY3RNYXRoQnlwYXNzID0gZmFsc2UsIG5hbWUgPSB0aGlzLm5hbWUsIGV2YWxkVmFsdWUsIHZhcmlhYmxlID0gdGhpcy52YXJpYWJsZTtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gZXhwYW5kICdwcmltaXRpdmUnIG5hbWUgZGlyZWN0bHkgdG8gZ2V0XG4gICAgICAgIC8vIHRoaW5ncyBmYXN0ZXIgKH4xMCUgZm9yIGJlbmNobWFyay5sZXNzKTpcbiAgICAgICAgbmFtZSA9IChuYW1lLmxlbmd0aCA9PT0gMSkgJiYgKG5hbWVbMF0gaW5zdGFuY2VvZiBLZXl3b3JkKSA/XG4gICAgICAgICAgICAgICAgbmFtZVswXS52YWx1ZSA6IGV2YWxOYW1lKGNvbnRleHQsIG5hbWUpO1xuICAgICAgICB2YXJpYWJsZSA9IGZhbHNlOyAvLyBuZXZlciB0cmVhdCBleHBhbmRlZCBpbnRlcnBvbGF0aW9uIGFzIG5ldyB2YXJpYWJsZSBuYW1lXG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcImZvbnRcIiAmJiAhY29udGV4dC5zdHJpY3RNYXRoKSB7XG4gICAgICAgIHN0cmljdE1hdGhCeXBhc3MgPSB0cnVlO1xuICAgICAgICBjb250ZXh0LnN0cmljdE1hdGggPSB0cnVlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb250ZXh0LmltcG9ydGFudFNjb3BlLnB1c2goe30pO1xuICAgICAgICBldmFsZFZhbHVlID0gdGhpcy52YWx1ZS5ldmFsKGNvbnRleHQpO1xuXG4gICAgICAgIGlmICghdGhpcy52YXJpYWJsZSAmJiBldmFsZFZhbHVlLnR5cGUgPT09IFwiRGV0YWNoZWRSdWxlc2V0XCIpIHtcbiAgICAgICAgICAgIHRocm93IHsgbWVzc2FnZTogXCJSdWxlc2V0cyBjYW5ub3QgYmUgZXZhbHVhdGVkIG9uIGEgcHJvcGVydHkuXCIsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LCBmaWxlbmFtZTogdGhpcy5jdXJyZW50RmlsZUluZm8uZmlsZW5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW1wb3J0YW50ID0gdGhpcy5pbXBvcnRhbnQsXG4gICAgICAgICAgICBpbXBvcnRhbnRSZXN1bHQgPSBjb250ZXh0LmltcG9ydGFudFNjb3BlLnBvcCgpO1xuICAgICAgICBpZiAoIWltcG9ydGFudCAmJiBpbXBvcnRhbnRSZXN1bHQuaW1wb3J0YW50KSB7XG4gICAgICAgICAgICBpbXBvcnRhbnQgPSBpbXBvcnRhbnRSZXN1bHQuaW1wb3J0YW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSdWxlKG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV2YWxkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGFudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRoaXMuaW5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUpO1xuICAgIH1cbiAgICBjYXRjaChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZS5pbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGUuaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgZS5maWxlbmFtZSA9IHRoaXMuY3VycmVudEZpbGVJbmZvLmZpbGVuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBpZiAoc3RyaWN0TWF0aEJ5cGFzcykge1xuICAgICAgICAgICAgY29udGV4dC5zdHJpY3RNYXRoID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59O1xuUnVsZS5wcm90b3R5cGUubWFrZUltcG9ydGFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFJ1bGUodGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIiFpbXBvcnRhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRoaXMuaW5saW5lKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUnVsZTtcbn0se1wiLi9rZXl3b3JkXCI6NjUsXCIuL25vZGVcIjo3MCxcIi4vdmFsdWVcIjo4MX1dLDc1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICBWYXJpYWJsZSA9IHJlcXVpcmUoXCIuL3ZhcmlhYmxlXCIpO1xuXG52YXIgUnVsZXNldENhbGwgPSBmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICB0aGlzLnZhcmlhYmxlID0gdmFyaWFibGU7XG4gICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xufTtcblJ1bGVzZXRDYWxsLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5SdWxlc2V0Q2FsbC5wcm90b3R5cGUudHlwZSA9IFwiUnVsZXNldENhbGxcIjtcblJ1bGVzZXRDYWxsLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgZGV0YWNoZWRSdWxlc2V0ID0gbmV3IFZhcmlhYmxlKHRoaXMudmFyaWFibGUpLmV2YWwoY29udGV4dCk7XG4gICAgcmV0dXJuIGRldGFjaGVkUnVsZXNldC5jYWxsRXZhbChjb250ZXh0KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFJ1bGVzZXRDYWxsO1xuXG59LHtcIi4vbm9kZVwiOjcwLFwiLi92YXJpYWJsZVwiOjgyfV0sNzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpLFxuICAgIFJ1bGUgPSByZXF1aXJlKFwiLi9ydWxlXCIpLFxuICAgIFNlbGVjdG9yID0gcmVxdWlyZShcIi4vc2VsZWN0b3JcIiksXG4gICAgRWxlbWVudCA9IHJlcXVpcmUoXCIuL2VsZW1lbnRcIiksXG4gICAgUGFyZW4gPSByZXF1aXJlKFwiLi9wYXJlblwiKSxcbiAgICBjb250ZXh0cyA9IHJlcXVpcmUoXCIuLi9jb250ZXh0c1wiKSxcbiAgICBnbG9iYWxGdW5jdGlvblJlZ2lzdHJ5ID0gcmVxdWlyZShcIi4uL2Z1bmN0aW9ucy9mdW5jdGlvbi1yZWdpc3RyeVwiKSxcbiAgICBkZWZhdWx0RnVuYyA9IHJlcXVpcmUoXCIuLi9mdW5jdGlvbnMvZGVmYXVsdFwiKSxcbiAgICBnZXREZWJ1Z0luZm8gPSByZXF1aXJlKFwiLi9kZWJ1Zy1pbmZvXCIpO1xuXG52YXIgUnVsZXNldCA9IGZ1bmN0aW9uIChzZWxlY3RvcnMsIHJ1bGVzLCBzdHJpY3RJbXBvcnRzLCB2aXNpYmlsaXR5SW5mbykge1xuICAgIHRoaXMuc2VsZWN0b3JzID0gc2VsZWN0b3JzO1xuICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICB0aGlzLl9sb29rdXBzID0ge307XG4gICAgdGhpcy5zdHJpY3RJbXBvcnRzID0gc3RyaWN0SW1wb3J0cztcbiAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XG4gICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xufTtcblJ1bGVzZXQucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblJ1bGVzZXQucHJvdG90eXBlLnR5cGUgPSBcIlJ1bGVzZXRcIjtcblJ1bGVzZXQucHJvdG90eXBlLmlzUnVsZXNldCA9IHRydWU7XG5SdWxlc2V0LnByb3RvdHlwZS5pc1J1bGVzZXRMaWtlID0gdHJ1ZTtcblJ1bGVzZXQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgaWYgKHRoaXMucGF0aHMpIHtcbiAgICAgICAgdGhpcy5wYXRocyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLnBhdGhzLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0b3JzKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JzID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMuc2VsZWN0b3JzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucnVsZXMgJiYgdGhpcy5ydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLnJ1bGVzKTtcbiAgICB9XG59O1xuUnVsZXNldC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIHRoaXNTZWxlY3RvcnMgPSB0aGlzLnNlbGVjdG9ycywgc2VsZWN0b3JzLFxuICAgICAgICBzZWxDbnQsIHNlbGVjdG9yLCBpLCBoYXNPbmVQYXNzaW5nU2VsZWN0b3IgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzU2VsZWN0b3JzICYmIChzZWxDbnQgPSB0aGlzU2VsZWN0b3JzLmxlbmd0aCkpIHtcbiAgICAgICAgc2VsZWN0b3JzID0gW107XG4gICAgICAgIGRlZmF1bHRGdW5jLmVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IFwiU3ludGF4XCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcIml0IGlzIGN1cnJlbnRseSBvbmx5IGFsbG93ZWQgaW4gcGFyYW1ldHJpYyBtaXhpbiBndWFyZHMsXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxDbnQ7IGkrKykge1xuICAgICAgICAgICAgc2VsZWN0b3IgPSB0aGlzU2VsZWN0b3JzW2ldLmV2YWwoY29udGV4dCk7XG4gICAgICAgICAgICBzZWxlY3RvcnMucHVzaChzZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoc2VsZWN0b3IuZXZhbGRDb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICBoYXNPbmVQYXNzaW5nU2VsZWN0b3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRGdW5jLnJlc2V0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaGFzT25lUGFzc2luZ1NlbGVjdG9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzID8gdGhpcy5ydWxlcy5zbGljZSgwKSA6IG51bGwsXG4gICAgICAgIHJ1bGVzZXQgPSBuZXcgUnVsZXNldChzZWxlY3RvcnMsIHJ1bGVzLCB0aGlzLnN0cmljdEltcG9ydHMsIHRoaXMudmlzaWJpbGl0eUluZm8oKSksXG4gICAgICAgIHJ1bGUsIHN1YlJ1bGU7XG5cbiAgICBydWxlc2V0Lm9yaWdpbmFsUnVsZXNldCA9IHRoaXM7XG4gICAgcnVsZXNldC5yb290ID0gdGhpcy5yb290O1xuICAgIHJ1bGVzZXQuZmlyc3RSb290ID0gdGhpcy5maXJzdFJvb3Q7XG4gICAgcnVsZXNldC5hbGxvd0ltcG9ydHMgPSB0aGlzLmFsbG93SW1wb3J0cztcblxuICAgIGlmICh0aGlzLmRlYnVnSW5mbykge1xuICAgICAgICBydWxlc2V0LmRlYnVnSW5mbyA9IHRoaXMuZGVidWdJbmZvO1xuICAgIH1cblxuICAgIGlmICghaGFzT25lUGFzc2luZ1NlbGVjdG9yKSB7XG4gICAgICAgIHJ1bGVzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgLy8gaW5oZXJpdCBhIGZ1bmN0aW9uIHJlZ2lzdHJ5IGZyb20gdGhlIGZyYW1lcyBzdGFjayB3aGVuIHBvc3NpYmxlO1xuICAgIC8vIG90aGVyd2lzZSBmcm9tIHRoZSBnbG9iYWwgcmVnaXN0cnlcbiAgICBydWxlc2V0LmZ1bmN0aW9uUmVnaXN0cnkgPSAoZnVuY3Rpb24gKGZyYW1lcykge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBuID0gZnJhbWVzLmxlbmd0aCxcbiAgICAgICAgICAgIGZvdW5kO1xuICAgICAgICBmb3IgKCA7IGkgIT09IG4gOyArK2kgKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGZyYW1lc1sgaSBdLmZ1bmN0aW9uUmVnaXN0cnk7XG4gICAgICAgICAgICBpZiAoIGZvdW5kICkgeyByZXR1cm4gZm91bmQ7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYmFsRnVuY3Rpb25SZWdpc3RyeTtcbiAgICB9KGNvbnRleHQuZnJhbWVzKSkuaW5oZXJpdCgpO1xuXG4gICAgLy8gcHVzaCB0aGUgY3VycmVudCBydWxlc2V0IHRvIHRoZSBmcmFtZXMgc3RhY2tcbiAgICB2YXIgY3R4RnJhbWVzID0gY29udGV4dC5mcmFtZXM7XG4gICAgY3R4RnJhbWVzLnVuc2hpZnQocnVsZXNldCk7XG5cbiAgICAvLyBjdXJycmVudCBzZWxlY3RvcnNcbiAgICB2YXIgY3R4U2VsZWN0b3JzID0gY29udGV4dC5zZWxlY3RvcnM7XG4gICAgaWYgKCFjdHhTZWxlY3RvcnMpIHtcbiAgICAgICAgY29udGV4dC5zZWxlY3RvcnMgPSBjdHhTZWxlY3RvcnMgPSBbXTtcbiAgICB9XG4gICAgY3R4U2VsZWN0b3JzLnVuc2hpZnQodGhpcy5zZWxlY3RvcnMpO1xuXG4gICAgLy8gRXZhbHVhdGUgaW1wb3J0c1xuICAgIGlmIChydWxlc2V0LnJvb3QgfHwgcnVsZXNldC5hbGxvd0ltcG9ydHMgfHwgIXJ1bGVzZXQuc3RyaWN0SW1wb3J0cykge1xuICAgICAgICBydWxlc2V0LmV2YWxJbXBvcnRzKGNvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIFN0b3JlIHRoZSBmcmFtZXMgYXJvdW5kIG1peGluIGRlZmluaXRpb25zLFxuICAgIC8vIHNvIHRoZXkgY2FuIGJlIGV2YWx1YXRlZCBsaWtlIGNsb3N1cmVzIHdoZW4gdGhlIHRpbWUgY29tZXMuXG4gICAgdmFyIHJzUnVsZXMgPSBydWxlc2V0LnJ1bGVzLCByc1J1bGVDbnQgPSByc1J1bGVzID8gcnNSdWxlcy5sZW5ndGggOiAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCByc1J1bGVDbnQ7IGkrKykge1xuICAgICAgICBpZiAocnNSdWxlc1tpXS5ldmFsRmlyc3QpIHtcbiAgICAgICAgICAgIHJzUnVsZXNbaV0gPSByc1J1bGVzW2ldLmV2YWwoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWVkaWFCbG9ja0NvdW50ID0gKGNvbnRleHQubWVkaWFCbG9ja3MgJiYgY29udGV4dC5tZWRpYUJsb2Nrcy5sZW5ndGgpIHx8IDA7XG5cbiAgICAvLyBFdmFsdWF0ZSBtaXhpbiBjYWxscy5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcnNSdWxlQ250OyBpKyspIHtcbiAgICAgICAgaWYgKHJzUnVsZXNbaV0udHlwZSA9PT0gXCJNaXhpbkNhbGxcIikge1xuICAgICAgICAgICAgLypqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSAqL1xuICAgICAgICAgICAgcnVsZXMgPSByc1J1bGVzW2ldLmV2YWwoY29udGV4dCkuZmlsdGVyKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHIgaW5zdGFuY2VvZiBSdWxlKSAmJiByLnZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBwb2xsdXRlIHRoZSBzY29wZSBpZiB0aGUgdmFyaWFibGUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxyZWFkeSB0aGVyZS4gY29uc2lkZXIgcmV0dXJuaW5nIGZhbHNlIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHdlIG5lZWQgYSB3YXkgdG8gXCJyZXR1cm5cIiB2YXJpYWJsZSBmcm9tIG1peGluc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIShydWxlc2V0LnZhcmlhYmxlKHIubmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcnNSdWxlcy5zcGxpY2UuYXBwbHkocnNSdWxlcywgW2ksIDFdLmNvbmNhdChydWxlcykpO1xuICAgICAgICAgICAgcnNSdWxlQ250ICs9IHJ1bGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpICs9IHJ1bGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBydWxlc2V0LnJlc2V0Q2FjaGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChyc1J1bGVzW2ldLnR5cGUgPT09IFwiUnVsZXNldENhbGxcIikge1xuICAgICAgICAgICAgLypqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSAqL1xuICAgICAgICAgICAgcnVsZXMgPSByc1J1bGVzW2ldLmV2YWwoY29udGV4dCkucnVsZXMuZmlsdGVyKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHIgaW5zdGFuY2VvZiBSdWxlKSAmJiByLnZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBwb2xsdXRlIHRoZSBzY29wZSBhdCBhbGxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcnNSdWxlcy5zcGxpY2UuYXBwbHkocnNSdWxlcywgW2ksIDFdLmNvbmNhdChydWxlcykpO1xuICAgICAgICAgICAgcnNSdWxlQ250ICs9IHJ1bGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpICs9IHJ1bGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBydWxlc2V0LnJlc2V0Q2FjaGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV2YWx1YXRlIGV2ZXJ5dGhpbmcgZWxzZVxuICAgIGZvciAoaSA9IDA7IGkgPCByc1J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJ1bGUgPSByc1J1bGVzW2ldO1xuICAgICAgICBpZiAoIXJ1bGUuZXZhbEZpcnN0KSB7XG4gICAgICAgICAgICByc1J1bGVzW2ldID0gcnVsZSA9IHJ1bGUuZXZhbCA/IHJ1bGUuZXZhbChjb250ZXh0KSA6IHJ1bGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFdmFsdWF0ZSBldmVyeXRoaW5nIGVsc2VcbiAgICBmb3IgKGkgPSAwOyBpIDwgcnNSdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBydWxlID0gcnNSdWxlc1tpXTtcbiAgICAgICAgLy8gZm9yIHJ1bGVzZXRzLCBjaGVjayBpZiBpdCBpcyBhIGNzcyBndWFyZCBhbmQgY2FuIGJlIHJlbW92ZWRcbiAgICAgICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBSdWxlc2V0ICYmIHJ1bGUuc2VsZWN0b3JzICYmIHJ1bGUuc2VsZWN0b3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXQgY2FuIGJlIGZvbGRlZCBpbiAoZS5nLiAmIHdoZXJlKVxuICAgICAgICAgICAgaWYgKHJ1bGUuc2VsZWN0b3JzWzBdLmlzSnVzdFBhcmVudFNlbGVjdG9yKCkpIHtcbiAgICAgICAgICAgICAgICByc1J1bGVzLnNwbGljZShpLS0sIDEpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBydWxlLnJ1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YlJ1bGUgPSBydWxlLnJ1bGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBzdWJSdWxlLmNvcHlWaXNpYmlsaXR5SW5mbyhydWxlLnZpc2liaWxpdHlJbmZvKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShzdWJSdWxlIGluc3RhbmNlb2YgUnVsZSkgfHwgIXN1YlJ1bGUudmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJzUnVsZXMuc3BsaWNlKCsraSwgMCwgc3ViUnVsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQb3AgdGhlIHN0YWNrXG4gICAgY3R4RnJhbWVzLnNoaWZ0KCk7XG4gICAgY3R4U2VsZWN0b3JzLnNoaWZ0KCk7XG5cbiAgICBpZiAoY29udGV4dC5tZWRpYUJsb2Nrcykge1xuICAgICAgICBmb3IgKGkgPSBtZWRpYUJsb2NrQ291bnQ7IGkgPCBjb250ZXh0Lm1lZGlhQmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm1lZGlhQmxvY2tzW2ldLmJ1YmJsZVNlbGVjdG9ycyhzZWxlY3RvcnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGVzZXQ7XG59O1xuUnVsZXNldC5wcm90b3R5cGUuZXZhbEltcG9ydHMgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlcywgaSwgaW1wb3J0UnVsZXM7XG4gICAgaWYgKCFydWxlcykgeyByZXR1cm47IH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocnVsZXNbaV0udHlwZSA9PT0gXCJJbXBvcnRcIikge1xuICAgICAgICAgICAgaW1wb3J0UnVsZXMgPSBydWxlc1tpXS5ldmFsKGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGltcG9ydFJ1bGVzICYmIChpbXBvcnRSdWxlcy5sZW5ndGggfHwgaW1wb3J0UnVsZXMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgIHJ1bGVzLnNwbGljZS5hcHBseShydWxlcywgW2ksIDFdLmNvbmNhdChpbXBvcnRSdWxlcykpO1xuICAgICAgICAgICAgICAgIGkrPSBpbXBvcnRSdWxlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBydWxlcy5zcGxpY2UoaSwgMSwgaW1wb3J0UnVsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXNldENhY2hlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuUnVsZXNldC5wcm90b3R5cGUubWFrZUltcG9ydGFudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQgPSBuZXcgUnVsZXNldCh0aGlzLnNlbGVjdG9ycywgdGhpcy5ydWxlcy5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgaWYgKHIubWFrZUltcG9ydGFudCkge1xuICAgICAgICAgICAgcmV0dXJuIHIubWFrZUltcG9ydGFudCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICB9KSwgdGhpcy5zdHJpY3RJbXBvcnRzLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5SdWxlc2V0LnByb3RvdHlwZS5tYXRjaEFyZ3MgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiAhYXJncyB8fCBhcmdzLmxlbmd0aCA9PT0gMDtcbn07XG4vLyBsZXRzIHlvdSBjYWxsIGEgY3NzIHNlbGVjdG9yIHdpdGggYSBndWFyZFxuUnVsZXNldC5wcm90b3R5cGUubWF0Y2hDb25kaXRpb24gPSBmdW5jdGlvbiAoYXJncywgY29udGV4dCkge1xuICAgIHZhciBsYXN0U2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yc1t0aGlzLnNlbGVjdG9ycy5sZW5ndGggLSAxXTtcbiAgICBpZiAoIWxhc3RTZWxlY3Rvci5ldmFsZENvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsYXN0U2VsZWN0b3IuY29uZGl0aW9uICYmXG4gICAgICAgICFsYXN0U2VsZWN0b3IuY29uZGl0aW9uLmV2YWwoXG4gICAgICAgICAgICBuZXcgY29udGV4dHMuRXZhbChjb250ZXh0LFxuICAgICAgICAgICAgICAgIGNvbnRleHQuZnJhbWVzKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5SdWxlc2V0LnByb3RvdHlwZS5yZXNldENhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3J1bGVzZXRzID0gbnVsbDtcbiAgICB0aGlzLl92YXJpYWJsZXMgPSBudWxsO1xuICAgIHRoaXMuX2xvb2t1cHMgPSB7fTtcbn07XG5SdWxlc2V0LnByb3RvdHlwZS52YXJpYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl92YXJpYWJsZXMpIHtcbiAgICAgICAgdGhpcy5fdmFyaWFibGVzID0gIXRoaXMucnVsZXMgPyB7fSA6IHRoaXMucnVsZXMucmVkdWNlKGZ1bmN0aW9uIChoYXNoLCByKSB7XG4gICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIFJ1bGUgJiYgci52YXJpYWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGhhc2hbci5uYW1lXSA9IHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3aGVuIGV2YWx1YXRpbmcgdmFyaWFibGVzIGluIGFuIGltcG9ydCBzdGF0ZW1lbnQsIGltcG9ydHMgaGF2ZSBub3QgYmVlbiBldmFsJ2RcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gZ28gaW5zaWRlIGltcG9ydCBzdGF0ZW1lbnRzLlxuICAgICAgICAgICAgLy8gZ3VhcmQgYWdhaW5zdCByb290IGJlaW5nIGEgc3RyaW5nIChpbiB0aGUgY2FzZSBvZiBpbmxpbmVkIGxlc3MpXG4gICAgICAgICAgICBpZiAoci50eXBlID09PSBcIkltcG9ydFwiICYmIHIucm9vdCAmJiByLnJvb3QudmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhcnMgPSByLnJvb3QudmFyaWFibGVzKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB2YXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YXJzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoW25hbWVdID0gdmFyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YXJpYWJsZXM7XG59O1xuUnVsZXNldC5wcm90b3R5cGUudmFyaWFibGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnZhcmlhYmxlcygpW25hbWVdO1xufTtcblJ1bGVzZXQucHJvdG90eXBlLnJ1bGVzZXRzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5ydWxlcykgeyByZXR1cm4gW107IH1cblxuICAgIHZhciBmaWx0UnVsZXMgPSBbXSwgcnVsZXMgPSB0aGlzLnJ1bGVzLCBjbnQgPSBydWxlcy5sZW5ndGgsXG4gICAgICAgIGksIHJ1bGU7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY250OyBpKyspIHtcbiAgICAgICAgcnVsZSA9IHJ1bGVzW2ldO1xuICAgICAgICBpZiAocnVsZS5pc1J1bGVzZXQpIHtcbiAgICAgICAgICAgIGZpbHRSdWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRSdWxlcztcbn07XG5SdWxlc2V0LnByb3RvdHlwZS5wcmVwZW5kUnVsZSA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlcztcbiAgICBpZiAocnVsZXMpIHtcbiAgICAgICAgcnVsZXMudW5zaGlmdChydWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJ1bGVzID0gWyBydWxlIF07XG4gICAgfVxufTtcblJ1bGVzZXQucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNlbGYsIGZpbHRlcikge1xuICAgIHNlbGYgPSBzZWxmIHx8IHRoaXM7XG4gICAgdmFyIHJ1bGVzID0gW10sIG1hdGNoLCBmb3VuZE1peGlucyxcbiAgICAgICAga2V5ID0gc2VsZWN0b3IudG9DU1MoKTtcblxuICAgIGlmIChrZXkgaW4gdGhpcy5fbG9va3VwcykgeyByZXR1cm4gdGhpcy5fbG9va3Vwc1trZXldOyB9XG5cbiAgICB0aGlzLnJ1bGVzZXRzKCkuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICBpZiAocnVsZSAhPT0gc2VsZikge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBydWxlLnNlbGVjdG9ycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gc2VsZWN0b3IubWF0Y2gocnVsZS5zZWxlY3RvcnNbal0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IuZWxlbWVudHMubGVuZ3RoID4gbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihydWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTWl4aW5zID0gcnVsZS5maW5kKG5ldyBTZWxlY3RvcihzZWxlY3Rvci5lbGVtZW50cy5zbGljZShtYXRjaCkpLCBzZWxmLCBmaWx0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm91bmRNaXhpbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRNaXhpbnNbaV0ucGF0aC5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShydWxlcywgZm91bmRNaXhpbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMucHVzaCh7IHJ1bGU6IHJ1bGUsIHBhdGg6IFtdfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fbG9va3Vwc1trZXldID0gcnVsZXM7XG4gICAgcmV0dXJuIHJ1bGVzO1xufTtcblJ1bGVzZXQucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICB2YXIgaSwgaixcbiAgICAgICAgY2hhcnNldFJ1bGVOb2RlcyA9IFtdLFxuICAgICAgICBydWxlTm9kZXMgPSBbXSxcbiAgICAgICAgZGVidWdJbmZvLCAgICAgLy8gTGluZSBudW1iZXIgZGVidWdnaW5nXG4gICAgICAgIHJ1bGUsXG4gICAgICAgIHBhdGg7XG5cbiAgICBjb250ZXh0LnRhYkxldmVsID0gKGNvbnRleHQudGFiTGV2ZWwgfHwgMCk7XG5cbiAgICBpZiAoIXRoaXMucm9vdCkge1xuICAgICAgICBjb250ZXh0LnRhYkxldmVsKys7XG4gICAgfVxuXG4gICAgdmFyIHRhYlJ1bGVTdHIgPSBjb250ZXh0LmNvbXByZXNzID8gJycgOiBBcnJheShjb250ZXh0LnRhYkxldmVsICsgMSkuam9pbihcIiAgXCIpLFxuICAgICAgICB0YWJTZXRTdHIgPSBjb250ZXh0LmNvbXByZXNzID8gJycgOiBBcnJheShjb250ZXh0LnRhYkxldmVsKS5qb2luKFwiICBcIiksXG4gICAgICAgIHNlcDtcblxuICAgIGZ1bmN0aW9uIGlzUnVsZXNldExpa2VOb2RlKHJ1bGUpIHtcbiAgICAgICAgLy8gaWYgaXQgaGFzIG5lc3RlZCBydWxlcywgdGhlbiBpdCBzaG91bGQgYmUgdHJlYXRlZCBsaWtlIGEgcnVsZXNldFxuICAgICAgICAvLyBtZWRpYXMgYW5kIGNvbW1lbnRzIGRvIG5vdCBoYXZlIG5lc3RlZCBydWxlcywgYnV0IHNob3VsZCBiZSB0cmVhdGVkIGxpa2UgcnVsZXNldHMgYW55d2F5XG4gICAgICAgIC8vIHNvbWUgZGlyZWN0aXZlcyBhbmQgYW5vbnltb3VzIG5vZGVzIGFyZSBydWxlc2V0IGxpa2UsIG90aGVycyBhcmUgbm90XG4gICAgICAgIGlmICh0eXBlb2YgcnVsZS5pc1J1bGVzZXRMaWtlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgcmV0dXJuIHJ1bGUuaXNSdWxlc2V0TGlrZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcnVsZS5pc1J1bGVzZXRMaWtlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBydWxlLmlzUnVsZXNldExpa2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGEgcnVsZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJzZXROb2RlSW5kZXggPSAwO1xuICAgIHZhciBpbXBvcnROb2RlSW5kZXggPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJ1bGUgPSB0aGlzLnJ1bGVzW2ldO1xuICAgICAgICBpZiAocnVsZS50eXBlID09PSBcIkNvbW1lbnRcIikge1xuICAgICAgICAgICAgaWYgKGltcG9ydE5vZGVJbmRleCA9PT0gaSkge1xuICAgICAgICAgICAgICAgIGltcG9ydE5vZGVJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVsZU5vZGVzLnB1c2gocnVsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocnVsZS5pc0NoYXJzZXQgJiYgcnVsZS5pc0NoYXJzZXQoKSkge1xuICAgICAgICAgICAgcnVsZU5vZGVzLnNwbGljZShjaGFyc2V0Tm9kZUluZGV4LCAwLCBydWxlKTtcbiAgICAgICAgICAgIGNoYXJzZXROb2RlSW5kZXgrKztcbiAgICAgICAgICAgIGltcG9ydE5vZGVJbmRleCsrO1xuICAgICAgICB9IGVsc2UgaWYgKHJ1bGUudHlwZSA9PT0gXCJJbXBvcnRcIikge1xuICAgICAgICAgICAgcnVsZU5vZGVzLnNwbGljZShpbXBvcnROb2RlSW5kZXgsIDAsIHJ1bGUpO1xuICAgICAgICAgICAgaW1wb3J0Tm9kZUluZGV4Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBydWxlTm9kZXMucHVzaChydWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBydWxlTm9kZXMgPSBjaGFyc2V0UnVsZU5vZGVzLmNvbmNhdChydWxlTm9kZXMpO1xuXG4gICAgLy8gSWYgdGhpcyBpcyB0aGUgcm9vdCBub2RlLCB3ZSBkb24ndCByZW5kZXJcbiAgICAvLyBhIHNlbGVjdG9yLCBvciB7fS5cbiAgICBpZiAoIXRoaXMucm9vdCkge1xuICAgICAgICBkZWJ1Z0luZm8gPSBnZXREZWJ1Z0luZm8oY29udGV4dCwgdGhpcywgdGFiU2V0U3RyKTtcblxuICAgICAgICBpZiAoZGVidWdJbmZvKSB7XG4gICAgICAgICAgICBvdXRwdXQuYWRkKGRlYnVnSW5mbyk7XG4gICAgICAgICAgICBvdXRwdXQuYWRkKHRhYlNldFN0cik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aHMgPSB0aGlzLnBhdGhzLCBwYXRoQ250ID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgICAgcGF0aFN1YkNudDtcblxuICAgICAgICBzZXAgPSBjb250ZXh0LmNvbXByZXNzID8gJywnIDogKCcsXFxuJyArIHRhYlNldFN0cik7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhdGhDbnQ7IGkrKykge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGhzW2ldO1xuICAgICAgICAgICAgaWYgKCEocGF0aFN1YkNudCA9IHBhdGgubGVuZ3RoKSkgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7IG91dHB1dC5hZGQoc2VwKTsgfVxuXG4gICAgICAgICAgICBjb250ZXh0LmZpcnN0U2VsZWN0b3IgPSB0cnVlO1xuICAgICAgICAgICAgcGF0aFswXS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcblxuICAgICAgICAgICAgY29udGV4dC5maXJzdFNlbGVjdG9yID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgcGF0aFN1YkNudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcGF0aFtqXS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5hZGQoKGNvbnRleHQuY29tcHJlc3MgPyAneycgOiAnIHtcXG4nKSArIHRhYlJ1bGVTdHIpO1xuICAgIH1cblxuICAgIC8vIENvbXBpbGUgcnVsZXMgYW5kIHJ1bGVzZXRzXG4gICAgZm9yIChpID0gMDsgaSA8IHJ1bGVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBydWxlID0gcnVsZU5vZGVzW2ldO1xuXG4gICAgICAgIGlmIChpICsgMSA9PT0gcnVsZU5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29udGV4dC5sYXN0UnVsZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VycmVudExhc3RSdWxlID0gY29udGV4dC5sYXN0UnVsZTtcbiAgICAgICAgaWYgKGlzUnVsZXNldExpa2VOb2RlKHJ1bGUpKSB7XG4gICAgICAgICAgICBjb250ZXh0Lmxhc3RSdWxlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocnVsZS5nZW5DU1MpIHtcbiAgICAgICAgICAgIHJ1bGUuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgICAgIH0gZWxzZSBpZiAocnVsZS52YWx1ZSkge1xuICAgICAgICAgICAgb3V0cHV0LmFkZChydWxlLnZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5sYXN0UnVsZSA9IGN1cnJlbnRMYXN0UnVsZTtcblxuICAgICAgICBpZiAoIWNvbnRleHQubGFzdFJ1bGUpIHtcbiAgICAgICAgICAgIG91dHB1dC5hZGQoY29udGV4dC5jb21wcmVzcyA/ICcnIDogKCdcXG4nICsgdGFiUnVsZVN0cikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5sYXN0UnVsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnJvb3QpIHtcbiAgICAgICAgb3V0cHV0LmFkZCgoY29udGV4dC5jb21wcmVzcyA/ICd9JyA6ICdcXG4nICsgdGFiU2V0U3RyICsgJ30nKSk7XG4gICAgICAgIGNvbnRleHQudGFiTGV2ZWwtLTtcbiAgICB9XG5cbiAgICBpZiAoIW91dHB1dC5pc0VtcHR5KCkgJiYgIWNvbnRleHQuY29tcHJlc3MgJiYgdGhpcy5maXJzdFJvb3QpIHtcbiAgICAgICAgb3V0cHV0LmFkZCgnXFxuJyk7XG4gICAgfVxufTtcblxuUnVsZXNldC5wcm90b3R5cGUuam9pblNlbGVjdG9ycyA9IGZ1bmN0aW9uIChwYXRocywgY29udGV4dCwgc2VsZWN0b3JzKSB7XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzZWxlY3RvcnMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgdGhpcy5qb2luU2VsZWN0b3IocGF0aHMsIGNvbnRleHQsIHNlbGVjdG9yc1tzXSk7XG4gICAgfVxufTtcblxuUnVsZXNldC5wcm90b3R5cGUuam9pblNlbGVjdG9yID0gZnVuY3Rpb24gKHBhdGhzLCBjb250ZXh0LCBzZWxlY3Rvcikge1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFyZW50aGVzaXMoZWxlbWVudHNUb1Bhaywgb3JpZ2luYWxFbGVtZW50KSB7XG4gICAgICAgIHZhciByZXBsYWNlbWVudFBhcmVuLCBqO1xuICAgICAgICBpZiAoZWxlbWVudHNUb1Bhay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlcGxhY2VtZW50UGFyZW4gPSBuZXcgUGFyZW4oZWxlbWVudHNUb1Bha1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW5zaWRlUGFyZW50ID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZWxlbWVudHNUb1Bhay5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGluc2lkZVBhcmVudC5wdXNoKG5ldyBFbGVtZW50KG51bGwsIGVsZW1lbnRzVG9QYWtbal0sIG9yaWdpbmFsRWxlbWVudC5pbmRleCwgb3JpZ2luYWxFbGVtZW50LmN1cnJlbnRGaWxlSW5mbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVwbGFjZW1lbnRQYXJlbiA9IG5ldyBQYXJlbihuZXcgU2VsZWN0b3IoaW5zaWRlUGFyZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50UGFyZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3IoY29udGFpbmVkRWxlbWVudCwgb3JpZ2luYWxFbGVtZW50KSB7XG4gICAgICAgIHZhciBlbGVtZW50LCBzZWxlY3RvcjtcbiAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KG51bGwsIGNvbnRhaW5lZEVsZW1lbnQsIG9yaWdpbmFsRWxlbWVudC5pbmRleCwgb3JpZ2luYWxFbGVtZW50LmN1cnJlbnRGaWxlSW5mbyk7XG4gICAgICAgIHNlbGVjdG9yID0gbmV3IFNlbGVjdG9yKFtlbGVtZW50XSk7XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICB9XG5cbiAgICAvLyBqb2lucyBzZWxlY3RvciBwYXRoIGZyb20gYGJlZ2lubmluZ1BhdGhgIHdpdGggc2VsZWN0b3IgcGF0aCBpbiBgYWRkUGF0aGBcbiAgICAvLyBgcmVwbGFjZWRFbGVtZW50YCBjb250YWlucyBlbGVtZW50IHRoYXQgaXMgYmVpbmcgcmVwbGFjZWQgYnkgYGFkZFBhdGhgXG4gICAgLy8gcmV0dXJucyBjb25jYXRlbmF0ZWQgcGF0aFxuICAgIGZ1bmN0aW9uIGFkZFJlcGxhY2VtZW50SW50b1BhdGgoYmVnaW5uaW5nUGF0aCwgYWRkUGF0aCwgcmVwbGFjZWRFbGVtZW50LCBvcmlnaW5hbFNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3RvclBhdGgsIGxhc3RTZWxlY3RvciwgbmV3Sm9pbmVkU2VsZWN0b3I7XG4gICAgICAgIC8vIG91ciBuZXcgc2VsZWN0b3IgcGF0aFxuICAgICAgICBuZXdTZWxlY3RvclBhdGggPSBbXTtcblxuICAgICAgICAvL2NvbnN0cnVjdCB0aGUgam9pbmVkIHNlbGVjdG9yIC0gaWYgJiBpcyB0aGUgZmlyc3QgdGhpbmcgdGhpcyB3aWxsIGJlIGVtcHR5LFxuICAgICAgICAvLyBpZiBub3QgbmV3Sm9pbmVkU2VsZWN0b3Igd2lsbCBiZSB0aGUgbGFzdCBzZXQgb2YgZWxlbWVudHMgaW4gdGhlIHNlbGVjdG9yXG4gICAgICAgIGlmIChiZWdpbm5pbmdQYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5ld1NlbGVjdG9yUGF0aCA9IGJlZ2lubmluZ1BhdGguc2xpY2UoMCk7XG4gICAgICAgICAgICBsYXN0U2VsZWN0b3IgPSBuZXdTZWxlY3RvclBhdGgucG9wKCk7XG4gICAgICAgICAgICBuZXdKb2luZWRTZWxlY3RvciA9IG9yaWdpbmFsU2VsZWN0b3IuY3JlYXRlRGVyaXZlZChsYXN0U2VsZWN0b3IuZWxlbWVudHMuc2xpY2UoMCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3Sm9pbmVkU2VsZWN0b3IgPSBvcmlnaW5hbFNlbGVjdG9yLmNyZWF0ZURlcml2ZWQoW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFkZFBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gL2RlZXAvIGlzIGEgY29tYmluYXRvciB0aGF0IGlzIHZhbGlkIHdpdGhvdXQgYW55dGhpbmcgaW4gZnJvbnQgb2YgaXRcbiAgICAgICAgICAgIC8vIHNvIGlmIHRoZSAmIGRvZXMgbm90IGhhdmUgYSBjb21iaW5hdG9yIHRoYXQgaXMgXCJcIiBvciBcIiBcIiB0aGVuXG4gICAgICAgICAgICAvLyBhbmQgdGhlcmUgaXMgYSBjb21iaW5hdG9yIG9uIHRoZSBwYXJlbnQsIHRoZW4gZ3JhYiB0aGF0LlxuICAgICAgICAgICAgLy8gdGhpcyBhbHNvIGFsbG93cyArIGEgeyAmIC5iIHsgLmEgJiB7IC4uLiB0aG91Z2ggbm90IHN1cmUgd2h5IHlvdSB3b3VsZCB3YW50IHRvIGRvIHRoYXRcbiAgICAgICAgICAgIHZhciBjb21iaW5hdG9yID0gcmVwbGFjZWRFbGVtZW50LmNvbWJpbmF0b3IsIHBhcmVudEVsID0gYWRkUGF0aFswXS5lbGVtZW50c1swXTtcbiAgICAgICAgICAgIGlmIChjb21iaW5hdG9yLmVtcHR5T3JXaGl0ZXNwYWNlICYmICFwYXJlbnRFbC5jb21iaW5hdG9yLmVtcHR5T3JXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgY29tYmluYXRvciA9IHBhcmVudEVsLmNvbWJpbmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBqb2luIHRoZSBlbGVtZW50cyBzbyBmYXIgd2l0aCB0aGUgZmlyc3QgcGFydCBvZiB0aGUgcGFyZW50XG4gICAgICAgICAgICBuZXdKb2luZWRTZWxlY3Rvci5lbGVtZW50cy5wdXNoKG5ldyBFbGVtZW50KGNvbWJpbmF0b3IsIHBhcmVudEVsLnZhbHVlLCByZXBsYWNlZEVsZW1lbnQuaW5kZXgsIHJlcGxhY2VkRWxlbWVudC5jdXJyZW50RmlsZUluZm8pKTtcbiAgICAgICAgICAgIG5ld0pvaW5lZFNlbGVjdG9yLmVsZW1lbnRzID0gbmV3Sm9pbmVkU2VsZWN0b3IuZWxlbWVudHMuY29uY2F0KGFkZFBhdGhbMF0uZWxlbWVudHMuc2xpY2UoMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm93IGFkZCB0aGUgam9pbmVkIHNlbGVjdG9yIC0gYnV0IG9ubHkgaWYgaXQgaXMgbm90IGVtcHR5XG4gICAgICAgIGlmIChuZXdKb2luZWRTZWxlY3Rvci5lbGVtZW50cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIG5ld1NlbGVjdG9yUGF0aC5wdXNoKG5ld0pvaW5lZFNlbGVjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vcHV0IHRvZ2V0aGVyIHRoZSBwYXJlbnQgc2VsZWN0b3JzIGFmdGVyIHRoZSBqb2luIChlLmcuIHRoZSByZXN0IG9mIHRoZSBwYXJlbnQpXG4gICAgICAgIGlmIChhZGRQYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciByZXN0T2ZQYXRoID0gYWRkUGF0aC5zbGljZSgxKTtcbiAgICAgICAgICAgIHJlc3RPZlBhdGggPSByZXN0T2ZQYXRoLm1hcChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0b3IuY3JlYXRlRGVyaXZlZChzZWxlY3Rvci5lbGVtZW50cywgW10pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXdTZWxlY3RvclBhdGggPSBuZXdTZWxlY3RvclBhdGguY29uY2F0KHJlc3RPZlBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTZWxlY3RvclBhdGg7XG4gICAgfVxuXG4gICAgLy8gam9pbnMgc2VsZWN0b3IgcGF0aCBmcm9tIGBiZWdpbm5pbmdQYXRoYCB3aXRoIGV2ZXJ5IHNlbGVjdG9yIHBhdGggaW4gYGFkZFBhdGhzYCBhcnJheVxuICAgIC8vIGByZXBsYWNlZEVsZW1lbnRgIGNvbnRhaW5zIGVsZW1lbnQgdGhhdCBpcyBiZWluZyByZXBsYWNlZCBieSBgYWRkUGF0aGBcbiAgICAvLyByZXR1cm5zIGFycmF5IHdpdGggYWxsIGNvbmNhdGVuYXRlZCBwYXRoc1xuICAgIGZ1bmN0aW9uIGFkZEFsbFJlcGxhY2VtZW50c0ludG9QYXRoKCBiZWdpbm5pbmdQYXRoLCBhZGRQYXRocywgcmVwbGFjZWRFbGVtZW50LCBvcmlnaW5hbFNlbGVjdG9yLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIGo7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBiZWdpbm5pbmdQYXRoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgbmV3U2VsZWN0b3JQYXRoID0gYWRkUmVwbGFjZW1lbnRJbnRvUGF0aChiZWdpbm5pbmdQYXRoW2pdLCBhZGRQYXRocywgcmVwbGFjZWRFbGVtZW50LCBvcmlnaW5hbFNlbGVjdG9yKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld1NlbGVjdG9yUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUVsZW1lbnRzT25Ub1NlbGVjdG9ycyhlbGVtZW50cywgc2VsZWN0b3JzKSB7XG4gICAgICAgIHZhciBpLCBzZWw7XG5cbiAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc2VsZWN0b3JzLnB1c2goWyBuZXcgU2VsZWN0b3IoZWxlbWVudHMpIF0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VsID0gc2VsZWN0b3JzW2ldO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcHJldmlvdXMgdGhpbmcgaW4gc2VsIGlzIGEgcGFyZW50IHRoaXMgbmVlZHMgdG8gam9pbiBvbiB0byBpdFxuICAgICAgICAgICAgaWYgKHNlbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc2VsW3NlbC5sZW5ndGggLSAxXSA9IHNlbFtzZWwubGVuZ3RoIC0gMV0uY3JlYXRlRGVyaXZlZChzZWxbc2VsLmxlbmd0aCAtIDFdLmVsZW1lbnRzLmNvbmNhdChlbGVtZW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsLnB1c2gobmV3IFNlbGVjdG9yKGVsZW1lbnRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXBsYWNlIGFsbCBwYXJlbnQgc2VsZWN0b3JzIGluc2lkZSBgaW5TZWxlY3RvcmAgYnkgY29udGVudCBvZiBgY29udGV4dGAgYXJyYXlcbiAgICAvLyByZXN1bHRpbmcgc2VsZWN0b3JzIGFyZSByZXR1cm5lZCBpbnNpZGUgYHBhdGhzYCBhcnJheVxuICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBgaW5TZWxlY3RvcmAgY29udGFpbmVkIGF0IGxlYXN0IG9uZSBwYXJlbnQgc2VsZWN0b3JcbiAgICBmdW5jdGlvbiByZXBsYWNlUGFyZW50U2VsZWN0b3IocGF0aHMsIGNvbnRleHQsIGluU2VsZWN0b3IpIHtcbiAgICAgICAgLy8gVGhlIHBhdGhzIGFyZSBbW1NlbGVjdG9yXV1cbiAgICAgICAgLy8gVGhlIGZpcnN0IGxpc3QgaXMgYSBsaXN0IG9mIGNvbW1hIHNlcGFyYXRlZCBzZWxlY3RvcnNcbiAgICAgICAgLy8gVGhlIGlubmVyIGxpc3QgaXMgYSBsaXN0IG9mIGluaGVyaXRhbmNlIHNlcGFyYXRlZCBzZWxlY3RvcnNcbiAgICAgICAgLy8gZS5nLlxuICAgICAgICAvLyAuYSwgLmIge1xuICAgICAgICAvLyAgIC5jIHtcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gPT0gW1suYV0gWy5jXV0gW1suYl0gWy5jXV1cbiAgICAgICAgLy9cbiAgICAgICAgdmFyIGksIGosIGssIGN1cnJlbnRFbGVtZW50cywgbmV3U2VsZWN0b3JzLCBzZWxlY3RvcnNNdWx0aXBsaWVkLCBzZWwsIGVsLCBoYWRQYXJlbnRTZWxlY3RvciA9IGZhbHNlLCBsZW5ndGgsIGxhc3RTZWxlY3RvcjtcbiAgICAgICAgZnVuY3Rpb24gZmluZE5lc3RlZFNlbGVjdG9yKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBtYXliZVNlbGVjdG9yO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQudmFsdWUudHlwZSAhPT0gJ1BhcmVuJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXliZVNlbGVjdG9yID0gZWxlbWVudC52YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChtYXliZVNlbGVjdG9yLnR5cGUgIT09ICdTZWxlY3RvcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1heWJlU2VsZWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgZWxlbWVudHMgZnJvbSB0aGUgY3VycmVudCBzZWxlY3RvciBzbyBmYXJcbiAgICAgICAgY3VycmVudEVsZW1lbnRzID0gW107XG4gICAgICAgIC8vIHRoZSBjdXJyZW50IGxpc3Qgb2YgbmV3IHNlbGVjdG9ycyB0byBhZGQgdG8gdGhlIHBhdGguXG4gICAgICAgIC8vIFdlIHdpbGwgYnVpbGQgaXQgdXAuIFdlIGluaXRpYXRlIGl0IHdpdGggb25lIGVtcHR5IHNlbGVjdG9yIGFzIHdlIFwibXVsdGlwbHlcIiB0aGUgbmV3IHNlbGVjdG9yc1xuICAgICAgICAvLyBieSB0aGUgcGFyZW50c1xuICAgICAgICBuZXdTZWxlY3RvcnMgPSBbXG4gICAgICAgICAgICBbXVxuICAgICAgICBdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNlbGVjdG9yLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlbCA9IGluU2VsZWN0b3IuZWxlbWVudHNbaV07XG4gICAgICAgICAgICAvLyBub24gcGFyZW50IHJlZmVyZW5jZSBlbGVtZW50cyBqdXN0IGdldCBhZGRlZFxuICAgICAgICAgICAgaWYgKGVsLnZhbHVlICE9PSBcIiZcIikge1xuICAgICAgICAgICAgICAgIHZhciBuZXN0ZWRTZWxlY3RvciA9IGZpbmROZXN0ZWRTZWxlY3RvcihlbCk7XG4gICAgICAgICAgICAgICAgaWYgKG5lc3RlZFNlbGVjdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2UgdGhlIGN1cnJlbnQgbGlzdCBvZiBub24gcGFyZW50IHNlbGVjdG9yIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIHRvIHRoZSBjdXJyZW50IGxpc3Qgb2Ygc2VsZWN0b3JzIHRvIGFkZFxuICAgICAgICAgICAgICAgICAgICBtZXJnZUVsZW1lbnRzT25Ub1NlbGVjdG9ycyhjdXJyZW50RWxlbWVudHMsIG5ld1NlbGVjdG9ycyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5lc3RlZFBhdGhzID0gW10sIHJlcGxhY2VkLCByZXBsYWNlZE5ld1NlbGVjdG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlZCA9IHJlcGxhY2VQYXJlbnRTZWxlY3RvcihuZXN0ZWRQYXRocywgY29udGV4dCwgbmVzdGVkU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBoYWRQYXJlbnRTZWxlY3RvciA9IGhhZFBhcmVudFNlbGVjdG9yIHx8IHJlcGxhY2VkO1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXN0ZWRQYXRocyBhcnJheSBzaG91bGQgaGF2ZSBvbmx5IG9uZSBtZW1iZXIgLSByZXBsYWNlUGFyZW50U2VsZWN0b3IgZG9lcyBub3QgbXVsdGlwbHkgc2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBuZXN0ZWRQYXRocy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50U2VsZWN0b3IgPSBjcmVhdGVTZWxlY3RvcihjcmVhdGVQYXJlbnRoZXNpcyhuZXN0ZWRQYXRoc1trXSwgZWwpLCBlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRBbGxSZXBsYWNlbWVudHNJbnRvUGF0aChuZXdTZWxlY3RvcnMsIFtyZXBsYWNlbWVudFNlbGVjdG9yXSwgZWwsIGluU2VsZWN0b3IsIHJlcGxhY2VkTmV3U2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvcnMgPSByZXBsYWNlZE5ld1NlbGVjdG9ycztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEVsZW1lbnRzID0gW107XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhZFBhcmVudFNlbGVjdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyB0aGUgbmV3IGxpc3Qgb2Ygc2VsZWN0b3JzIHRvIGFkZFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yc011bHRpcGxpZWQgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIG1lcmdlIHRoZSBjdXJyZW50IGxpc3Qgb2Ygbm9uIHBhcmVudCBzZWxlY3RvciBlbGVtZW50c1xuICAgICAgICAgICAgICAgIC8vIG9uIHRvIHRoZSBjdXJyZW50IGxpc3Qgb2Ygc2VsZWN0b3JzIHRvIGFkZFxuICAgICAgICAgICAgICAgIG1lcmdlRWxlbWVudHNPblRvU2VsZWN0b3JzKGN1cnJlbnRFbGVtZW50cywgbmV3U2VsZWN0b3JzKTtcblxuICAgICAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBvdXIgY3VycmVudCBzZWxlY3RvcnNcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbmV3U2VsZWN0b3JzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbCA9IG5ld1NlbGVjdG9yc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgcGFyZW50IHBhdGhzLCB0aGUgJiBtaWdodCBiZSBpbiBhIG1peGluIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hldGhlciB0aGVyZSBhcmUgcGFyZW50cyBvciBub3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY29tYmluYXRvciB1c2VkIG9uIGVsIHNob3VsZCBub3cgYmUgYXBwbGllZCB0byB0aGUgbmV4dCBlbGVtZW50IGluc3RlYWQgc28gdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgaXMgbm90IGxvc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbFswXS5lbGVtZW50cy5wdXNoKG5ldyBFbGVtZW50KGVsLmNvbWJpbmF0b3IsICcnLCBlbC5pbmRleCwgZWwuY3VycmVudEZpbGVJbmZvKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnNNdWx0aXBsaWVkLnB1c2goc2VsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGUgcGFyZW50IHNlbGVjdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGNvbnRleHQubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHB1dCB0aGUgY3VycmVudCBzZWxlY3RvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGpvaW4gdGhlIGxhc3Qgc2VsZWN0b3IncyBlbGVtZW50cyBvbiB0byB0aGUgcGFyZW50cyBzZWxlY3RvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2VsZWN0b3JQYXRoID0gYWRkUmVwbGFjZW1lbnRJbnRvUGF0aChzZWwsIGNvbnRleHRba10sIGVsLCBpblNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhhdCB0byBvdXIgbmV3IHNldCBvZiBzZWxlY3RvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnNNdWx0aXBsaWVkLnB1c2gobmV3U2VsZWN0b3JQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG91ciBuZXcgc2VsZWN0b3JzIGhhcyBiZWVuIG11bHRpcGxpZWQsIHNvIHJlc2V0IHRoZSBzdGF0ZVxuICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9ycyA9IHNlbGVjdG9yc011bHRpcGxpZWQ7XG4gICAgICAgICAgICAgICAgY3VycmVudEVsZW1lbnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGFueSBlbGVtZW50cyBsZWZ0IG92ZXIgKGUuZy4gLmEmIC5iID09IC5iKVxuICAgICAgICAvLyBhZGQgdGhlbSBvbiB0byBhbGwgdGhlIGN1cnJlbnQgc2VsZWN0b3JzXG4gICAgICAgIG1lcmdlRWxlbWVudHNPblRvU2VsZWN0b3JzKGN1cnJlbnRFbGVtZW50cywgbmV3U2VsZWN0b3JzKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3U2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBuZXdTZWxlY3RvcnNbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKG5ld1NlbGVjdG9yc1tpXSk7XG4gICAgICAgICAgICAgICAgbGFzdFNlbGVjdG9yID0gbmV3U2VsZWN0b3JzW2ldW2xlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yc1tpXVtsZW5ndGggLSAxXSA9IGxhc3RTZWxlY3Rvci5jcmVhdGVEZXJpdmVkKGxhc3RTZWxlY3Rvci5lbGVtZW50cywgaW5TZWxlY3Rvci5leHRlbmRMaXN0KTtcbiAgICAgICAgICAgICAgICAvL25ld1NlbGVjdG9yc1tpXVtsZW5ndGggLSAxXS5jb3B5VmlzaWJpbGl0eUluZm8oaW5TZWxlY3Rvci52aXNpYmlsaXR5SW5mbygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYWRQYXJlbnRTZWxlY3RvcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXJpdmVTZWxlY3Rvcih2aXNpYmlsaXR5SW5mbywgZGVyaXZlRnJvbSkge1xuICAgICAgICB2YXIgbmV3U2VsZWN0b3IgPSBkZXJpdmVGcm9tLmNyZWF0ZURlcml2ZWQoZGVyaXZlRnJvbS5lbGVtZW50cywgZGVyaXZlRnJvbS5leHRlbmRMaXN0LCBkZXJpdmVGcm9tLmV2YWxkQ29uZGl0aW9uKTtcbiAgICAgICAgbmV3U2VsZWN0b3IuY29weVZpc2liaWxpdHlJbmZvKHZpc2liaWxpdHlJbmZvKTtcbiAgICAgICAgcmV0dXJuIG5ld1NlbGVjdG9yO1xuICAgIH1cblxuICAgIC8vIGpvaW5TZWxlY3RvciBjb2RlIGZvbGxvd3NcbiAgICB2YXIgaSwgbmV3UGF0aHMsIGhhZFBhcmVudFNlbGVjdG9yO1xuXG4gICAgbmV3UGF0aHMgPSBbXTtcbiAgICBoYWRQYXJlbnRTZWxlY3RvciA9IHJlcGxhY2VQYXJlbnRTZWxlY3RvcihuZXdQYXRocywgY29udGV4dCwgc2VsZWN0b3IpO1xuXG4gICAgaWYgKCFoYWRQYXJlbnRTZWxlY3Rvcikge1xuICAgICAgICBpZiAoY29udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBuZXdQYXRocyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbnRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvL3ZhciBjb25jYXRlbmF0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAvL2NvbnRleHRbaV0uZm9yRWFjaChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgIC8vICAgIHZhciBuZXdFbnRyeSA9IGVudHJ5LmNyZWF0ZURlcml2ZWQoZW50cnkuZWxlbWVudHMsIGVudHJ5LmV4dGVuZExpc3QsIGVudHJ5LmV2YWxkQ29uZGl0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyAgICBuZXdFbnRyeS5jb3B5VmlzaWJpbGl0eUluZm8oc2VsZWN0b3IudmlzaWJpbGl0eUluZm8oKSk7XG4gICAgICAgICAgICAgICAgLy8gICAgY29uY2F0ZW5hdGVkLnB1c2gobmV3RW50cnkpO1xuICAgICAgICAgICAgICAgIC8vfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmNhdGVuYXRlZCA9IGNvbnRleHRbaV0ubWFwKGRlcml2ZVNlbGVjdG9yLmJpbmQodGhpcywgc2VsZWN0b3IudmlzaWJpbGl0eUluZm8oKSkpO1xuXG4gICAgICAgICAgICAgICAgY29uY2F0ZW5hdGVkLnB1c2goc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIG5ld1BhdGhzLnB1c2goY29uY2F0ZW5hdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1BhdGhzID0gW1tzZWxlY3Rvcl1dO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG5ld1BhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhdGhzLnB1c2gobmV3UGF0aHNbaV0pO1xuICAgIH1cblxufTtcbm1vZHVsZS5leHBvcnRzID0gUnVsZXNldDtcblxufSx7XCIuLi9jb250ZXh0c1wiOjExLFwiLi4vZnVuY3Rpb25zL2RlZmF1bHRcIjoyMCxcIi4uL2Z1bmN0aW9ucy9mdW5jdGlvbi1yZWdpc3RyeVwiOjIyLFwiLi9kZWJ1Zy1pbmZvXCI6NTQsXCIuL2VsZW1lbnRcIjo1OCxcIi4vbm9kZVwiOjcwLFwiLi9wYXJlblwiOjcyLFwiLi9ydWxlXCI6NzQsXCIuL3NlbGVjdG9yXCI6Nzd9XSw3NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIiksXG4gICAgRWxlbWVudCA9IHJlcXVpcmUoXCIuL2VsZW1lbnRcIik7XG5cbnZhciBTZWxlY3RvciA9IGZ1bmN0aW9uIChlbGVtZW50cywgZXh0ZW5kTGlzdCwgY29uZGl0aW9uLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCB2aXNpYmlsaXR5SW5mbykge1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB0aGlzLmV4dGVuZExpc3QgPSBleHRlbmRMaXN0O1xuICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgIHRoaXMuY3VycmVudEZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvIHx8IHt9O1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuZXZhbGRDb25kaXRpb24gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XG59O1xuU2VsZWN0b3IucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblNlbGVjdG9yLnByb3RvdHlwZS50eXBlID0gXCJTZWxlY3RvclwiO1xuU2VsZWN0b3IucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLmVsZW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZXh0ZW5kTGlzdCkge1xuICAgICAgICB0aGlzLmV4dGVuZExpc3QgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy5leHRlbmRMaXN0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gdmlzaXRvci52aXNpdCh0aGlzLmNvbmRpdGlvbik7XG4gICAgfVxufTtcblNlbGVjdG9yLnByb3RvdHlwZS5jcmVhdGVEZXJpdmVkID0gZnVuY3Rpb24oZWxlbWVudHMsIGV4dGVuZExpc3QsIGV2YWxkQ29uZGl0aW9uKSB7XG4gICAgdmFyIGluZm8gPSB0aGlzLnZpc2liaWxpdHlJbmZvKCk7XG4gICAgZXZhbGRDb25kaXRpb24gPSAoZXZhbGRDb25kaXRpb24gIT0gbnVsbCkgPyBldmFsZENvbmRpdGlvbiA6IHRoaXMuZXZhbGRDb25kaXRpb247XG4gICAgdmFyIG5ld1NlbGVjdG9yID0gbmV3IFNlbGVjdG9yKGVsZW1lbnRzLCBleHRlbmRMaXN0IHx8IHRoaXMuZXh0ZW5kTGlzdCwgbnVsbCwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8sIGluZm8pO1xuICAgIG5ld1NlbGVjdG9yLmV2YWxkQ29uZGl0aW9uID0gZXZhbGRDb25kaXRpb247XG4gICAgbmV3U2VsZWN0b3IubWVkaWFFbXB0eSA9IHRoaXMubWVkaWFFbXB0eTtcbiAgICByZXR1cm4gbmV3U2VsZWN0b3I7XG59O1xuU2VsZWN0b3IucHJvdG90eXBlLmNyZWF0ZUVtcHR5U2VsZWN0b3JzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVsID0gbmV3IEVsZW1lbnQoJycsICcmJywgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pLFxuICAgICAgICBzZWxzID0gW25ldyBTZWxlY3RvcihbZWxdLCBudWxsLCBudWxsLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbyldO1xuICAgIHNlbHNbMF0ubWVkaWFFbXB0eSA9IHRydWU7XG4gICAgcmV0dXJuIHNlbHM7XG59O1xuU2VsZWN0b3IucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cyxcbiAgICAgICAgbGVuID0gZWxlbWVudHMubGVuZ3RoLFxuICAgICAgICBvbGVuLCBpO1xuXG4gICAgb3RoZXIuQ2FjaGVFbGVtZW50cygpO1xuXG4gICAgb2xlbiA9IG90aGVyLl9lbGVtZW50cy5sZW5ndGg7XG4gICAgaWYgKG9sZW4gPT09IDAgfHwgbGVuIDwgb2xlbikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2xlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHNbaV0udmFsdWUgIT09IG90aGVyLl9lbGVtZW50c1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9sZW47IC8vIHJldHVybiBudW1iZXIgb2YgbWF0Y2hlZCBlbGVtZW50c1xufTtcblNlbGVjdG9yLnByb3RvdHlwZS5DYWNoZUVsZW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLm1hcCggZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdi5jb21iaW5hdG9yLnZhbHVlICsgKHYudmFsdWUudmFsdWUgfHwgdi52YWx1ZSk7XG4gICAgfSkuam9pbihcIlwiKS5tYXRjaCgvWywmI1xcKlxcLlxcdy1dKFtcXHctXXwoXFxcXC4pKSovZyk7XG5cbiAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzWzBdID09PSBcIiZcIikge1xuICAgICAgICAgICAgZWxlbWVudHMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnRzID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudHMgPSBlbGVtZW50cztcbn07XG5TZWxlY3Rvci5wcm90b3R5cGUuaXNKdXN0UGFyZW50U2VsZWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMubWVkaWFFbXB0eSAmJlxuICAgICAgICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICB0aGlzLmVsZW1lbnRzWzBdLnZhbHVlID09PSAnJicgJiZcbiAgICAgICAgKHRoaXMuZWxlbWVudHNbMF0uY29tYmluYXRvci52YWx1ZSA9PT0gJyAnIHx8IHRoaXMuZWxlbWVudHNbMF0uY29tYmluYXRvci52YWx1ZSA9PT0gJycpO1xufTtcblNlbGVjdG9yLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgZXZhbGRDb25kaXRpb24gPSB0aGlzLmNvbmRpdGlvbiAmJiB0aGlzLmNvbmRpdGlvbi5ldmFsKGNvbnRleHQpLFxuICAgICAgICBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMsIGV4dGVuZExpc3QgPSB0aGlzLmV4dGVuZExpc3Q7XG5cbiAgICBlbGVtZW50cyA9IGVsZW1lbnRzICYmIGVsZW1lbnRzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5ldmFsKGNvbnRleHQpOyB9KTtcbiAgICBleHRlbmRMaXN0ID0gZXh0ZW5kTGlzdCAmJiBleHRlbmRMaXN0Lm1hcChmdW5jdGlvbihleHRlbmQpIHsgcmV0dXJuIGV4dGVuZC5ldmFsKGNvbnRleHQpOyB9KTtcblxuICAgIHJldHVybiB0aGlzLmNyZWF0ZURlcml2ZWQoZWxlbWVudHMsIGV4dGVuZExpc3QsIGV2YWxkQ29uZGl0aW9uKTtcbn07XG5TZWxlY3Rvci5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIHZhciBpLCBlbGVtZW50O1xuICAgIGlmICgoIWNvbnRleHQgfHwgIWNvbnRleHQuZmlyc3RTZWxlY3RvcikgJiYgdGhpcy5lbGVtZW50c1swXS5jb21iaW5hdG9yLnZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgIG91dHB1dC5hZGQoJyAnLCB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fY3NzKSB7XG4gICAgICAgIC8vVE9ETyBjYWNoaW5nPyBzcGVlZCBjb21wYXJpc29uP1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbaV07XG4gICAgICAgICAgICBlbGVtZW50LmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblNlbGVjdG9yLnByb3RvdHlwZS5nZXRJc091dHB1dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmV2YWxkQ29uZGl0aW9uO1xufTtcbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0b3I7XG5cbn0se1wiLi9lbGVtZW50XCI6NTgsXCIuL25vZGVcIjo3MH1dLDc4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKTtcblxudmFyIFVuaWNvZGVEZXNjcmlwdG9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufTtcblVuaWNvZGVEZXNjcmlwdG9yLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5Vbmljb2RlRGVzY3JpcHRvci5wcm90b3R5cGUudHlwZSA9IFwiVW5pY29kZURlc2NyaXB0b3JcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBVbmljb2RlRGVzY3JpcHRvcjtcblxufSx7XCIuL25vZGVcIjo3MH1dLDc5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICB1bml0Q29udmVyc2lvbnMgPSByZXF1aXJlKFwiLi4vZGF0YS91bml0LWNvbnZlcnNpb25zXCIpO1xuXG52YXIgVW5pdCA9IGZ1bmN0aW9uIChudW1lcmF0b3IsIGRlbm9taW5hdG9yLCBiYWNrdXBVbml0KSB7XG4gICAgdGhpcy5udW1lcmF0b3IgPSBudW1lcmF0b3IgPyBudW1lcmF0b3Iuc2xpY2UoMCkuc29ydCgpIDogW107XG4gICAgdGhpcy5kZW5vbWluYXRvciA9IGRlbm9taW5hdG9yID8gZGVub21pbmF0b3Iuc2xpY2UoMCkuc29ydCgpIDogW107XG4gICAgaWYgKGJhY2t1cFVuaXQpIHtcbiAgICAgICAgdGhpcy5iYWNrdXBVbml0ID0gYmFja3VwVW5pdDtcbiAgICB9IGVsc2UgaWYgKG51bWVyYXRvciAmJiBudW1lcmF0b3IubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYmFja3VwVW5pdCA9IG51bWVyYXRvclswXTtcbiAgICB9XG59O1xuXG5Vbml0LnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5Vbml0LnByb3RvdHlwZS50eXBlID0gXCJVbml0XCI7XG5Vbml0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFVuaXQodGhpcy5udW1lcmF0b3Iuc2xpY2UoMCksIHRoaXMuZGVub21pbmF0b3Iuc2xpY2UoMCksIHRoaXMuYmFja3VwVW5pdCk7XG59O1xuVW5pdC5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIC8vIERpbWVuc2lvbiBjaGVja3MgdGhlIHVuaXQgaXMgc2luZ3VsYXIgYW5kIHRocm93cyBhbiBlcnJvciBpZiBpbiBzdHJpY3QgbWF0aCBtb2RlLlxuICAgIHZhciBzdHJpY3RVbml0cyA9IGNvbnRleHQgJiYgY29udGV4dC5zdHJpY3RVbml0cztcbiAgICBpZiAodGhpcy5udW1lcmF0b3IubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG91dHB1dC5hZGQodGhpcy5udW1lcmF0b3JbMF0pOyAvLyB0aGUgaWRlYWwgc2l0dWF0aW9uXG4gICAgfSBlbHNlIGlmICghc3RyaWN0VW5pdHMgJiYgdGhpcy5iYWNrdXBVbml0KSB7XG4gICAgICAgIG91dHB1dC5hZGQodGhpcy5iYWNrdXBVbml0KTtcbiAgICB9IGVsc2UgaWYgKCFzdHJpY3RVbml0cyAmJiB0aGlzLmRlbm9taW5hdG9yLmxlbmd0aCkge1xuICAgICAgICBvdXRwdXQuYWRkKHRoaXMuZGVub21pbmF0b3JbMF0pO1xuICAgIH1cbn07XG5Vbml0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSwgcmV0dXJuU3RyID0gdGhpcy5udW1lcmF0b3Iuam9pbihcIipcIik7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGVub21pbmF0b3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmV0dXJuU3RyICs9IFwiL1wiICsgdGhpcy5kZW5vbWluYXRvcltpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblN0cjtcbn07XG5Vbml0LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuaXMob3RoZXIudG9TdHJpbmcoKSkgPyAwIDogdW5kZWZpbmVkO1xufTtcblVuaXQucHJvdG90eXBlLmlzID0gZnVuY3Rpb24gKHVuaXRTdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpLnRvVXBwZXJDYXNlKCkgPT09IHVuaXRTdHJpbmcudG9VcHBlckNhc2UoKTtcbn07XG5Vbml0LnByb3RvdHlwZS5pc0xlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLnRvQ1NTKCkubWF0Y2goL3B4fGVtfCV8aW58Y218bW18cGN8cHR8ZXgvKSk7XG59O1xuVW5pdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5udW1lcmF0b3IubGVuZ3RoID09PSAwICYmIHRoaXMuZGVub21pbmF0b3IubGVuZ3RoID09PSAwO1xufTtcblVuaXQucHJvdG90eXBlLmlzU2luZ3VsYXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5udW1lcmF0b3IubGVuZ3RoIDw9IDEgJiYgdGhpcy5kZW5vbWluYXRvci5sZW5ndGggPT09IDA7XG59O1xuVW5pdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm51bWVyYXRvci5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLm51bWVyYXRvcltpXSA9IGNhbGxiYWNrKHRoaXMubnVtZXJhdG9yW2ldLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGVub21pbmF0b3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5kZW5vbWluYXRvcltpXSA9IGNhbGxiYWNrKHRoaXMuZGVub21pbmF0b3JbaV0sIHRydWUpO1xuICAgIH1cbn07XG5Vbml0LnByb3RvdHlwZS51c2VkVW5pdHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ3JvdXAsIHJlc3VsdCA9IHt9LCBtYXBVbml0LCBncm91cE5hbWU7XG5cbiAgICBtYXBVbml0ID0gZnVuY3Rpb24gKGF0b21pY1VuaXQpIHtcbiAgICAgICAgLypqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSAqL1xuICAgICAgICBpZiAoZ3JvdXAuaGFzT3duUHJvcGVydHkoYXRvbWljVW5pdCkgJiYgIXJlc3VsdFtncm91cE5hbWVdKSB7XG4gICAgICAgICAgICByZXN1bHRbZ3JvdXBOYW1lXSA9IGF0b21pY1VuaXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXRvbWljVW5pdDtcbiAgICB9O1xuXG4gICAgZm9yIChncm91cE5hbWUgaW4gdW5pdENvbnZlcnNpb25zKSB7XG4gICAgICAgIGlmICh1bml0Q29udmVyc2lvbnMuaGFzT3duUHJvcGVydHkoZ3JvdXBOYW1lKSkge1xuICAgICAgICAgICAgZ3JvdXAgPSB1bml0Q29udmVyc2lvbnNbZ3JvdXBOYW1lXTtcblxuICAgICAgICAgICAgdGhpcy5tYXAobWFwVW5pdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblVuaXQucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY291bnRlciA9IHt9LCBhdG9taWNVbml0LCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubnVtZXJhdG9yLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGF0b21pY1VuaXQgPSB0aGlzLm51bWVyYXRvcltpXTtcbiAgICAgICAgY291bnRlclthdG9taWNVbml0XSA9IChjb3VudGVyW2F0b21pY1VuaXRdIHx8IDApICsgMTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kZW5vbWluYXRvci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhdG9taWNVbml0ID0gdGhpcy5kZW5vbWluYXRvcltpXTtcbiAgICAgICAgY291bnRlclthdG9taWNVbml0XSA9IChjb3VudGVyW2F0b21pY1VuaXRdIHx8IDApIC0gMTtcbiAgICB9XG5cbiAgICB0aGlzLm51bWVyYXRvciA9IFtdO1xuICAgIHRoaXMuZGVub21pbmF0b3IgPSBbXTtcblxuICAgIGZvciAoYXRvbWljVW5pdCBpbiBjb3VudGVyKSB7XG4gICAgICAgIGlmIChjb3VudGVyLmhhc093blByb3BlcnR5KGF0b21pY1VuaXQpKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBjb3VudGVyW2F0b21pY1VuaXRdO1xuXG4gICAgICAgICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5udW1lcmF0b3IucHVzaChhdG9taWNVbml0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAtY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbm9taW5hdG9yLnB1c2goYXRvbWljVW5pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5udW1lcmF0b3Iuc29ydCgpO1xuICAgIHRoaXMuZGVub21pbmF0b3Iuc29ydCgpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gVW5pdDtcblxufSx7XCIuLi9kYXRhL3VuaXQtY29udmVyc2lvbnNcIjoxNCxcIi4vbm9kZVwiOjcwfV0sODA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuXG52YXIgVVJMID0gZnVuY3Rpb24gKHZhbCwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgaXNFdmFsZCkge1xuICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgdGhpcy5jdXJyZW50RmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuaXNFdmFsZCA9IGlzRXZhbGQ7XG59O1xuVVJMLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5VUkwucHJvdG90eXBlLnR5cGUgPSBcIlVybFwiO1xuVVJMLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgIHRoaXMudmFsdWUgPSB2aXNpdG9yLnZpc2l0KHRoaXMudmFsdWUpO1xufTtcblVSTC5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIG91dHB1dC5hZGQoXCJ1cmwoXCIpO1xuICAgIHRoaXMudmFsdWUuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgb3V0cHV0LmFkZChcIilcIik7XG59O1xuVVJMLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgdmFsID0gdGhpcy52YWx1ZS5ldmFsKGNvbnRleHQpLFxuICAgICAgICByb290cGF0aDtcblxuICAgIGlmICghdGhpcy5pc0V2YWxkKSB7XG4gICAgICAgIC8vIEFkZCB0aGUgYmFzZSBwYXRoIGlmIHRoZSBVUkwgaXMgcmVsYXRpdmVcbiAgICAgICAgcm9vdHBhdGggPSB0aGlzLmN1cnJlbnRGaWxlSW5mbyAmJiB0aGlzLmN1cnJlbnRGaWxlSW5mby5yb290cGF0aDtcbiAgICAgICAgaWYgKHJvb3RwYXRoICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsLnZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICBjb250ZXh0LmlzUGF0aFJlbGF0aXZlKHZhbC52YWx1ZSkpIHtcblxuICAgICAgICAgICAgaWYgKCF2YWwucXVvdGUpIHtcbiAgICAgICAgICAgICAgICByb290cGF0aCA9IHJvb3RwYXRoLnJlcGxhY2UoL1tcXChcXCknXCJcXHNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7IHJldHVybiBcIlxcXFxcIiArIG1hdGNoOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbC52YWx1ZSA9IHJvb3RwYXRoICsgdmFsLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsLnZhbHVlID0gY29udGV4dC5ub3JtYWxpemVQYXRoKHZhbC52YWx1ZSk7XG5cbiAgICAgICAgLy8gQWRkIHVybCBhcmdzIGlmIGVuYWJsZWRcbiAgICAgICAgaWYgKGNvbnRleHQudXJsQXJncykge1xuICAgICAgICAgICAgaWYgKCF2YWwudmFsdWUubWF0Y2goL15cXHMqZGF0YTovKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWxpbWl0ZXIgPSB2YWwudmFsdWUuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJztcbiAgICAgICAgICAgICAgICB2YXIgdXJsQXJncyA9IGRlbGltaXRlciArIGNvbnRleHQudXJsQXJncztcbiAgICAgICAgICAgICAgICBpZiAodmFsLnZhbHVlLmluZGV4T2YoJyMnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsLnZhbHVlID0gdmFsLnZhbHVlLnJlcGxhY2UoJyMnLCB1cmxBcmdzICsgJyMnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWwudmFsdWUgKz0gdXJsQXJncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFVSTCh2YWwsIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvLCB0cnVlKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFVSTDtcblxufSx7XCIuL25vZGVcIjo3MH1dLDgxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKTtcblxudmFyIFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgcmVxdWlyZXMgYW4gYXJyYXkgYXJndW1lbnRcIik7XG4gICAgfVxufTtcblZhbHVlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5WYWx1ZS5wcm90b3R5cGUudHlwZSA9IFwiVmFsdWVcIjtcblZhbHVlLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy52YWx1ZSk7XG4gICAgfVxufTtcblZhbHVlLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVbMF0uZXZhbChjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKHRoaXMudmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdi5ldmFsKGNvbnRleHQpO1xuICAgICAgICB9KSk7XG4gICAgfVxufTtcblZhbHVlLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy52YWx1ZVtpXS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICAgICAgaWYgKGkgKyAxIDwgdGhpcy52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dHB1dC5hZGQoKGNvbnRleHQgJiYgY29udGV4dC5jb21wcmVzcykgPyAnLCcgOiAnLCAnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFZhbHVlO1xuXG59LHtcIi4vbm9kZVwiOjcwfV0sODI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuXG52YXIgVmFyaWFibGUgPSBmdW5jdGlvbiAobmFtZSwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY3VycmVudEZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvIHx8IHt9O1xufTtcblZhcmlhYmxlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5WYXJpYWJsZS5wcm90b3R5cGUudHlwZSA9IFwiVmFyaWFibGVcIjtcblZhcmlhYmxlLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgdmFyaWFibGUsIG5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICBpZiAobmFtZS5pbmRleE9mKCdAQCcpID09PSAwKSB7XG4gICAgICAgIG5hbWUgPSAnQCcgKyBuZXcgVmFyaWFibGUobmFtZS5zbGljZSgxKSwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pLmV2YWwoY29udGV4dCkudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXZhbHVhdGluZykge1xuICAgICAgICB0aHJvdyB7IHR5cGU6ICdOYW1lJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlJlY3Vyc2l2ZSB2YXJpYWJsZSBkZWZpbml0aW9uIGZvciBcIiArIG5hbWUsXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuY3VycmVudEZpbGVJbmZvLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4IH07XG4gICAgfVxuXG4gICAgdGhpcy5ldmFsdWF0aW5nID0gdHJ1ZTtcblxuICAgIHZhcmlhYmxlID0gdGhpcy5maW5kKGNvbnRleHQuZnJhbWVzLCBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgdmFyIHYgPSBmcmFtZS52YXJpYWJsZShuYW1lKTtcbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIGlmICh2LmltcG9ydGFudCkge1xuICAgICAgICAgICAgICAgIHZhciBpbXBvcnRhbnRTY29wZSA9IGNvbnRleHQuaW1wb3J0YW50U2NvcGVbY29udGV4dC5pbXBvcnRhbnRTY29wZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpbXBvcnRhbnRTY29wZS5pbXBvcnRhbnQgPSB2LmltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2LnZhbHVlLmV2YWwoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodmFyaWFibGUpIHtcbiAgICAgICAgdGhpcy5ldmFsdWF0aW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB2YXJpYWJsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB7IHR5cGU6ICdOYW1lJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcInZhcmlhYmxlIFwiICsgbmFtZSArIFwiIGlzIHVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmN1cnJlbnRGaWxlSW5mby5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCB9O1xuICAgIH1cbn07XG5WYXJpYWJsZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChvYmosIGZ1bikge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHIgPSBmdW4uY2FsbChvYmosIG9ialtpXSk7XG4gICAgICAgIGlmIChyKSB7IHJldHVybiByOyB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbm1vZHVsZS5leHBvcnRzID0gVmFyaWFibGU7XG5cbn0se1wiLi9ub2RlXCI6NzB9XSw4MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRMb2NhdGlvbjogZnVuY3Rpb24oaW5kZXgsIGlucHV0U3RyZWFtKSB7XG4gICAgICAgIHZhciBuID0gaW5kZXggKyAxLFxuICAgICAgICAgICAgbGluZSA9IG51bGwsXG4gICAgICAgICAgICBjb2x1bW4gPSAtMTtcblxuICAgICAgICB3aGlsZSAoLS1uID49IDAgJiYgaW5wdXRTdHJlYW0uY2hhckF0KG4pICE9PSAnXFxuJykge1xuICAgICAgICAgICAgY29sdW1uKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgbGluZSA9IChpbnB1dFN0cmVhbS5zbGljZSgwLCBpbmRleCkubWF0Y2goL1xcbi9nKSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgICAgIH07XG4gICAgfVxufTtcblxufSx7fV0sODQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHRyZWUgPSByZXF1aXJlKFwiLi4vdHJlZVwiKSxcbiAgICBWaXNpdG9yID0gcmVxdWlyZShcIi4vdmlzaXRvclwiKSxcbiAgICBsb2dnZXIgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xuXG4vKmpzaGludCBsb29wZnVuYzp0cnVlICovXG5cbnZhciBFeHRlbmRGaW5kZXJWaXNpdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdmlzaXRvciA9IG5ldyBWaXNpdG9yKHRoaXMpO1xuICAgIHRoaXMuY29udGV4dHMgPSBbXTtcbiAgICB0aGlzLmFsbEV4dGVuZHNTdGFjayA9IFtbXV07XG59O1xuXG5FeHRlbmRGaW5kZXJWaXNpdG9yLnByb3RvdHlwZSA9IHtcbiAgICBydW46IGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgIHJvb3QgPSB0aGlzLl92aXNpdG9yLnZpc2l0KHJvb3QpO1xuICAgICAgICByb290LmFsbEV4dGVuZHMgPSB0aGlzLmFsbEV4dGVuZHNTdGFja1swXTtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfSxcbiAgICB2aXNpdFJ1bGU6IGZ1bmN0aW9uIChydWxlTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xuICAgIH0sXG4gICAgdmlzaXRNaXhpbkRlZmluaXRpb246IGZ1bmN0aW9uIChtaXhpbkRlZmluaXRpb25Ob2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gZmFsc2U7XG4gICAgfSxcbiAgICB2aXNpdFJ1bGVzZXQ6IGZ1bmN0aW9uIChydWxlc2V0Tm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIGlmIChydWxlc2V0Tm9kZS5yb290KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSwgaiwgZXh0ZW5kLCBhbGxTZWxlY3RvcnNFeHRlbmRMaXN0ID0gW10sIGV4dGVuZExpc3Q7XG5cbiAgICAgICAgLy8gZ2V0ICY6ZXh0ZW5kKC5hKTsgcnVsZXMgd2hpY2ggYXBwbHkgdG8gYWxsIHNlbGVjdG9ycyBpbiB0aGlzIHJ1bGVzZXRcbiAgICAgICAgdmFyIHJ1bGVzID0gcnVsZXNldE5vZGUucnVsZXMsIHJ1bGVDbnQgPSBydWxlcyA/IHJ1bGVzLmxlbmd0aCA6IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBydWxlQ250OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChydWxlc2V0Tm9kZS5ydWxlc1tpXSBpbnN0YW5jZW9mIHRyZWUuRXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgYWxsU2VsZWN0b3JzRXh0ZW5kTGlzdC5wdXNoKHJ1bGVzW2ldKTtcbiAgICAgICAgICAgICAgICBydWxlc2V0Tm9kZS5leHRlbmRPbkV2ZXJ5UGF0aCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3cgZmluZCBldmVyeSBzZWxlY3RvciBhbmQgYXBwbHkgdGhlIGV4dGVuZHMgdGhhdCBhcHBseSB0byBhbGwgZXh0ZW5kc1xuICAgICAgICAvLyBhbmQgdGhlIG9uZXMgd2hpY2ggYXBwbHkgdG8gYW4gaW5kaXZpZHVhbCBleHRlbmRcbiAgICAgICAgdmFyIHBhdGhzID0gcnVsZXNldE5vZGUucGF0aHM7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yUGF0aCA9IHBhdGhzW2ldLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3JQYXRoW3NlbGVjdG9yUGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICBzZWxFeHRlbmRMaXN0ID0gc2VsZWN0b3IuZXh0ZW5kTGlzdDtcblxuICAgICAgICAgICAgZXh0ZW5kTGlzdCA9IHNlbEV4dGVuZExpc3QgPyBzZWxFeHRlbmRMaXN0LnNsaWNlKDApLmNvbmNhdChhbGxTZWxlY3RvcnNFeHRlbmRMaXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhbGxTZWxlY3RvcnNFeHRlbmRMaXN0O1xuXG4gICAgICAgICAgICBpZiAoZXh0ZW5kTGlzdCkge1xuICAgICAgICAgICAgICAgIGV4dGVuZExpc3QgPSBleHRlbmRMaXN0Lm1hcChmdW5jdGlvbihhbGxTZWxlY3RvcnNFeHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbFNlbGVjdG9yc0V4dGVuZC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZXh0ZW5kTGlzdC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZm91bmRFeHRlbmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBleHRlbmQgPSBleHRlbmRMaXN0W2pdO1xuICAgICAgICAgICAgICAgIGV4dGVuZC5maW5kU2VsZlNlbGVjdG9ycyhzZWxlY3RvclBhdGgpO1xuICAgICAgICAgICAgICAgIGV4dGVuZC5ydWxlc2V0ID0gcnVsZXNldE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDApIHsgZXh0ZW5kLmZpcnN0RXh0ZW5kT25UaGlzU2VsZWN0b3JQYXRoID0gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrW3RoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCAtIDFdLnB1c2goZXh0ZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29udGV4dHMucHVzaChydWxlc2V0Tm9kZS5zZWxlY3RvcnMpO1xuICAgIH0sXG4gICAgdmlzaXRSdWxlc2V0T3V0OiBmdW5jdGlvbiAocnVsZXNldE5vZGUpIHtcbiAgICAgICAgaWYgKCFydWxlc2V0Tm9kZS5yb290KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzLmxlbmd0aCA9IHRoaXMuY29udGV4dHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdmlzaXRNZWRpYTogZnVuY3Rpb24gKG1lZGlhTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIG1lZGlhTm9kZS5hbGxFeHRlbmRzID0gW107XG4gICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrLnB1c2gobWVkaWFOb2RlLmFsbEV4dGVuZHMpO1xuICAgIH0sXG4gICAgdmlzaXRNZWRpYU91dDogZnVuY3Rpb24gKG1lZGlhTm9kZSkge1xuICAgICAgICB0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggPSB0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggLSAxO1xuICAgIH0sXG4gICAgdmlzaXREaXJlY3RpdmU6IGZ1bmN0aW9uIChkaXJlY3RpdmVOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgZGlyZWN0aXZlTm9kZS5hbGxFeHRlbmRzID0gW107XG4gICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrLnB1c2goZGlyZWN0aXZlTm9kZS5hbGxFeHRlbmRzKTtcbiAgICB9LFxuICAgIHZpc2l0RGlyZWN0aXZlT3V0OiBmdW5jdGlvbiAoZGlyZWN0aXZlTm9kZSkge1xuICAgICAgICB0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggPSB0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggLSAxO1xuICAgIH1cbn07XG5cbnZhciBQcm9jZXNzRXh0ZW5kc1Zpc2l0b3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl92aXNpdG9yID0gbmV3IFZpc2l0b3IodGhpcyk7XG59O1xuXG5Qcm9jZXNzRXh0ZW5kc1Zpc2l0b3IucHJvdG90eXBlID0ge1xuICAgIHJ1bjogZnVuY3Rpb24ocm9vdCkge1xuICAgICAgICB2YXIgZXh0ZW5kRmluZGVyID0gbmV3IEV4dGVuZEZpbmRlclZpc2l0b3IoKTtcbiAgICAgICAgdGhpcy5leHRlbmRJbmRpY2VzID0ge307XG4gICAgICAgIGV4dGVuZEZpbmRlci5ydW4ocm9vdCk7XG4gICAgICAgIGlmICghZXh0ZW5kRmluZGVyLmZvdW5kRXh0ZW5kcykgeyByZXR1cm4gcm9vdDsgfVxuICAgICAgICByb290LmFsbEV4dGVuZHMgPSByb290LmFsbEV4dGVuZHMuY29uY2F0KHRoaXMuZG9FeHRlbmRDaGFpbmluZyhyb290LmFsbEV4dGVuZHMsIHJvb3QuYWxsRXh0ZW5kcykpO1xuICAgICAgICB0aGlzLmFsbEV4dGVuZHNTdGFjayA9IFtyb290LmFsbEV4dGVuZHNdO1xuICAgICAgICB2YXIgbmV3Um9vdCA9IHRoaXMuX3Zpc2l0b3IudmlzaXQocm9vdCk7XG4gICAgICAgIHRoaXMuY2hlY2tFeHRlbmRzRm9yTm9uTWF0Y2hlZChyb290LmFsbEV4dGVuZHMpO1xuICAgICAgICByZXR1cm4gbmV3Um9vdDtcbiAgICB9LFxuICAgIGNoZWNrRXh0ZW5kc0Zvck5vbk1hdGNoZWQ6IGZ1bmN0aW9uKGV4dGVuZExpc3QpIHtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmV4dGVuZEluZGljZXM7XG4gICAgICAgIGV4dGVuZExpc3QuZmlsdGVyKGZ1bmN0aW9uKGV4dGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuICFleHRlbmQuaGFzRm91bmRNYXRjaGVzICYmIGV4dGVuZC5wYXJlbnRfaWRzLmxlbmd0aCA9PSAxO1xuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGV4dGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IFwiX3Vua25vd25fXCI7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBleHRlbmQuc2VsZWN0b3IudG9DU1Moe30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaChfKSB7fVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpbmRpY2VzW2V4dGVuZC5pbmRleCArICcgJyArIHNlbGVjdG9yXSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzW2V4dGVuZC5pbmRleCArICcgJyArIHNlbGVjdG9yXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiZXh0ZW5kICdcIiArIHNlbGVjdG9yICsgXCInIGhhcyBubyBtYXRjaGVzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG4gICAgZG9FeHRlbmRDaGFpbmluZzogZnVuY3Rpb24gKGV4dGVuZHNMaXN0LCBleHRlbmRzTGlzdFRhcmdldCwgaXRlcmF0aW9uQ291bnQpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY2hhaW5pbmcgaXMgZGlmZmVyZW50IGZyb20gbm9ybWFsIGV4dGVuc2lvbi4uIGlmIHdlIGV4dGVuZCBhbiBleHRlbmQgdGhlbiB3ZSBhcmUgbm90IGp1c3QgY29weWluZywgYWx0ZXJpbmdcbiAgICAgICAgLy8gYW5kIHBhc3RpbmcgdGhlIHNlbGVjdG9yIHdlIHdvdWxkIGRvIG5vcm1hbGx5LCBidXQgd2UgYXJlIGFsc28gYWRkaW5nIGFuIGV4dGVuZCB3aXRoIHRoZSBzYW1lIHRhcmdldCBzZWxlY3RvclxuICAgICAgICAvLyB0aGlzIG1lYW5zIHRoaXMgbmV3IGV4dGVuZCBjYW4gdGhlbiBnbyBhbmQgYWx0ZXIgb3RoZXIgZXh0ZW5kc1xuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzIG1ldGhvZCBkZWFscyB3aXRoIGFsbCB0aGUgY2hhaW5pbmcgd29yayAtIHdpdGhvdXQgaXQsIGV4dGVuZCBpcyBmbGF0IGFuZCBkb2Vzbid0IHdvcmsgb24gb3RoZXIgZXh0ZW5kIHNlbGVjdG9yc1xuICAgICAgICAvLyB0aGlzIGlzIGFsc28gdGhlIG1vc3QgZXhwZW5zaXZlLi4gYW5kIGEgbWF0Y2ggb24gb25lIHNlbGVjdG9yIGNhbiBjYXVzZSBhbiBleHRlbnNpb24gb2YgYSBzZWxlY3RvciB3ZSBoYWQgYWxyZWFkeVxuICAgICAgICAvLyBwcm9jZXNzZWQgaWYgd2UgbG9vayBhdCBlYWNoIHNlbGVjdG9yIGF0IGEgdGltZSwgYXMgaXMgZG9uZSBpbiB2aXNpdFJ1bGVzZXRcblxuICAgICAgICB2YXIgZXh0ZW5kSW5kZXgsIHRhcmdldEV4dGVuZEluZGV4LCBtYXRjaGVzLCBleHRlbmRzVG9BZGQgPSBbXSwgbmV3U2VsZWN0b3IsIGV4dGVuZFZpc2l0b3IgPSB0aGlzLCBzZWxlY3RvclBhdGgsXG4gICAgICAgICAgICBleHRlbmQsIHRhcmdldEV4dGVuZCwgbmV3RXh0ZW5kO1xuXG4gICAgICAgIGl0ZXJhdGlvbkNvdW50ID0gaXRlcmF0aW9uQ291bnQgfHwgMDtcblxuICAgICAgICAvL2xvb3AgdGhyb3VnaCBjb21wYXJpbmcgZXZlcnkgZXh0ZW5kIHdpdGggZXZlcnkgdGFyZ2V0IGV4dGVuZC5cbiAgICAgICAgLy8gYSB0YXJnZXQgZXh0ZW5kIGlzIHRoZSBvbmUgb24gdGhlIHJ1bGVzZXQgd2UgYXJlIGxvb2tpbmcgYXQgY29weS9lZGl0L3Bhc3RpbmcgaW4gcGxhY2VcbiAgICAgICAgLy8gZS5nLiAgLmE6ZXh0ZW5kKC5iKSB7fSAgYW5kIC5iOmV4dGVuZCguYykge30gdGhlbiB0aGUgZmlyc3QgZXh0ZW5kIGV4dGVuZHMgdGhlIHNlY29uZCBvbmVcbiAgICAgICAgLy8gYW5kIHRoZSBzZWNvbmQgaXMgdGhlIHRhcmdldC5cbiAgICAgICAgLy8gdGhlIHNlcGFyYXRpb24gaW50byB0d28gbGlzdHMgYWxsb3dzIHVzIHRvIHByb2Nlc3MgYSBzdWJzZXQgb2YgY2hhaW5zIHdpdGggYSBiaWdnZXIgc2V0LCBhcyBpcyB0aGVcbiAgICAgICAgLy8gY2FzZSB3aGVuIHByb2Nlc3NpbmcgbWVkaWEgcXVlcmllc1xuICAgICAgICBmb3IgKGV4dGVuZEluZGV4ID0gMDsgZXh0ZW5kSW5kZXggPCBleHRlbmRzTGlzdC5sZW5ndGg7IGV4dGVuZEluZGV4KyspIHtcbiAgICAgICAgICAgIGZvciAodGFyZ2V0RXh0ZW5kSW5kZXggPSAwOyB0YXJnZXRFeHRlbmRJbmRleCA8IGV4dGVuZHNMaXN0VGFyZ2V0Lmxlbmd0aDsgdGFyZ2V0RXh0ZW5kSW5kZXgrKykge1xuXG4gICAgICAgICAgICAgICAgZXh0ZW5kID0gZXh0ZW5kc0xpc3RbZXh0ZW5kSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRhcmdldEV4dGVuZCA9IGV4dGVuZHNMaXN0VGFyZ2V0W3RhcmdldEV4dGVuZEluZGV4XTtcblxuICAgICAgICAgICAgICAgIC8vIGxvb2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICBpZiAoIGV4dGVuZC5wYXJlbnRfaWRzLmluZGV4T2YoIHRhcmdldEV4dGVuZC5vYmplY3RfaWQgKSA+PSAwICkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICAgICAgLy8gZmluZCBhIG1hdGNoIGluIHRoZSB0YXJnZXQgZXh0ZW5kcyBzZWxmIHNlbGVjdG9yICh0aGUgYml0IGJlZm9yZSA6ZXh0ZW5kKVxuICAgICAgICAgICAgICAgIHNlbGVjdG9yUGF0aCA9IFt0YXJnZXRFeHRlbmQuc2VsZlNlbGVjdG9yc1swXV07XG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IGV4dGVuZFZpc2l0b3IuZmluZE1hdGNoKGV4dGVuZCwgc2VsZWN0b3JQYXRoKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQuaGFzRm91bmRNYXRjaGVzID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBmb3VuZCBhIG1hdGNoLCBzbyBmb3IgZWFjaCBzZWxmIHNlbGVjdG9yLi5cbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kLnNlbGZTZWxlY3RvcnMuZm9yRWFjaChmdW5jdGlvbihzZWxmU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmZvID0gdGFyZ2V0RXh0ZW5kLnZpc2liaWxpdHlJbmZvKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgdGhlIGV4dGVuZCBhcyB1c3VhbFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0b3IgPSBleHRlbmRWaXNpdG9yLmV4dGVuZFNlbGVjdG9yKG1hdGNoZXMsIHNlbGVjdG9yUGF0aCwgc2VsZlNlbGVjdG9yLCBleHRlbmQuaXNWaXNpYmxlKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgbm93IHdlIGNyZWF0ZSBhIG5ldyBleHRlbmQgZnJvbSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXh0ZW5kID0gbmV3KHRyZWUuRXh0ZW5kKSh0YXJnZXRFeHRlbmQuc2VsZWN0b3IsIHRhcmdldEV4dGVuZC5vcHRpb24sIDAsIHRhcmdldEV4dGVuZC5jdXJyZW50RmlsZUluZm8sIGluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXh0ZW5kLnNlbGZTZWxlY3RvcnMgPSBuZXdTZWxlY3RvcjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBleHRlbmQgb250byB0aGUgbGlzdCBvZiBleHRlbmRzIGZvciB0aGF0IHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvcltuZXdTZWxlY3Rvci5sZW5ndGggLSAxXS5leHRlbmRMaXN0ID0gW25ld0V4dGVuZF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlY29yZCB0aGF0IHdlIG5lZWQgdG8gYWRkIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kc1RvQWRkLnB1c2gobmV3RXh0ZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V4dGVuZC5ydWxlc2V0ID0gdGFyZ2V0RXh0ZW5kLnJ1bGVzZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtZW1iZXIgaXRzIHBhcmVudHMgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V4dGVuZC5wYXJlbnRfaWRzID0gbmV3RXh0ZW5kLnBhcmVudF9pZHMuY29uY2F0KHRhcmdldEV4dGVuZC5wYXJlbnRfaWRzLCBleHRlbmQucGFyZW50X2lkcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgcHJvY2VzcyB0aGUgc2VsZWN0b3Igb25jZS4uIGlmIHdlIGhhdmUgOmV4dGVuZCguYSwuYikgdGhlbiBtdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXh0ZW5kcyB3aWxsIGxvb2sgYXQgdGhlIHNhbWUgc2VsZWN0b3IgcGF0aCwgc28gd2hlbiBleHRlbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGtub3cgdGhhdCBhbnkgb3RoZXJzIHdpbGwgYmUgZHVwbGljYXRlcyBpbiB0ZXJtcyBvZiB3aGF0IGlzIGFkZGVkIHRvIHRoZSBjc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFeHRlbmQuZmlyc3RFeHRlbmRPblRoaXNTZWxlY3RvclBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdFeHRlbmQuZmlyc3RFeHRlbmRPblRoaXNTZWxlY3RvclBhdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEV4dGVuZC5ydWxlc2V0LnBhdGhzLnB1c2gobmV3U2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0ZW5kc1RvQWRkLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gdHJ5IHRvIGRldGVjdCBjaXJjdWxhciByZWZlcmVuY2VzIHRvIHN0b3AgYSBzdGFjayBvdmVyZmxvdy5cbiAgICAgICAgICAgIC8vIG1heSBubyBsb25nZXIgYmUgbmVlZGVkLlxuICAgICAgICAgICAgdGhpcy5leHRlbmRDaGFpbkNvdW50Kys7XG4gICAgICAgICAgICBpZiAoaXRlcmF0aW9uQ291bnQgPiAxMDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3JPbmUgPSBcInt1bmFibGUgdG8gY2FsY3VsYXRlfVwiO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvclR3byA9IFwie3VuYWJsZSB0byBjYWxjdWxhdGV9XCI7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JPbmUgPSBleHRlbmRzVG9BZGRbMF0uc2VsZlNlbGVjdG9yc1swXS50b0NTUygpO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvclR3byA9IGV4dGVuZHNUb0FkZFswXS5zZWxlY3Rvci50b0NTUygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7fVxuICAgICAgICAgICAgICAgIHRocm93IHsgbWVzc2FnZTogXCJleHRlbmQgY2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkLiBPbmUgb2YgdGhlIGNpcmN1bGFyIGV4dGVuZHMgaXMgY3VycmVudGx5OlwiICtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JPbmUgKyBcIjpleHRlbmQoXCIgKyBzZWxlY3RvclR3byArIFwiKVwifTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm93IHByb2Nlc3MgdGhlIG5ldyBleHRlbmRzIG9uIHRoZSBleGlzdGluZyBydWxlcyBzbyB0aGF0IHdlIGNhbiBoYW5kbGUgYSBleHRlbmRpbmcgYiBleHRlbmRpbmcgYyBleHRlbmRpbmdcbiAgICAgICAgICAgIC8vIGQgZXh0ZW5kaW5nIGUuLi5cbiAgICAgICAgICAgIHJldHVybiBleHRlbmRzVG9BZGQuY29uY2F0KGV4dGVuZFZpc2l0b3IuZG9FeHRlbmRDaGFpbmluZyhleHRlbmRzVG9BZGQsIGV4dGVuZHNMaXN0VGFyZ2V0LCBpdGVyYXRpb25Db3VudCArIDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlbmRzVG9BZGQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHZpc2l0UnVsZTogZnVuY3Rpb24gKHJ1bGVOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gZmFsc2U7XG4gICAgfSxcbiAgICB2aXNpdE1peGluRGVmaW5pdGlvbjogZnVuY3Rpb24gKG1peGluRGVmaW5pdGlvbk5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcbiAgICB9LFxuICAgIHZpc2l0U2VsZWN0b3I6IGZ1bmN0aW9uIChzZWxlY3Rvck5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcbiAgICB9LFxuICAgIHZpc2l0UnVsZXNldDogZnVuY3Rpb24gKHJ1bGVzZXROb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgaWYgKHJ1bGVzZXROb2RlLnJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hlcywgcGF0aEluZGV4LCBleHRlbmRJbmRleCwgYWxsRXh0ZW5kcyA9IHRoaXMuYWxsRXh0ZW5kc1N0YWNrW3RoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgc2VsZWN0b3JzVG9BZGQgPSBbXSwgZXh0ZW5kVmlzaXRvciA9IHRoaXMsIHNlbGVjdG9yUGF0aDtcblxuICAgICAgICAvLyBsb29rIGF0IGVhY2ggc2VsZWN0b3IgcGF0aCBpbiB0aGUgcnVsZXNldCwgZmluZCBhbnkgZXh0ZW5kIG1hdGNoZXMgYW5kIHRoZW4gY29weSwgZmluZCBhbmQgcmVwbGFjZVxuXG4gICAgICAgIGZvciAoZXh0ZW5kSW5kZXggPSAwOyBleHRlbmRJbmRleCA8IGFsbEV4dGVuZHMubGVuZ3RoOyBleHRlbmRJbmRleCsrKSB7XG4gICAgICAgICAgICBmb3IgKHBhdGhJbmRleCA9IDA7IHBhdGhJbmRleCA8IHJ1bGVzZXROb2RlLnBhdGhzLmxlbmd0aDsgcGF0aEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvclBhdGggPSBydWxlc2V0Tm9kZS5wYXRoc1twYXRoSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgLy8gZXh0ZW5kaW5nIGV4dGVuZHMgaGFwcGVucyBpbml0aWFsbHksIGJlZm9yZSB0aGUgbWFpbiBwYXNzXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGVzZXROb2RlLmV4dGVuZE9uRXZlcnlQYXRoKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgdmFyIGV4dGVuZExpc3QgPSBzZWxlY3RvclBhdGhbc2VsZWN0b3JQYXRoLmxlbmd0aCAtIDFdLmV4dGVuZExpc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuZExpc3QgJiYgZXh0ZW5kTGlzdC5sZW5ndGgpIHsgY29udGludWU7IH1cblxuICAgICAgICAgICAgICAgIG1hdGNoZXMgPSB0aGlzLmZpbmRNYXRjaChhbGxFeHRlbmRzW2V4dGVuZEluZGV4XSwgc2VsZWN0b3JQYXRoKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhbGxFeHRlbmRzW2V4dGVuZEluZGV4XS5oYXNGb3VuZE1hdGNoZXMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGFsbEV4dGVuZHNbZXh0ZW5kSW5kZXhdLnNlbGZTZWxlY3RvcnMuZm9yRWFjaChmdW5jdGlvbihzZWxmU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHRlbmRlZFNlbGVjdG9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkU2VsZWN0b3JzID0gZXh0ZW5kVmlzaXRvci5leHRlbmRTZWxlY3RvcihtYXRjaGVzLCBzZWxlY3RvclBhdGgsIHNlbGZTZWxlY3RvciwgYWxsRXh0ZW5kc1tleHRlbmRJbmRleF0uaXNWaXNpYmxlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzVG9BZGQucHVzaChleHRlbmRlZFNlbGVjdG9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBydWxlc2V0Tm9kZS5wYXRocyA9IHJ1bGVzZXROb2RlLnBhdGhzLmNvbmNhdChzZWxlY3RvcnNUb0FkZCk7XG4gICAgfSxcbiAgICBmaW5kTWF0Y2g6IGZ1bmN0aW9uIChleHRlbmQsIGhheXN0YWNrU2VsZWN0b3JQYXRoKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGxvb2sgdGhyb3VnaCB0aGUgaGF5c3RhY2sgc2VsZWN0b3IgcGF0aCB0byB0cnkgYW5kIGZpbmQgdGhlIG5lZWRsZSAtIGV4dGVuZC5zZWxlY3RvclxuICAgICAgICAvLyByZXR1cm5zIGFuIGFycmF5IG9mIHNlbGVjdG9yIG1hdGNoZXMgdGhhdCBjYW4gdGhlbiBiZSByZXBsYWNlZFxuICAgICAgICAvL1xuICAgICAgICB2YXIgaGF5c3RhY2tTZWxlY3RvckluZGV4LCBoYWNrc3RhY2tTZWxlY3RvciwgaGFja3N0YWNrRWxlbWVudEluZGV4LCBoYXlzdGFja0VsZW1lbnQsXG4gICAgICAgICAgICB0YXJnZXRDb21iaW5hdG9yLCBpLFxuICAgICAgICAgICAgZXh0ZW5kVmlzaXRvciA9IHRoaXMsXG4gICAgICAgICAgICBuZWVkbGVFbGVtZW50cyA9IGV4dGVuZC5zZWxlY3Rvci5lbGVtZW50cyxcbiAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoZXMgPSBbXSwgcG90ZW50aWFsTWF0Y2gsIG1hdGNoZXMgPSBbXTtcblxuICAgICAgICAvLyBsb29wIHRocm91Z2ggdGhlIGhheXN0YWNrIGVsZW1lbnRzXG4gICAgICAgIGZvciAoaGF5c3RhY2tTZWxlY3RvckluZGV4ID0gMDsgaGF5c3RhY2tTZWxlY3RvckluZGV4IDwgaGF5c3RhY2tTZWxlY3RvclBhdGgubGVuZ3RoOyBoYXlzdGFja1NlbGVjdG9ySW5kZXgrKykge1xuICAgICAgICAgICAgaGFja3N0YWNrU2VsZWN0b3IgPSBoYXlzdGFja1NlbGVjdG9yUGF0aFtoYXlzdGFja1NlbGVjdG9ySW5kZXhdO1xuXG4gICAgICAgICAgICBmb3IgKGhhY2tzdGFja0VsZW1lbnRJbmRleCA9IDA7IGhhY2tzdGFja0VsZW1lbnRJbmRleCA8IGhhY2tzdGFja1NlbGVjdG9yLmVsZW1lbnRzLmxlbmd0aDsgaGFja3N0YWNrRWxlbWVudEluZGV4KyspIHtcblxuICAgICAgICAgICAgICAgIGhheXN0YWNrRWxlbWVudCA9IGhhY2tzdGFja1NlbGVjdG9yLmVsZW1lbnRzW2hhY2tzdGFja0VsZW1lbnRJbmRleF07XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhbGxvdyBlbGVtZW50cyBiZWZvcmUgb3VyIG1hdGNoIHdlIGNhbiBhZGQgYSBwb3RlbnRpYWwgbWF0Y2ggZXZlcnkgdGltZS4gb3RoZXJ3aXNlIG9ubHkgYXQgdGhlIGZpcnN0IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuZC5hbGxvd0JlZm9yZSB8fCAoaGF5c3RhY2tTZWxlY3RvckluZGV4ID09PSAwICYmIGhhY2tzdGFja0VsZW1lbnRJbmRleCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2hlcy5wdXNoKHtwYXRoSW5kZXg6IGhheXN0YWNrU2VsZWN0b3JJbmRleCwgaW5kZXg6IGhhY2tzdGFja0VsZW1lbnRJbmRleCwgbWF0Y2hlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb21iaW5hdG9yOiBoYXlzdGFja0VsZW1lbnQuY29tYmluYXRvcn0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb3RlbnRpYWxNYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoID0gcG90ZW50aWFsTWF0Y2hlc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3RvcnMgYWRkIFwiIFwiIG9udG8gdGhlIGZpcnN0IGVsZW1lbnQuIFdoZW4gd2UgdXNlICYgaXQgam9pbnMgdGhlIHNlbGVjdG9ycyB0b2dldGhlciwgYnV0IGlmIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gZWFjaCBzZWxlY3RvciBpbiBoYXlzdGFja1NlbGVjdG9yUGF0aCBoYXMgYSBzcGFjZSBiZWZvcmUgaXQgYWRkZWQgaW4gdGhlIHRvQ1NTIHBoYXNlLiBzbyB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHdvcmsgb3V0IHdoYXQgdGhlIHJlc3VsdGluZyBjb21iaW5hdG9yIHdpbGwgYmVcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29tYmluYXRvciA9IGhheXN0YWNrRWxlbWVudC5jb21iaW5hdG9yLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Q29tYmluYXRvciA9PT0gJycgJiYgaGFja3N0YWNrRWxlbWVudEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDb21iaW5hdG9yID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgbWF0Y2gsIG51bGwgb3VyIG1hdGNoIHRvIGluZGljYXRlIGZhaWx1cmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleHRlbmRWaXNpdG9yLmlzRWxlbWVudFZhbHVlc0VxdWFsKG5lZWRsZUVsZW1lbnRzW3BvdGVudGlhbE1hdGNoLm1hdGNoZWRdLnZhbHVlLCBoYXlzdGFja0VsZW1lbnQudmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAocG90ZW50aWFsTWF0Y2gubWF0Y2hlZCA+IDAgJiYgbmVlZGxlRWxlbWVudHNbcG90ZW50aWFsTWF0Y2gubWF0Y2hlZF0uY29tYmluYXRvci52YWx1ZSAhPT0gdGFyZ2V0Q29tYmluYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoLm1hdGNoZWQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBzdGlsbCB2YWxpZCBhbmQgaGF2ZSBmaW5pc2hlZCwgdGVzdCB3aGV0aGVyIHdlIGhhdmUgZWxlbWVudHMgYWZ0ZXIgYW5kIHdoZXRoZXIgdGhlc2UgYXJlIGFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvdGVudGlhbE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxNYXRjaC5maW5pc2hlZCA9IHBvdGVudGlhbE1hdGNoLm1hdGNoZWQgPT09IG5lZWRsZUVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3RlbnRpYWxNYXRjaC5maW5pc2hlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghZXh0ZW5kLmFsbG93QWZ0ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGhhY2tzdGFja0VsZW1lbnRJbmRleCArIDEgPCBoYWNrc3RhY2tTZWxlY3Rvci5lbGVtZW50cy5sZW5ndGggfHwgaGF5c3RhY2tTZWxlY3RvckluZGV4ICsgMSA8IGhheXN0YWNrU2VsZWN0b3JQYXRoLmxlbmd0aCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG51bGwgd2UgcmVtb3ZlLCBpZiBub3QsIHdlIGFyZSBzdGlsbCB2YWxpZCwgc28gZWl0aGVyIHB1c2ggYXMgYSB2YWxpZCBtYXRjaCBvciBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICBpZiAocG90ZW50aWFsTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3RlbnRpYWxNYXRjaC5maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoLmxlbmd0aCA9IG5lZWRsZUVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxNYXRjaC5lbmRQYXRoSW5kZXggPSBoYXlzdGFja1NlbGVjdG9ySW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2guZW5kUGF0aEVsZW1lbnRJbmRleCA9IGhhY2tzdGFja0VsZW1lbnRJbmRleCArIDE7IC8vIGluZGV4IGFmdGVyIGVuZCBvZiBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoZXMubGVuZ3RoID0gMDsgLy8gd2UgZG9uJ3QgYWxsb3cgbWF0Y2hlcyB0byBvdmVybGFwLCBzbyBzdGFydCBtYXRjaGluZyBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChwb3RlbnRpYWxNYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxNYXRjaGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICB9LFxuICAgIGlzRWxlbWVudFZhbHVlc0VxdWFsOiBmdW5jdGlvbihlbGVtZW50VmFsdWUxLCBlbGVtZW50VmFsdWUyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudFZhbHVlMSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZWxlbWVudFZhbHVlMiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRWYWx1ZTEgPT09IGVsZW1lbnRWYWx1ZTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnRWYWx1ZTEgaW5zdGFuY2VvZiB0cmVlLkF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRWYWx1ZTEub3AgIT09IGVsZW1lbnRWYWx1ZTIub3AgfHwgZWxlbWVudFZhbHVlMS5rZXkgIT09IGVsZW1lbnRWYWx1ZTIua2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlbGVtZW50VmFsdWUxLnZhbHVlIHx8ICFlbGVtZW50VmFsdWUyLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRWYWx1ZTEudmFsdWUgfHwgZWxlbWVudFZhbHVlMi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudFZhbHVlMSA9IGVsZW1lbnRWYWx1ZTEudmFsdWUudmFsdWUgfHwgZWxlbWVudFZhbHVlMS52YWx1ZTtcbiAgICAgICAgICAgIGVsZW1lbnRWYWx1ZTIgPSBlbGVtZW50VmFsdWUyLnZhbHVlLnZhbHVlIHx8IGVsZW1lbnRWYWx1ZTIudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudFZhbHVlMSA9PT0gZWxlbWVudFZhbHVlMjtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50VmFsdWUxID0gZWxlbWVudFZhbHVlMS52YWx1ZTtcbiAgICAgICAgZWxlbWVudFZhbHVlMiA9IGVsZW1lbnRWYWx1ZTIudmFsdWU7XG4gICAgICAgIGlmIChlbGVtZW50VmFsdWUxIGluc3RhbmNlb2YgdHJlZS5TZWxlY3Rvcikge1xuICAgICAgICAgICAgaWYgKCEoZWxlbWVudFZhbHVlMiBpbnN0YW5jZW9mIHRyZWUuU2VsZWN0b3IpIHx8IGVsZW1lbnRWYWx1ZTEuZWxlbWVudHMubGVuZ3RoICE9PSBlbGVtZW50VmFsdWUyLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICA8IGVsZW1lbnRWYWx1ZTEuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFZhbHVlMS5lbGVtZW50c1tpXS5jb21iaW5hdG9yLnZhbHVlICE9PSBlbGVtZW50VmFsdWUyLmVsZW1lbnRzW2ldLmNvbWJpbmF0b3IudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IDAgfHwgKGVsZW1lbnRWYWx1ZTEuZWxlbWVudHNbaV0uY29tYmluYXRvci52YWx1ZSB8fCAnICcpICE9PSAoZWxlbWVudFZhbHVlMi5lbGVtZW50c1tpXS5jb21iaW5hdG9yLnZhbHVlIHx8ICcgJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNFbGVtZW50VmFsdWVzRXF1YWwoZWxlbWVudFZhbHVlMS5lbGVtZW50c1tpXS52YWx1ZSwgZWxlbWVudFZhbHVlMi5lbGVtZW50c1tpXS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGV4dGVuZFNlbGVjdG9yOmZ1bmN0aW9uIChtYXRjaGVzLCBzZWxlY3RvclBhdGgsIHJlcGxhY2VtZW50U2VsZWN0b3IsIGlzVmlzaWJsZSkge1xuXG4gICAgICAgIC8vZm9yIGEgc2V0IG9mIG1hdGNoZXMsIHJlcGxhY2UgZWFjaCBtYXRjaCB3aXRoIHRoZSByZXBsYWNlbWVudCBzZWxlY3RvclxuXG4gICAgICAgIHZhciBjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXggPSAwLFxuICAgICAgICAgICAgY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCA9IDAsXG4gICAgICAgICAgICBwYXRoID0gW10sXG4gICAgICAgICAgICBtYXRjaEluZGV4LFxuICAgICAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgICAgICBmaXJzdEVsZW1lbnQsXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIG5ld0VsZW1lbnRzO1xuXG4gICAgICAgIGZvciAobWF0Y2hJbmRleCA9IDA7IG1hdGNoSW5kZXggPCBtYXRjaGVzLmxlbmd0aDsgbWF0Y2hJbmRleCsrKSB7XG4gICAgICAgICAgICBtYXRjaCA9IG1hdGNoZXNbbWF0Y2hJbmRleF07XG4gICAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yUGF0aFttYXRjaC5wYXRoSW5kZXhdO1xuICAgICAgICAgICAgZmlyc3RFbGVtZW50ID0gbmV3IHRyZWUuRWxlbWVudChcbiAgICAgICAgICAgICAgICBtYXRjaC5pbml0aWFsQ29tYmluYXRvcixcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudFNlbGVjdG9yLmVsZW1lbnRzWzBdLnZhbHVlLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50U2VsZWN0b3IuZWxlbWVudHNbMF0uaW5kZXgsXG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRTZWxlY3Rvci5lbGVtZW50c1swXS5jdXJyZW50RmlsZUluZm9cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaC5wYXRoSW5kZXggPiBjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXggJiYgY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMV0uZWxlbWVudHMgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICAgICAgICAgLmVsZW1lbnRzLmNvbmNhdChzZWxlY3RvclBhdGhbY3VycmVudFNlbGVjdG9yUGF0aEluZGV4XS5lbGVtZW50cy5zbGljZShjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4KSk7XG4gICAgICAgICAgICAgICAgY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgY3VycmVudFNlbGVjdG9yUGF0aEluZGV4Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ld0VsZW1lbnRzID0gc2VsZWN0b3IuZWxlbWVudHNcbiAgICAgICAgICAgICAgICAuc2xpY2UoY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCwgbWF0Y2guaW5kZXgpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbZmlyc3RFbGVtZW50XSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KHJlcGxhY2VtZW50U2VsZWN0b3IuZWxlbWVudHMuc2xpY2UoMSkpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFNlbGVjdG9yUGF0aEluZGV4ID09PSBtYXRjaC5wYXRoSW5kZXggJiYgbWF0Y2hJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMV0uZWxlbWVudHMgPVxuICAgICAgICAgICAgICAgICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMV0uZWxlbWVudHMuY29uY2F0KG5ld0VsZW1lbnRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguY29uY2F0KHNlbGVjdG9yUGF0aC5zbGljZShjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXgsIG1hdGNoLnBhdGhJbmRleCkpO1xuXG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5ldyB0cmVlLlNlbGVjdG9yKFxuICAgICAgICAgICAgICAgICAgICBuZXdFbGVtZW50c1xuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFNlbGVjdG9yUGF0aEluZGV4ID0gbWF0Y2guZW5kUGF0aEluZGV4O1xuICAgICAgICAgICAgY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCA9IG1hdGNoLmVuZFBhdGhFbGVtZW50SW5kZXg7XG4gICAgICAgICAgICBpZiAoY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCA+PSBzZWxlY3RvclBhdGhbY3VycmVudFNlbGVjdG9yUGF0aEluZGV4XS5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXggPCBzZWxlY3RvclBhdGgubGVuZ3RoICYmIGN1cnJlbnRTZWxlY3RvclBhdGhFbGVtZW50SW5kZXggPiAwKSB7XG4gICAgICAgICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMV0uZWxlbWVudHMgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICAgICAuZWxlbWVudHMuY29uY2F0KHNlbGVjdG9yUGF0aFtjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXhdLmVsZW1lbnRzLnNsaWNlKGN1cnJlbnRTZWxlY3RvclBhdGhFbGVtZW50SW5kZXgpKTtcbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aCA9IHBhdGguY29uY2F0KHNlbGVjdG9yUGF0aC5zbGljZShjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXgsIHNlbGVjdG9yUGF0aC5sZW5ndGgpKTtcbiAgICAgICAgcGF0aCA9IHBhdGgubWFwKGZ1bmN0aW9uIChjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHdlIGNhbiByZS11c2UgZWxlbWVudHMgaGVyZSwgYmVjYXVzZSB0aGUgdmlzaWJpbGl0eSBwcm9wZXJ0eSBtYXR0ZXJzIG9ubHkgZm9yIHNlbGVjdG9yc1xuICAgICAgICAgICAgdmFyIGRlcml2ZWQgPSBjdXJyZW50VmFsdWUuY3JlYXRlRGVyaXZlZChjdXJyZW50VmFsdWUuZWxlbWVudHMpO1xuICAgICAgICAgICAgaWYgKGlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGRlcml2ZWQuZW5zdXJlVmlzaWJpbGl0eSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXJpdmVkLmVuc3VyZUludmlzaWJpbGl0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlcml2ZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuICAgIHZpc2l0TWVkaWE6IGZ1bmN0aW9uIChtZWRpYU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2YXIgbmV3QWxsRXh0ZW5kcyA9IG1lZGlhTm9kZS5hbGxFeHRlbmRzLmNvbmNhdCh0aGlzLmFsbEV4dGVuZHNTdGFja1t0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICAgIG5ld0FsbEV4dGVuZHMgPSBuZXdBbGxFeHRlbmRzLmNvbmNhdCh0aGlzLmRvRXh0ZW5kQ2hhaW5pbmcobmV3QWxsRXh0ZW5kcywgbWVkaWFOb2RlLmFsbEV4dGVuZHMpKTtcbiAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2sucHVzaChuZXdBbGxFeHRlbmRzKTtcbiAgICB9LFxuICAgIHZpc2l0TWVkaWFPdXQ6IGZ1bmN0aW9uIChtZWRpYU5vZGUpIHtcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IHRoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCA9IGxhc3RJbmRleDtcbiAgICB9LFxuICAgIHZpc2l0RGlyZWN0aXZlOiBmdW5jdGlvbiAoZGlyZWN0aXZlTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHZhciBuZXdBbGxFeHRlbmRzID0gZGlyZWN0aXZlTm9kZS5hbGxFeHRlbmRzLmNvbmNhdCh0aGlzLmFsbEV4dGVuZHNTdGFja1t0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICAgIG5ld0FsbEV4dGVuZHMgPSBuZXdBbGxFeHRlbmRzLmNvbmNhdCh0aGlzLmRvRXh0ZW5kQ2hhaW5pbmcobmV3QWxsRXh0ZW5kcywgZGlyZWN0aXZlTm9kZS5hbGxFeHRlbmRzKSk7XG4gICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrLnB1c2gobmV3QWxsRXh0ZW5kcyk7XG4gICAgfSxcbiAgICB2aXNpdERpcmVjdGl2ZU91dDogZnVuY3Rpb24gKGRpcmVjdGl2ZU5vZGUpIHtcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IHRoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCA9IGxhc3RJbmRleDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2Nlc3NFeHRlbmRzVmlzaXRvcjtcblxufSx7XCIuLi9sb2dnZXJcIjozMyxcIi4uL3RyZWVcIjo2MixcIi4vdmlzaXRvclwiOjkxfV0sODU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuZnVuY3Rpb24gSW1wb3J0U2VxdWVuY2VyKG9uU2VxdWVuY2VyRW1wdHkpIHtcbiAgICB0aGlzLmltcG9ydHMgPSBbXTtcbiAgICB0aGlzLnZhcmlhYmxlSW1wb3J0cyA9IFtdO1xuICAgIHRoaXMuX29uU2VxdWVuY2VyRW1wdHkgPSBvblNlcXVlbmNlckVtcHR5O1xuICAgIHRoaXMuX2N1cnJlbnREZXB0aCA9IDA7XG59XG5cbkltcG9ydFNlcXVlbmNlci5wcm90b3R5cGUuYWRkSW1wb3J0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgaW1wb3J0U2VxdWVuY2VyID0gdGhpcyxcbiAgICAgICAgaW1wb3J0SXRlbSA9IHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgIGFyZ3M6IG51bGwsXG4gICAgICAgICAgICBpc1JlYWR5OiBmYWxzZVxuICAgICAgICB9O1xuICAgIHRoaXMuaW1wb3J0cy5wdXNoKGltcG9ydEl0ZW0pO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaW1wb3J0SXRlbS5hcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgaW1wb3J0SXRlbS5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgaW1wb3J0U2VxdWVuY2VyLnRyeVJ1bigpO1xuICAgIH07XG59O1xuXG5JbXBvcnRTZXF1ZW5jZXIucHJvdG90eXBlLmFkZFZhcmlhYmxlSW1wb3J0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB0aGlzLnZhcmlhYmxlSW1wb3J0cy5wdXNoKGNhbGxiYWNrKTtcbn07XG5cbkltcG9ydFNlcXVlbmNlci5wcm90b3R5cGUudHJ5UnVuID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY3VycmVudERlcHRoKys7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmltcG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBpbXBvcnRJdGVtID0gdGhpcy5pbXBvcnRzWzBdO1xuICAgICAgICAgICAgICAgIGlmICghaW1wb3J0SXRlbS5pc1JlYWR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRzID0gdGhpcy5pbXBvcnRzLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGltcG9ydEl0ZW0uY2FsbGJhY2suYXBwbHkobnVsbCwgaW1wb3J0SXRlbS5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnZhcmlhYmxlSW1wb3J0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YXJpYWJsZUltcG9ydCA9IHRoaXMudmFyaWFibGVJbXBvcnRzWzBdO1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZUltcG9ydHMgPSB0aGlzLnZhcmlhYmxlSW1wb3J0cy5zbGljZSgxKTtcbiAgICAgICAgICAgIHZhcmlhYmxlSW1wb3J0KCk7XG4gICAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9jdXJyZW50RGVwdGgtLTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2N1cnJlbnREZXB0aCA9PT0gMCAmJiB0aGlzLl9vblNlcXVlbmNlckVtcHR5KSB7XG4gICAgICAgIHRoaXMuX29uU2VxdWVuY2VyRW1wdHkoKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltcG9ydFNlcXVlbmNlcjtcblxufSx7fV0sODY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGNvbnRleHRzID0gcmVxdWlyZShcIi4uL2NvbnRleHRzXCIpLFxuICAgIFZpc2l0b3IgPSByZXF1aXJlKFwiLi92aXNpdG9yXCIpLFxuICAgIEltcG9ydFNlcXVlbmNlciA9IHJlcXVpcmUoXCIuL2ltcG9ydC1zZXF1ZW5jZXJcIik7XG5cbnZhciBJbXBvcnRWaXNpdG9yID0gZnVuY3Rpb24oaW1wb3J0ZXIsIGZpbmlzaCkge1xuXG4gICAgdGhpcy5fdmlzaXRvciA9IG5ldyBWaXNpdG9yKHRoaXMpO1xuICAgIHRoaXMuX2ltcG9ydGVyID0gaW1wb3J0ZXI7XG4gICAgdGhpcy5fZmluaXNoID0gZmluaXNoO1xuICAgIHRoaXMuY29udGV4dCA9IG5ldyBjb250ZXh0cy5FdmFsKCk7XG4gICAgdGhpcy5pbXBvcnRDb3VudCA9IDA7XG4gICAgdGhpcy5vbmNlRmlsZURldGVjdGlvbk1hcCA9IHt9O1xuICAgIHRoaXMucmVjdXJzaW9uRGV0ZWN0b3IgPSB7fTtcbiAgICB0aGlzLl9zZXF1ZW5jZXIgPSBuZXcgSW1wb3J0U2VxdWVuY2VyKHRoaXMuX29uU2VxdWVuY2VyRW1wdHkuYmluZCh0aGlzKSk7XG59O1xuXG5JbXBvcnRWaXNpdG9yLnByb3RvdHlwZSA9IHtcbiAgICBpc1JlcGxhY2luZzogZmFsc2UsXG4gICAgcnVuOiBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gcHJvY2VzcyB0aGUgY29udGVudHNcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0b3IudmlzaXQocm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zZXF1ZW5jZXIudHJ5UnVuKCk7XG4gICAgfSxcbiAgICBfb25TZXF1ZW5jZXJFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmluaXNoKHRoaXMuZXJyb3IpO1xuICAgIH0sXG4gICAgdmlzaXRJbXBvcnQ6IGZ1bmN0aW9uIChpbXBvcnROb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgdmFyIGlubGluZUNTUyA9IGltcG9ydE5vZGUub3B0aW9ucy5pbmxpbmU7XG5cbiAgICAgICAgaWYgKCFpbXBvcnROb2RlLmNzcyB8fCBpbmxpbmVDU1MpIHtcblxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgY29udGV4dHMuRXZhbCh0aGlzLmNvbnRleHQsIHRoaXMuY29udGV4dC5mcmFtZXMuc2xpY2UoMCkpO1xuICAgICAgICAgICAgdmFyIGltcG9ydFBhcmVudCA9IGNvbnRleHQuZnJhbWVzWzBdO1xuXG4gICAgICAgICAgICB0aGlzLmltcG9ydENvdW50Kys7XG4gICAgICAgICAgICBpZiAoaW1wb3J0Tm9kZS5pc1ZhcmlhYmxlSW1wb3J0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXF1ZW5jZXIuYWRkVmFyaWFibGVJbXBvcnQodGhpcy5wcm9jZXNzSW1wb3J0Tm9kZS5iaW5kKHRoaXMsIGltcG9ydE5vZGUsIGNvbnRleHQsIGltcG9ydFBhcmVudCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NJbXBvcnROb2RlKGltcG9ydE5vZGUsIGNvbnRleHQsIGltcG9ydFBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gZmFsc2U7XG4gICAgfSxcbiAgICBwcm9jZXNzSW1wb3J0Tm9kZTogZnVuY3Rpb24oaW1wb3J0Tm9kZSwgY29udGV4dCwgaW1wb3J0UGFyZW50KSB7XG4gICAgICAgIHZhciBldmFsZEltcG9ydE5vZGUsXG4gICAgICAgICAgICBpbmxpbmVDU1MgPSBpbXBvcnROb2RlLm9wdGlvbnMuaW5saW5lO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBldmFsZEltcG9ydE5vZGUgPSBpbXBvcnROb2RlLmV2YWxGb3JJbXBvcnQoY29udGV4dCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgaWYgKCFlLmZpbGVuYW1lKSB7IGUuaW5kZXggPSBpbXBvcnROb2RlLmluZGV4OyBlLmZpbGVuYW1lID0gaW1wb3J0Tm9kZS5jdXJyZW50RmlsZUluZm8uZmlsZW5hbWU7IH1cbiAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gZXZhbCBwcm9wZXJseSBhbmQgdHJlYXQgYXMgY3NzXG4gICAgICAgICAgICBpbXBvcnROb2RlLmNzcyA9IHRydWU7XG4gICAgICAgICAgICAvLyBpZiB0aGF0IGZhaWxzLCB0aGlzIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gICAgICAgICAgICBpbXBvcnROb2RlLmVycm9yID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmFsZEltcG9ydE5vZGUgJiYgKCFldmFsZEltcG9ydE5vZGUuY3NzIHx8IGlubGluZUNTUykpIHtcblxuICAgICAgICAgICAgaWYgKGV2YWxkSW1wb3J0Tm9kZS5vcHRpb25zLm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5pbXBvcnRNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRyeSBhcHBlbmRpbmcgaWYgd2UgaGF2ZW4ndCBkZXRlcm1pbmVkIGlmIGl0IGlzIGNzcyBvciBub3RcbiAgICAgICAgICAgIHZhciB0cnlBcHBlbmRMZXNzRXh0ZW5zaW9uID0gZXZhbGRJbXBvcnROb2RlLmNzcyA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGltcG9ydFBhcmVudC5ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpbXBvcnRQYXJlbnQucnVsZXNbaV0gPT09IGltcG9ydE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0UGFyZW50LnJ1bGVzW2ldID0gZXZhbGRJbXBvcnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvbkltcG9ydGVkID0gdGhpcy5vbkltcG9ydGVkLmJpbmQodGhpcywgZXZhbGRJbXBvcnROb2RlLCBjb250ZXh0KSxcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZWRPbkltcG9ydGVkID0gdGhpcy5fc2VxdWVuY2VyLmFkZEltcG9ydChvbkltcG9ydGVkKTtcblxuICAgICAgICAgICAgdGhpcy5faW1wb3J0ZXIucHVzaChldmFsZEltcG9ydE5vZGUuZ2V0UGF0aCgpLCB0cnlBcHBlbmRMZXNzRXh0ZW5zaW9uLCBldmFsZEltcG9ydE5vZGUuY3VycmVudEZpbGVJbmZvLFxuICAgICAgICAgICAgICAgIGV2YWxkSW1wb3J0Tm9kZS5vcHRpb25zLCBzZXF1ZW5jZWRPbkltcG9ydGVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0Q291bnQtLTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXF1ZW5jZXIudHJ5UnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9uSW1wb3J0ZWQ6IGZ1bmN0aW9uIChpbXBvcnROb2RlLCBjb250ZXh0LCBlLCByb290LCBpbXBvcnRlZEF0Um9vdCwgZnVsbFBhdGgpIHtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGlmICghZS5maWxlbmFtZSkge1xuICAgICAgICAgICAgICAgIGUuaW5kZXggPSBpbXBvcnROb2RlLmluZGV4OyBlLmZpbGVuYW1lID0gaW1wb3J0Tm9kZS5jdXJyZW50RmlsZUluZm8uZmlsZW5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbXBvcnRWaXNpdG9yID0gdGhpcyxcbiAgICAgICAgICAgIGlubGluZUNTUyA9IGltcG9ydE5vZGUub3B0aW9ucy5pbmxpbmUsXG4gICAgICAgICAgICBpc1BsdWdpbiA9IGltcG9ydE5vZGUub3B0aW9ucy5wbHVnaW4sXG4gICAgICAgICAgICBpc09wdGlvbmFsID0gaW1wb3J0Tm9kZS5vcHRpb25zLm9wdGlvbmFsLFxuICAgICAgICAgICAgZHVwbGljYXRlSW1wb3J0ID0gaW1wb3J0ZWRBdFJvb3QgfHwgZnVsbFBhdGggaW4gaW1wb3J0VmlzaXRvci5yZWN1cnNpb25EZXRlY3RvcjtcblxuICAgICAgICBpZiAoIWNvbnRleHQuaW1wb3J0TXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGlmIChkdXBsaWNhdGVJbXBvcnQpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnROb2RlLnNraXAgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbXBvcnROb2RlLnNraXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bGxQYXRoIGluIGltcG9ydFZpc2l0b3Iub25jZUZpbGVEZXRlY3Rpb25NYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydFZpc2l0b3Iub25jZUZpbGVEZXRlY3Rpb25NYXBbZnVsbFBhdGhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZ1bGxQYXRoICYmIGlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGltcG9ydE5vZGUuc2tpcCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgaW1wb3J0Tm9kZS5yb290ID0gcm9vdDtcbiAgICAgICAgICAgIGltcG9ydE5vZGUuaW1wb3J0ZWRGaWxlbmFtZSA9IGZ1bGxQYXRoO1xuXG4gICAgICAgICAgICBpZiAoIWlubGluZUNTUyAmJiAhaXNQbHVnaW4gJiYgKGNvbnRleHQuaW1wb3J0TXVsdGlwbGUgfHwgIWR1cGxpY2F0ZUltcG9ydCkpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRWaXNpdG9yLnJlY3Vyc2lvbkRldGVjdG9yW2Z1bGxQYXRoXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgb2xkQ29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2l0b3IudmlzaXQocm9vdCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gb2xkQ29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGltcG9ydFZpc2l0b3IuaW1wb3J0Q291bnQtLTtcblxuICAgICAgICBpZiAoaW1wb3J0VmlzaXRvci5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICBpbXBvcnRWaXNpdG9yLl9zZXF1ZW5jZXIudHJ5UnVuKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHZpc2l0UnVsZTogZnVuY3Rpb24gKHJ1bGVOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgaWYgKHJ1bGVOb2RlLnZhbHVlLnR5cGUgPT09IFwiRGV0YWNoZWRSdWxlc2V0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMudW5zaGlmdChydWxlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdmlzaXRSdWxlT3V0IDogZnVuY3Rpb24ocnVsZU5vZGUpIHtcbiAgICAgICAgaWYgKHJ1bGVOb2RlLnZhbHVlLnR5cGUgPT09IFwiRGV0YWNoZWRSdWxlc2V0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdmlzaXREaXJlY3RpdmU6IGZ1bmN0aW9uIChkaXJlY3RpdmVOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy51bnNoaWZ0KGRpcmVjdGl2ZU5vZGUpO1xuICAgIH0sXG4gICAgdmlzaXREaXJlY3RpdmVPdXQ6IGZ1bmN0aW9uIChkaXJlY3RpdmVOb2RlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMuc2hpZnQoKTtcbiAgICB9LFxuICAgIHZpc2l0TWl4aW5EZWZpbml0aW9uOiBmdW5jdGlvbiAobWl4aW5EZWZpbml0aW9uTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMudW5zaGlmdChtaXhpbkRlZmluaXRpb25Ob2RlKTtcbiAgICB9LFxuICAgIHZpc2l0TWl4aW5EZWZpbml0aW9uT3V0OiBmdW5jdGlvbiAobWl4aW5EZWZpbml0aW9uTm9kZSkge1xuICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVzLnNoaWZ0KCk7XG4gICAgfSxcbiAgICB2aXNpdFJ1bGVzZXQ6IGZ1bmN0aW9uIChydWxlc2V0Tm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMudW5zaGlmdChydWxlc2V0Tm9kZSk7XG4gICAgfSxcbiAgICB2aXNpdFJ1bGVzZXRPdXQ6IGZ1bmN0aW9uIChydWxlc2V0Tm9kZSkge1xuICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVzLnNoaWZ0KCk7XG4gICAgfSxcbiAgICB2aXNpdE1lZGlhOiBmdW5jdGlvbiAobWVkaWFOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy51bnNoaWZ0KG1lZGlhTm9kZS5ydWxlc1swXSk7XG4gICAgfSxcbiAgICB2aXNpdE1lZGlhT3V0OiBmdW5jdGlvbiAobWVkaWFOb2RlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMuc2hpZnQoKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBJbXBvcnRWaXNpdG9yO1xuXG59LHtcIi4uL2NvbnRleHRzXCI6MTEsXCIuL2ltcG9ydC1zZXF1ZW5jZXJcIjo4NSxcIi4vdmlzaXRvclwiOjkxfV0sODc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZpc2l0b3JzID0ge1xuICAgIFZpc2l0b3I6IHJlcXVpcmUoXCIuL3Zpc2l0b3JcIiksXG4gICAgSW1wb3J0VmlzaXRvcjogcmVxdWlyZSgnLi9pbXBvcnQtdmlzaXRvcicpLFxuICAgIE1hcmtWaXNpYmxlU2VsZWN0b3JzVmlzaXRvcjogcmVxdWlyZShcIi4vc2V0LXRyZWUtdmlzaWJpbGl0eS12aXNpdG9yXCIpLFxuICAgIEV4dGVuZFZpc2l0b3I6IHJlcXVpcmUoJy4vZXh0ZW5kLXZpc2l0b3InKSxcbiAgICBKb2luU2VsZWN0b3JWaXNpdG9yOiByZXF1aXJlKCcuL2pvaW4tc2VsZWN0b3ItdmlzaXRvcicpLFxuICAgIFRvQ1NTVmlzaXRvcjogcmVxdWlyZSgnLi90by1jc3MtdmlzaXRvcicpXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZpc2l0b3JzO1xuXG59LHtcIi4vZXh0ZW5kLXZpc2l0b3JcIjo4NCxcIi4vaW1wb3J0LXZpc2l0b3JcIjo4NixcIi4vam9pbi1zZWxlY3Rvci12aXNpdG9yXCI6ODgsXCIuL3NldC10cmVlLXZpc2liaWxpdHktdmlzaXRvclwiOjg5LFwiLi90by1jc3MtdmlzaXRvclwiOjkwLFwiLi92aXNpdG9yXCI6OTF9XSw4ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgVmlzaXRvciA9IHJlcXVpcmUoXCIuL3Zpc2l0b3JcIik7XG5cbnZhciBKb2luU2VsZWN0b3JWaXNpdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb250ZXh0cyA9IFtbXV07XG4gICAgdGhpcy5fdmlzaXRvciA9IG5ldyBWaXNpdG9yKHRoaXMpO1xufTtcblxuSm9pblNlbGVjdG9yVmlzaXRvci5wcm90b3R5cGUgPSB7XG4gICAgcnVuOiBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRvci52aXNpdChyb290KTtcbiAgICB9LFxuICAgIHZpc2l0UnVsZTogZnVuY3Rpb24gKHJ1bGVOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gZmFsc2U7XG4gICAgfSxcbiAgICB2aXNpdE1peGluRGVmaW5pdGlvbjogZnVuY3Rpb24gKG1peGluRGVmaW5pdGlvbk5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgdmlzaXRSdWxlc2V0OiBmdW5jdGlvbiAocnVsZXNldE5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dHNbdGhpcy5jb250ZXh0cy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhdGhzID0gW10sIHNlbGVjdG9ycztcblxuICAgICAgICB0aGlzLmNvbnRleHRzLnB1c2gocGF0aHMpO1xuXG4gICAgICAgIGlmICghIHJ1bGVzZXROb2RlLnJvb3QpIHtcbiAgICAgICAgICAgIHNlbGVjdG9ycyA9IHJ1bGVzZXROb2RlLnNlbGVjdG9ycztcbiAgICAgICAgICAgIGlmIChzZWxlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBzZWxlY3RvcnMuZmlsdGVyKGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiBzZWxlY3Rvci5nZXRJc091dHB1dCgpOyB9KTtcbiAgICAgICAgICAgICAgICBydWxlc2V0Tm9kZS5zZWxlY3RvcnMgPSBzZWxlY3RvcnMubGVuZ3RoID8gc2VsZWN0b3JzIDogKHNlbGVjdG9ycyA9IG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvcnMpIHsgcnVsZXNldE5vZGUuam9pblNlbGVjdG9ycyhwYXRocywgY29udGV4dCwgc2VsZWN0b3JzKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxlY3RvcnMpIHsgcnVsZXNldE5vZGUucnVsZXMgPSBudWxsOyB9XG4gICAgICAgICAgICBydWxlc2V0Tm9kZS5wYXRocyA9IHBhdGhzO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB2aXNpdFJ1bGVzZXRPdXQ6IGZ1bmN0aW9uIChydWxlc2V0Tm9kZSkge1xuICAgICAgICB0aGlzLmNvbnRleHRzLmxlbmd0aCA9IHRoaXMuY29udGV4dHMubGVuZ3RoIC0gMTtcbiAgICB9LFxuICAgIHZpc2l0TWVkaWE6IGZ1bmN0aW9uIChtZWRpYU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dHNbdGhpcy5jb250ZXh0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgbWVkaWFOb2RlLnJ1bGVzWzBdLnJvb3QgPSAoY29udGV4dC5sZW5ndGggPT09IDAgfHwgY29udGV4dFswXS5tdWx0aU1lZGlhKTtcbiAgICB9LFxuICAgIHZpc2l0RGlyZWN0aXZlOiBmdW5jdGlvbiAoZGlyZWN0aXZlTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0c1t0aGlzLmNvbnRleHRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZGlyZWN0aXZlTm9kZS5ydWxlcyAmJiBkaXJlY3RpdmVOb2RlLnJ1bGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGlyZWN0aXZlTm9kZS5ydWxlc1swXS5yb290ID0gKGRpcmVjdGl2ZU5vZGUuaXNSb290ZWQgfHwgY29udGV4dC5sZW5ndGggPT09IDAgfHwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpvaW5TZWxlY3RvclZpc2l0b3I7XG5cbn0se1wiLi92aXNpdG9yXCI6OTF9XSw4OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2V0VHJlZVZpc2liaWxpdHlWaXNpdG9yID0gZnVuY3Rpb24odmlzaWJsZSkge1xuICAgIHRoaXMudmlzaWJsZSA9IHZpc2libGU7XG59O1xuU2V0VHJlZVZpc2liaWxpdHlWaXNpdG9yLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbihyb290KSB7XG4gICAgdGhpcy52aXNpdChyb290KTtcbn07XG5TZXRUcmVlVmlzaWJpbGl0eVZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbihub2Rlcykge1xuICAgIGlmICghbm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cblxuICAgIHZhciBjbnQgPSBub2Rlcy5sZW5ndGgsIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNudDsgaSsrKSB7XG4gICAgICAgIHRoaXMudmlzaXQobm9kZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG59O1xuU2V0VHJlZVZpc2liaWxpdHlWaXNpdG9yLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGlmIChub2RlLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFycmF5KG5vZGUpO1xuICAgIH1cblxuICAgIGlmICghbm9kZS5ibG9ja3NWaXNpYmlsaXR5IHx8IG5vZGUuYmxvY2tzVmlzaWJpbGl0eSgpKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgIG5vZGUuZW5zdXJlVmlzaWJpbGl0eSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuZW5zdXJlSW52aXNpYmlsaXR5KCk7XG4gICAgfVxuXG4gICAgbm9kZS5hY2NlcHQodGhpcyk7XG4gICAgcmV0dXJuIG5vZGU7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBTZXRUcmVlVmlzaWJpbGl0eVZpc2l0b3I7XG59LHt9XSw5MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdHJlZSA9IHJlcXVpcmUoXCIuLi90cmVlXCIpLFxuICAgIFZpc2l0b3IgPSByZXF1aXJlKFwiLi92aXNpdG9yXCIpO1xuXG52YXIgQ1NTVmlzaXRvclV0aWxzID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHRoaXMuX3Zpc2l0b3IgPSBuZXcgVmlzaXRvcih0aGlzKTtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn07XG5cbkNTU1Zpc2l0b3JVdGlscy5wcm90b3R5cGUgPSB7XG4gICAgY29udGFpbnNTaWxlbnROb25CbG9ja2VkQ2hpbGQ6IGZ1bmN0aW9uKGJvZHlSdWxlcykge1xuICAgICAgICB2YXIgcnVsZTtcbiAgICAgICAgaWYgKGJvZHlSdWxlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBib2R5UnVsZXMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgIHJ1bGUgPSBib2R5UnVsZXNbcl07XG4gICAgICAgICAgICBpZiAocnVsZS5pc1NpbGVudCAmJiBydWxlLmlzU2lsZW50KHRoaXMuX2NvbnRleHQpICYmICFydWxlLmJsb2Nrc1Zpc2liaWxpdHkoKSkge1xuICAgICAgICAgICAgICAgIC8vdGhlIGRpcmVjdGl2ZSBjb250YWlucyBzb21ldGhpbmcgdGhhdCB3YXMgcmVmZXJlbmNlZCAobGlrZWx5IGJ5IGV4dGVuZClcbiAgICAgICAgICAgICAgICAvL3RoZXJlZm9yZSBpdCBuZWVkcyB0byBiZSBzaG93biBpbiBvdXRwdXQgdG9vXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBrZWVwT25seVZpc2libGVDaGlsZHM6IGZ1bmN0aW9uKG93bmVyKSB7XG4gICAgICAgIGlmIChvd25lciA9PSBudWxsIHx8IG93bmVyLnJ1bGVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgIH1cblxuICAgICAgICBvd25lci5ydWxlcyA9IG93bmVyLnJ1bGVzLmZpbHRlcihmdW5jdGlvbih0aGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGluZy5pc1Zpc2libGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgaXNFbXB0eTogZnVuY3Rpb24ob3duZXIpIHtcbiAgICAgICAgaWYgKG93bmVyID09IG51bGwgfHwgb3duZXIucnVsZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG93bmVyLnJ1bGVzLmxlbmd0aCA9PT0gMDtcbiAgICB9LFxuXG4gICAgaGFzVmlzaWJsZVNlbGVjdG9yOiBmdW5jdGlvbihydWxlc2V0Tm9kZSkge1xuICAgICAgICBpZiAocnVsZXNldE5vZGUgPT0gbnVsbCB8fCBydWxlc2V0Tm9kZS5wYXRocyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bGVzZXROb2RlLnBhdGhzLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIHJlc29sdmVWaXNpYmlsaXR5OiBmdW5jdGlvbiAobm9kZSwgb3JpZ2luYWxSdWxlcykge1xuICAgICAgICBpZiAoIW5vZGUuYmxvY2tzVmlzaWJpbGl0eSgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0VtcHR5KG5vZGUpICYmICF0aGlzLmNvbnRhaW5zU2lsZW50Tm9uQmxvY2tlZENoaWxkKG9yaWdpbmFsUnVsZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29tcGlsZWRSdWxlc0JvZHkgPSBub2RlLnJ1bGVzWzBdO1xuICAgICAgICB0aGlzLmtlZXBPbmx5VmlzaWJsZUNoaWxkcyhjb21waWxlZFJ1bGVzQm9keSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eShjb21waWxlZFJ1bGVzQm9keSkpIHtcbiAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLmVuc3VyZVZpc2liaWxpdHkoKTtcbiAgICAgICAgbm9kZS5yZW1vdmVWaXNpYmlsaXR5QmxvY2soKTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgaXNWaXNpYmxlUnVsZXNldDogZnVuY3Rpb24ocnVsZXNldE5vZGUpIHtcbiAgICAgICAgaWYgKHJ1bGVzZXROb2RlLmZpcnN0Um9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KHJ1bGVzZXROb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFydWxlc2V0Tm9kZS5yb290ICYmICF0aGlzLmhhc1Zpc2libGVTZWxlY3RvcihydWxlc2V0Tm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxufTtcblxudmFyIFRvQ1NTVmlzaXRvciA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB0aGlzLl92aXNpdG9yID0gbmV3IFZpc2l0b3IodGhpcyk7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy51dGlscyA9IG5ldyBDU1NWaXNpdG9yVXRpbHMoY29udGV4dCk7XG59O1xuXG5Ub0NTU1Zpc2l0b3IucHJvdG90eXBlID0ge1xuICAgIGlzUmVwbGFjaW5nOiB0cnVlLFxuICAgIHJ1bjogZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0b3IudmlzaXQocm9vdCk7XG4gICAgfSxcblxuICAgIHZpc2l0UnVsZTogZnVuY3Rpb24gKHJ1bGVOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgaWYgKHJ1bGVOb2RlLmJsb2Nrc1Zpc2liaWxpdHkoKSB8fCBydWxlTm9kZS52YXJpYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydWxlTm9kZTtcbiAgICB9LFxuXG4gICAgdmlzaXRNaXhpbkRlZmluaXRpb246IGZ1bmN0aW9uIChtaXhpbk5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICAvLyBtaXhpbiBkZWZpbml0aW9ucyBkbyBub3QgZ2V0IGV2YWwnZCAtIHRoaXMgbWVhbnMgdGhleSBrZWVwIHN0YXRlXG4gICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gY2xlYXIgdGhhdCBzdGF0ZSBoZXJlIHNvIGl0IGlzbid0IHVzZWQgaWYgdG9DU1MgaXMgY2FsbGVkIHR3aWNlXG4gICAgICAgIG1peGluTm9kZS5mcmFtZXMgPSBbXTtcbiAgICB9LFxuXG4gICAgdmlzaXRFeHRlbmQ6IGZ1bmN0aW9uIChleHRlbmROb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICB9LFxuXG4gICAgdmlzaXRDb21tZW50OiBmdW5jdGlvbiAoY29tbWVudE5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICBpZiAoY29tbWVudE5vZGUuYmxvY2tzVmlzaWJpbGl0eSgpIHx8IGNvbW1lbnROb2RlLmlzU2lsZW50KHRoaXMuX2NvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1lbnROb2RlO1xuICAgIH0sXG5cbiAgICB2aXNpdE1lZGlhOiBmdW5jdGlvbihtZWRpYU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2YXIgb3JpZ2luYWxSdWxlcyA9IG1lZGlhTm9kZS5ydWxlc1swXS5ydWxlcztcbiAgICAgICAgbWVkaWFOb2RlLmFjY2VwdCh0aGlzLl92aXNpdG9yKTtcbiAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXRpbHMucmVzb2x2ZVZpc2liaWxpdHkobWVkaWFOb2RlLCBvcmlnaW5hbFJ1bGVzKTtcbiAgICB9LFxuXG4gICAgdmlzaXRJbXBvcnQ6IGZ1bmN0aW9uIChpbXBvcnROb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgaWYgKGltcG9ydE5vZGUuYmxvY2tzVmlzaWJpbGl0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbXBvcnROb2RlO1xuICAgIH0sXG5cbiAgICB2aXNpdERpcmVjdGl2ZTogZnVuY3Rpb24oZGlyZWN0aXZlTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIGlmIChkaXJlY3RpdmVOb2RlLnJ1bGVzICYmIGRpcmVjdGl2ZU5vZGUucnVsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdERpcmVjdGl2ZVdpdGhCb2R5KGRpcmVjdGl2ZU5vZGUsIHZpc2l0QXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdERpcmVjdGl2ZVdpdGhvdXRCb2R5KGRpcmVjdGl2ZU5vZGUsIHZpc2l0QXJncyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmlzaXREaXJlY3RpdmVXaXRoQm9keTogZnVuY3Rpb24oZGlyZWN0aXZlTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIC8vaWYgdGhlcmUgaXMgb25seSBvbmUgbmVzdGVkIHJ1bGVzZXQgYW5kIHRoYXQgb25lIGhhcyBubyBwYXRoLCB0aGVuIGl0IGlzXG4gICAgICAgIC8vanVzdCBmYWtlIHJ1bGVzZXRcbiAgICAgICAgZnVuY3Rpb24gaGFzRmFrZVJ1bGVzZXQoZGlyZWN0aXZlTm9kZSkge1xuICAgICAgICAgICAgdmFyIGJvZHlSdWxlcyA9IGRpcmVjdGl2ZU5vZGUucnVsZXM7XG4gICAgICAgICAgICByZXR1cm4gYm9keVJ1bGVzLmxlbmd0aCA9PT0gMSAmJiAoIWJvZHlSdWxlc1swXS5wYXRocyB8fCBib2R5UnVsZXNbMF0ucGF0aHMubGVuZ3RoID09PSAwKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRCb2R5UnVsZXMoZGlyZWN0aXZlTm9kZSkge1xuICAgICAgICAgICAgdmFyIG5vZGVSdWxlcyA9IGRpcmVjdGl2ZU5vZGUucnVsZXM7XG4gICAgICAgICAgICBpZiAoaGFzRmFrZVJ1bGVzZXQoZGlyZWN0aXZlTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZVJ1bGVzWzBdLnJ1bGVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZVJ1bGVzO1xuICAgICAgICB9XG4gICAgICAgIC8vaXQgaXMgc3RpbGwgdHJ1ZSB0aGF0IGl0IGlzIG9ubHkgb25lIHJ1bGVzZXQgaW4gYXJyYXlcbiAgICAgICAgLy90aGlzIGlzIGxhc3Qgc3VjaCBtb21lbnRcbiAgICAgICAgLy9wcm9jZXNzIGNoaWxkc1xuICAgICAgICB2YXIgb3JpZ2luYWxSdWxlcyA9IGdldEJvZHlSdWxlcyhkaXJlY3RpdmVOb2RlKTtcbiAgICAgICAgZGlyZWN0aXZlTm9kZS5hY2NlcHQodGhpcy5fdmlzaXRvcik7XG4gICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghdGhpcy51dGlscy5pc0VtcHR5KGRpcmVjdGl2ZU5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXJnZVJ1bGVzKGRpcmVjdGl2ZU5vZGUucnVsZXNbMF0ucnVsZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXRpbHMucmVzb2x2ZVZpc2liaWxpdHkoZGlyZWN0aXZlTm9kZSwgb3JpZ2luYWxSdWxlcyk7XG4gICAgfSxcblxuICAgIHZpc2l0RGlyZWN0aXZlV2l0aG91dEJvZHk6IGZ1bmN0aW9uKGRpcmVjdGl2ZU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICBpZiAoZGlyZWN0aXZlTm9kZS5ibG9ja3NWaXNpYmlsaXR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXJlY3RpdmVOb2RlLm5hbWUgPT09IFwiQGNoYXJzZXRcIikge1xuICAgICAgICAgICAgLy8gT25seSBvdXRwdXQgdGhlIGRlYnVnIGluZm8gdG9nZXRoZXIgd2l0aCBzdWJzZXF1ZW50IEBjaGFyc2V0IGRlZmluaXRpb25zXG4gICAgICAgICAgICAvLyBhIGNvbW1lbnQgKG9yIEBtZWRpYSBzdGF0ZW1lbnQpIGJlZm9yZSB0aGUgYWN0dWFsIEBjaGFyc2V0IGRpcmVjdGl2ZSB3b3VsZFxuICAgICAgICAgICAgLy8gYmUgY29uc2lkZXJlZCBpbGxlZ2FsIGNzcyBhcyBpdCBoYXMgdG8gYmUgb24gdGhlIGZpcnN0IGxpbmVcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYXJzZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aXZlTm9kZS5kZWJ1Z0luZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSBuZXcgdHJlZS5Db21tZW50KFwiLyogXCIgKyBkaXJlY3RpdmVOb2RlLnRvQ1NTKHRoaXMuX2NvbnRleHQpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKSArIFwiICovXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50LmRlYnVnSW5mbyA9IGRpcmVjdGl2ZU5vZGUuZGVidWdJbmZvO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRvci52aXNpdChjb21tZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGFyc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXJlY3RpdmVOb2RlO1xuICAgIH0sXG5cbiAgICBjaGVja1ZhbGlkTm9kZXM6IGZ1bmN0aW9uKHJ1bGVzLCBpc1Jvb3QpIHtcbiAgICAgICAgaWYgKCFydWxlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJ1bGVOb2RlID0gcnVsZXNbaV07XG4gICAgICAgICAgICBpZiAoaXNSb290ICYmIHJ1bGVOb2RlIGluc3RhbmNlb2YgdHJlZS5SdWxlICYmICFydWxlTm9kZS52YXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IHsgbWVzc2FnZTogXCJQcm9wZXJ0aWVzIG11c3QgYmUgaW5zaWRlIHNlbGVjdG9yIGJsb2Nrcy4gVGhleSBjYW5ub3QgYmUgaW4gdGhlIHJvb3RcIixcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHJ1bGVOb2RlLmluZGV4LCBmaWxlbmFtZTogcnVsZU5vZGUuY3VycmVudEZpbGVJbmZvICYmIHJ1bGVOb2RlLmN1cnJlbnRGaWxlSW5mby5maWxlbmFtZX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVsZU5vZGUgaW5zdGFuY2VvZiB0cmVlLkNhbGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6IFwiRnVuY3Rpb24gJ1wiICsgcnVsZU5vZGUubmFtZSArIFwiJyBpcyB1bmRlZmluZWRcIixcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHJ1bGVOb2RlLmluZGV4LCBmaWxlbmFtZTogcnVsZU5vZGUuY3VycmVudEZpbGVJbmZvICYmIHJ1bGVOb2RlLmN1cnJlbnRGaWxlSW5mby5maWxlbmFtZX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVsZU5vZGUudHlwZSAmJiAhcnVsZU5vZGUuYWxsb3dSb290KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiBydWxlTm9kZS50eXBlICsgXCIgbm9kZSByZXR1cm5lZCBieSBhIGZ1bmN0aW9uIGlzIG5vdCB2YWxpZCBoZXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBydWxlTm9kZS5pbmRleCwgZmlsZW5hbWU6IHJ1bGVOb2RlLmN1cnJlbnRGaWxlSW5mbyAmJiBydWxlTm9kZS5jdXJyZW50RmlsZUluZm8uZmlsZW5hbWV9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZpc2l0UnVsZXNldDogZnVuY3Rpb24gKHJ1bGVzZXROb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgLy9hdCB0aGlzIHBvaW50IHJ1bGVzZXRzIGFyZSBuZXN0ZWQgaW50byBlYWNoIG90aGVyXG4gICAgICAgIHZhciBydWxlLCBydWxlc2V0cyA9IFtdO1xuXG4gICAgICAgIHRoaXMuY2hlY2tWYWxpZE5vZGVzKHJ1bGVzZXROb2RlLnJ1bGVzLCBydWxlc2V0Tm9kZS5maXJzdFJvb3QpO1xuXG4gICAgICAgIGlmICghIHJ1bGVzZXROb2RlLnJvb3QpIHtcbiAgICAgICAgICAgIC8vcmVtb3ZlIGludmlzaWJsZSBwYXRoc1xuICAgICAgICAgICAgdGhpcy5fY29tcGlsZVJ1bGVzZXRQYXRocyhydWxlc2V0Tm9kZSk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBydWxlc2V0cyBmcm9tIHRoaXMgcnVsZXNldCBib2R5IGFuZCBjb21waWxlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICAgICAgdmFyIG5vZGVSdWxlcyA9IHJ1bGVzZXROb2RlLnJ1bGVzLCBub2RlUnVsZUNudCA9IG5vZGVSdWxlcyA/IG5vZGVSdWxlcy5sZW5ndGggOiAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlUnVsZUNudDsgKSB7XG4gICAgICAgICAgICAgICAgcnVsZSA9IG5vZGVSdWxlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocnVsZSAmJiBydWxlLnJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZpc2l0IGJlY2F1c2Ugd2UgYXJlIG1vdmluZyB0aGVtIG91dCBmcm9tIGJlaW5nIGEgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNldHMucHVzaCh0aGlzLl92aXNpdG9yLnZpc2l0KHJ1bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVJ1bGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVJ1bGVDbnQtLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFjY2VwdCB0aGUgdmlzaXRvciB0byByZW1vdmUgcnVsZXMgYW5kIHJlZmFjdG9yIGl0c2VsZlxuICAgICAgICAgICAgLy8gdGhlbiB3ZSBjYW4gZGVjaWRlIG5vZ3cgd2hldGhlciB3ZSB3YW50IGl0IG9yIG5vdFxuICAgICAgICAgICAgLy8gY29tcGlsZSBib2R5XG4gICAgICAgICAgICBpZiAobm9kZVJ1bGVDbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcnVsZXNldE5vZGUuYWNjZXB0KHRoaXMuX3Zpc2l0b3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBydWxlc2V0Tm9kZS5ydWxlcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcblxuICAgICAgICB9IGVsc2UgeyAvL2lmICghIHJ1bGVzZXROb2RlLnJvb3QpIHtcbiAgICAgICAgICAgIHJ1bGVzZXROb2RlLmFjY2VwdCh0aGlzLl92aXNpdG9yKTtcbiAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJ1bGVzZXROb2RlLnJ1bGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXJnZVJ1bGVzKHJ1bGVzZXROb2RlLnJ1bGVzKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUR1cGxpY2F0ZVJ1bGVzKHJ1bGVzZXROb2RlLnJ1bGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbm93IGRlY2lkZSB3aGV0aGVyIHdlIGtlZXAgdGhlIHJ1bGVzZXRcbiAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNWaXNpYmxlUnVsZXNldChydWxlc2V0Tm9kZSkpIHtcbiAgICAgICAgICAgIHJ1bGVzZXROb2RlLmVuc3VyZVZpc2liaWxpdHkoKTtcbiAgICAgICAgICAgIHJ1bGVzZXRzLnNwbGljZSgwLCAwLCBydWxlc2V0Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocnVsZXNldHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVsZXNldHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bGVzZXRzO1xuICAgIH0sXG5cbiAgICBfY29tcGlsZVJ1bGVzZXRQYXRoczogZnVuY3Rpb24ocnVsZXNldE5vZGUpIHtcbiAgICAgICAgaWYgKHJ1bGVzZXROb2RlLnBhdGhzKSB7XG4gICAgICAgICAgICBydWxlc2V0Tm9kZS5wYXRocyA9IHJ1bGVzZXROb2RlLnBhdGhzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocFswXS5lbGVtZW50c1swXS5jb21iaW5hdG9yLnZhbHVlID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBbMF0uZWxlbWVudHNbMF0uY29tYmluYXRvciA9IG5ldyh0cmVlLkNvbWJpbmF0b3IpKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBbaV0uaXNWaXNpYmxlKCkgJiYgcFtpXS5nZXRJc091dHB1dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yZW1vdmVEdXBsaWNhdGVSdWxlczogZnVuY3Rpb24ocnVsZXMpIHtcbiAgICAgICAgaWYgKCFydWxlcykgeyByZXR1cm47IH1cblxuICAgICAgICAvLyByZW1vdmUgZHVwbGljYXRlc1xuICAgICAgICB2YXIgcnVsZUNhY2hlID0ge30sXG4gICAgICAgICAgICBydWxlTGlzdCwgcnVsZSwgaTtcblxuICAgICAgICBmb3IgKGkgPSBydWxlcy5sZW5ndGggLSAxOyBpID49IDAgOyBpLS0pIHtcbiAgICAgICAgICAgIHJ1bGUgPSBydWxlc1tpXTtcbiAgICAgICAgICAgIGlmIChydWxlIGluc3RhbmNlb2YgdHJlZS5SdWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFydWxlQ2FjaGVbcnVsZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBydWxlQ2FjaGVbcnVsZS5uYW1lXSA9IHJ1bGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUxpc3QgPSBydWxlQ2FjaGVbcnVsZS5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVMaXN0IGluc3RhbmNlb2YgdHJlZS5SdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlTGlzdCA9IHJ1bGVDYWNoZVtydWxlLm5hbWVdID0gW3J1bGVDYWNoZVtydWxlLm5hbWVdLnRvQ1NTKHRoaXMuX2NvbnRleHQpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZUNTUyA9IHJ1bGUudG9DU1ModGhpcy5fY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlTGlzdC5pbmRleE9mKHJ1bGVDU1MpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUxpc3QucHVzaChydWxlQ1NTKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfbWVyZ2VSdWxlczogZnVuY3Rpb24gKHJ1bGVzKSB7XG4gICAgICAgIGlmICghcnVsZXMpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgdmFyIGdyb3VwcyA9IHt9LFxuICAgICAgICAgICAgcGFydHMsXG4gICAgICAgICAgICBydWxlLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJ1bGUgPSBydWxlc1tpXTtcblxuICAgICAgICAgICAgaWYgKChydWxlIGluc3RhbmNlb2YgdHJlZS5SdWxlKSAmJiBydWxlLm1lcmdlKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gW3J1bGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5pbXBvcnRhbnQgPyBcIiFcIiA6IFwiXCJdLmpvaW4oXCIsXCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFncm91cHNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBncm91cHNba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldLnB1c2gocnVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3Qua2V5cyhncm91cHMpLm1hcChmdW5jdGlvbiAoaykge1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB0b0V4cHJlc3Npb24odmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5FeHByZXNzaW9uKSh2YWx1ZXMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwLnZhbHVlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gdG9WYWx1ZSh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLlZhbHVlKSh2YWx1ZXMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFydHMgPSBncm91cHNba107XG5cbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcnVsZSA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBzcGFjZWRHcm91cHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFNwYWNlZEdyb3VwID0gW107XG4gICAgICAgICAgICAgICAgcGFydHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLm1lcmdlID09PSBcIitcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RTcGFjZWRHcm91cC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2VkR3JvdXBzLnB1c2godG9FeHByZXNzaW9uKGxhc3RTcGFjZWRHcm91cCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFNwYWNlZEdyb3VwID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdFNwYWNlZEdyb3VwLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3BhY2VkR3JvdXBzLnB1c2godG9FeHByZXNzaW9uKGxhc3RTcGFjZWRHcm91cCkpO1xuICAgICAgICAgICAgICAgIHJ1bGUudmFsdWUgPSB0b1ZhbHVlKHNwYWNlZEdyb3Vwcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB2aXNpdEFub255bW91czogZnVuY3Rpb24oYW5vbnltb3VzTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIGlmIChhbm9ueW1vdXNOb2RlLmJsb2Nrc1Zpc2liaWxpdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgfVxuICAgICAgICBhbm9ueW1vdXNOb2RlLmFjY2VwdCh0aGlzLl92aXNpdG9yKTtcbiAgICAgICAgcmV0dXJuIGFub255bW91c05vZGU7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb0NTU1Zpc2l0b3I7XG5cbn0se1wiLi4vdHJlZVwiOjYyLFwiLi92aXNpdG9yXCI6OTF9XSw5MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdHJlZSA9IHJlcXVpcmUoXCIuLi90cmVlXCIpO1xuXG52YXIgX3Zpc2l0QXJncyA9IHsgdmlzaXREZWVwZXI6IHRydWUgfSxcbiAgICBfaGFzSW5kZXhlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBfbm9vcChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGluZGV4Tm9kZVR5cGVzKHBhcmVudCwgdGlja2VyKSB7XG4gICAgLy8gYWRkIC50eXBlSW5kZXggdG8gdHJlZSBub2RlIHR5cGVzIGZvciBsb29rdXAgdGFibGVcbiAgICB2YXIga2V5LCBjaGlsZDtcbiAgICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHBhcmVudFtrZXldO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGJvdW5kIGZ1bmN0aW9ucyBkaXJlY3RseSBvbiB0cmVlIHdoaWNoIGRvIG5vdCBoYXZlIGEgcHJvdG90eXBlXG4gICAgICAgICAgICAgICAgICAgIC8vIG9yIGFyZW4ndCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQucHJvdG90eXBlICYmIGNoaWxkLnByb3RvdHlwZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5wcm90b3R5cGUudHlwZUluZGV4ID0gdGlja2VyKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgICAgICB0aWNrZXIgPSBpbmRleE5vZGVUeXBlcyhjaGlsZCwgdGlja2VyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpY2tlcjtcbn1cblxudmFyIFZpc2l0b3IgPSBmdW5jdGlvbihpbXBsZW1lbnRhdGlvbikge1xuICAgIHRoaXMuX2ltcGxlbWVudGF0aW9uID0gaW1wbGVtZW50YXRpb247XG4gICAgdGhpcy5fdmlzaXRGbkNhY2hlID0gW107XG5cbiAgICBpZiAoIV9oYXNJbmRleGVkKSB7XG4gICAgICAgIGluZGV4Tm9kZVR5cGVzKHRyZWUsIDEpO1xuICAgICAgICBfaGFzSW5kZXhlZCA9IHRydWU7XG4gICAgfVxufTtcblxuVmlzaXRvci5wcm90b3R5cGUgPSB7XG4gICAgdmlzaXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlVHlwZUluZGV4ID0gbm9kZS50eXBlSW5kZXg7XG4gICAgICAgIGlmICghbm9kZVR5cGVJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmlzaXRGbkNhY2hlID0gdGhpcy5fdmlzaXRGbkNhY2hlLFxuICAgICAgICAgICAgaW1wbCA9IHRoaXMuX2ltcGxlbWVudGF0aW9uLFxuICAgICAgICAgICAgYXJ5SW5keCA9IG5vZGVUeXBlSW5kZXggPDwgMSxcbiAgICAgICAgICAgIG91dEFyeUluZGV4ID0gYXJ5SW5keCB8IDEsXG4gICAgICAgICAgICBmdW5jID0gdmlzaXRGbkNhY2hlW2FyeUluZHhdLFxuICAgICAgICAgICAgZnVuY091dCA9IHZpc2l0Rm5DYWNoZVtvdXRBcnlJbmRleF0sXG4gICAgICAgICAgICB2aXNpdEFyZ3MgPSBfdmlzaXRBcmdzLFxuICAgICAgICAgICAgZm5OYW1lO1xuXG4gICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFmdW5jKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSBcInZpc2l0XCIgKyBub2RlLnR5cGU7XG4gICAgICAgICAgICBmdW5jID0gaW1wbFtmbk5hbWVdIHx8IF9ub29wO1xuICAgICAgICAgICAgZnVuY091dCA9IGltcGxbZm5OYW1lICsgXCJPdXRcIl0gfHwgX25vb3A7XG4gICAgICAgICAgICB2aXNpdEZuQ2FjaGVbYXJ5SW5keF0gPSBmdW5jO1xuICAgICAgICAgICAgdmlzaXRGbkNhY2hlW291dEFyeUluZGV4XSA9IGZ1bmNPdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnVuYyAhPT0gX25vb3ApIHtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlID0gZnVuYy5jYWxsKGltcGwsIG5vZGUsIHZpc2l0QXJncyk7XG4gICAgICAgICAgICBpZiAoaW1wbC5pc1JlcGxhY2luZykge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXdOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZpc2l0QXJncy52aXNpdERlZXBlciAmJiBub2RlICYmIG5vZGUuYWNjZXB0KSB7XG4gICAgICAgICAgICBub2RlLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmdW5jT3V0ICE9IF9ub29wKSB7XG4gICAgICAgICAgICBmdW5jT3V0LmNhbGwoaW1wbCwgbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIHZpc2l0QXJyYXk6IGZ1bmN0aW9uKG5vZGVzLCBub25SZXBsYWNpbmcpIHtcbiAgICAgICAgaWYgKCFub2Rlcykge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNudCA9IG5vZGVzLmxlbmd0aCwgaTtcblxuICAgICAgICAvLyBOb24tcmVwbGFjaW5nXG4gICAgICAgIGlmIChub25SZXBsYWNpbmcgfHwgIXRoaXMuX2ltcGxlbWVudGF0aW9uLmlzUmVwbGFjaW5nKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY250OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlcGxhY2luZ1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGV2YWxkID0gdGhpcy52aXNpdChub2Rlc1tpXSk7XG4gICAgICAgICAgICBpZiAoZXZhbGQgPT09IHVuZGVmaW5lZCkgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgaWYgKCFldmFsZC5zcGxpY2UpIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChldmFsZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2YWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmxhdHRlbihldmFsZCwgb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0sXG4gICAgZmxhdHRlbjogZnVuY3Rpb24oYXJyLCBvdXQpIHtcbiAgICAgICAgaWYgKCFvdXQpIHtcbiAgICAgICAgICAgIG91dCA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNudCwgaSwgaXRlbSxcbiAgICAgICAgICAgIG5lc3RlZENudCwgaiwgbmVzdGVkSXRlbTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBjbnQgPSBhcnIubGVuZ3RoOyBpIDwgY250OyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBhcnJbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWl0ZW0uc3BsaWNlKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDAsIG5lc3RlZENudCA9IGl0ZW0ubGVuZ3RoOyBqIDwgbmVzdGVkQ250OyBqKyspIHtcbiAgICAgICAgICAgICAgICBuZXN0ZWRJdGVtID0gaXRlbVtqXTtcbiAgICAgICAgICAgICAgICBpZiAobmVzdGVkSXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5lc3RlZEl0ZW0uc3BsaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKG5lc3RlZEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmVzdGVkSXRlbS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGF0dGVuKG5lc3RlZEl0ZW0sIG91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBWaXNpdG9yO1xuXG59LHtcIi4uL3RyZWVcIjo2Mn1dLDkyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG4vLyByYXdBc2FwIHByb3ZpZGVzIGV2ZXJ5dGhpbmcgd2UgbmVlZCBleGNlcHQgZXhjZXB0aW9uIG1hbmFnZW1lbnQuXG52YXIgcmF3QXNhcCA9IHJlcXVpcmUoXCIuL3Jhd1wiKTtcbi8vIFJhd1Rhc2tzIGFyZSByZWN5Y2xlZCB0byByZWR1Y2UgR0MgY2h1cm4uXG52YXIgZnJlZVRhc2tzID0gW107XG4vLyBXZSBxdWV1ZSBlcnJvcnMgdG8gZW5zdXJlIHRoZXkgYXJlIHRocm93biBpbiByaWdodCBvcmRlciAoRklGTykuXG4vLyBBcnJheS1hcy1xdWV1ZSBpcyBnb29kIGVub3VnaCBoZXJlLCBzaW5jZSB3ZSBhcmUganVzdCBkZWFsaW5nIHdpdGggZXhjZXB0aW9ucy5cbnZhciBwZW5kaW5nRXJyb3JzID0gW107XG52YXIgcmVxdWVzdEVycm9yVGhyb3cgPSByYXdBc2FwLm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcih0aHJvd0ZpcnN0RXJyb3IpO1xuXG5mdW5jdGlvbiB0aHJvd0ZpcnN0RXJyb3IoKSB7XG4gICAgaWYgKHBlbmRpbmdFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IHBlbmRpbmdFcnJvcnMuc2hpZnQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2FsbHMgYSB0YXNrIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgcmV0dXJuaW5nLCBpbiBpdHMgb3duIGV2ZW50LCB3aXRoIHByaW9yaXR5XG4gKiBvdmVyIG90aGVyIGV2ZW50cyBsaWtlIGFuaW1hdGlvbiwgcmVmbG93LCBhbmQgcmVwYWludC4gQW4gZXJyb3IgdGhyb3duIGZyb20gYW5cbiAqIGV2ZW50IHdpbGwgbm90IGludGVycnVwdCwgbm9yIGV2ZW4gc3Vic3RhbnRpYWxseSBzbG93IGRvd24gdGhlIHByb2Nlc3Npbmcgb2ZcbiAqIG90aGVyIGV2ZW50cywgYnV0IHdpbGwgYmUgcmF0aGVyIHBvc3Rwb25lZCB0byBhIGxvd2VyIHByaW9yaXR5IGV2ZW50LlxuICogQHBhcmFtIHt7Y2FsbH19IHRhc2sgQSBjYWxsYWJsZSBvYmplY3QsIHR5cGljYWxseSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgbm9cbiAqIGFyZ3VtZW50cy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBhc2FwO1xuZnVuY3Rpb24gYXNhcCh0YXNrKSB7XG4gICAgdmFyIHJhd1Rhc2s7XG4gICAgaWYgKGZyZWVUYXNrcy5sZW5ndGgpIHtcbiAgICAgICAgcmF3VGFzayA9IGZyZWVUYXNrcy5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByYXdUYXNrID0gbmV3IFJhd1Rhc2soKTtcbiAgICB9XG4gICAgcmF3VGFzay50YXNrID0gdGFzaztcbiAgICByYXdBc2FwKHJhd1Rhc2spO1xufVxuXG4vLyBXZSB3cmFwIHRhc2tzIHdpdGggcmVjeWNsYWJsZSB0YXNrIG9iamVjdHMuICBBIHRhc2sgb2JqZWN0IGltcGxlbWVudHNcbi8vIGBjYWxsYCwganVzdCBsaWtlIGEgZnVuY3Rpb24uXG5mdW5jdGlvbiBSYXdUYXNrKCkge1xuICAgIHRoaXMudGFzayA9IG51bGw7XG59XG5cbi8vIFRoZSBzb2xlIHB1cnBvc2Ugb2Ygd3JhcHBpbmcgdGhlIHRhc2sgaXMgdG8gY2F0Y2ggdGhlIGV4Y2VwdGlvbiBhbmQgcmVjeWNsZVxuLy8gdGhlIHRhc2sgb2JqZWN0IGFmdGVyIGl0cyBzaW5nbGUgdXNlLlxuUmF3VGFzay5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICB0aGlzLnRhc2suY2FsbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChhc2FwLm9uZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaG9vayBleGlzdHMgcHVyZWx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICAgICAgICAgICAgLy8gSXRzIG5hbWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgcmFuZG9taXplZCB0byBicmVhayBhbnkgY29kZSB0aGF0XG4gICAgICAgICAgICAvLyBkZXBlbmRzIG9uIGl0cyBleGlzdGVuY2UuXG4gICAgICAgICAgICBhc2FwLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gYSB3ZWIgYnJvd3NlciwgZXhjZXB0aW9ucyBhcmUgbm90IGZhdGFsLiBIb3dldmVyLCB0byBhdm9pZFxuICAgICAgICAgICAgLy8gc2xvd2luZyBkb3duIHRoZSBxdWV1ZSBvZiBwZW5kaW5nIHRhc2tzLCB3ZSByZXRocm93IHRoZSBlcnJvciBpbiBhXG4gICAgICAgICAgICAvLyBsb3dlciBwcmlvcml0eSB0dXJuLlxuICAgICAgICAgICAgcGVuZGluZ0Vycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgIHJlcXVlc3RFcnJvclRocm93KCk7XG4gICAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICBmcmVlVGFza3NbZnJlZVRhc2tzLmxlbmd0aF0gPSB0aGlzO1xuICAgIH1cbn07XG5cbn0se1wiLi9yYXdcIjo5M31dLDkzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcblwidXNlIHN0cmljdFwiO1xuXG4vLyBVc2UgdGhlIGZhc3Rlc3QgbWVhbnMgcG9zc2libGUgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gaXRzIG93biB0dXJuLCB3aXRoXG4vLyBwcmlvcml0eSBvdmVyIG90aGVyIGV2ZW50cyBpbmNsdWRpbmcgSU8sIGFuaW1hdGlvbiwgcmVmbG93LCBhbmQgcmVkcmF3XG4vLyBldmVudHMgaW4gYnJvd3NlcnMuXG4vL1xuLy8gQW4gZXhjZXB0aW9uIHRocm93biBieSBhIHRhc2sgd2lsbCBwZXJtYW5lbnRseSBpbnRlcnJ1cHQgdGhlIHByb2Nlc3Npbmcgb2Zcbi8vIHN1YnNlcXVlbnQgdGFza3MuIFRoZSBoaWdoZXIgbGV2ZWwgYGFzYXBgIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCBpZiBhblxuLy8gZXhjZXB0aW9uIGlzIHRocm93biBieSBhIHRhc2ssIHRoYXQgdGhlIHRhc2sgcXVldWUgd2lsbCBjb250aW51ZSBmbHVzaGluZyBhc1xuLy8gc29vbiBhcyBwb3NzaWJsZSwgYnV0IGlmIHlvdSB1c2UgYHJhd0FzYXBgIGRpcmVjdGx5LCB5b3UgYXJlIHJlc3BvbnNpYmxlIHRvXG4vLyBlaXRoZXIgZW5zdXJlIHRoYXQgbm8gZXhjZXB0aW9ucyBhcmUgdGhyb3duIGZyb20geW91ciB0YXNrLCBvciB0byBtYW51YWxseVxuLy8gY2FsbCBgcmF3QXNhcC5yZXF1ZXN0Rmx1c2hgIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG5tb2R1bGUuZXhwb3J0cyA9IHJhd0FzYXA7XG5mdW5jdGlvbiByYXdBc2FwKHRhc2spIHtcbiAgICBpZiAoIXF1ZXVlLmxlbmd0aCkge1xuICAgICAgICByZXF1ZXN0Rmx1c2goKTtcbiAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBFcXVpdmFsZW50IHRvIHB1c2gsIGJ1dCBhdm9pZHMgYSBmdW5jdGlvbiBjYWxsLlxuICAgIHF1ZXVlW3F1ZXVlLmxlbmd0aF0gPSB0YXNrO1xufVxuXG52YXIgcXVldWUgPSBbXTtcbi8vIE9uY2UgYSBmbHVzaCBoYXMgYmVlbiByZXF1ZXN0ZWQsIG5vIGZ1cnRoZXIgY2FsbHMgdG8gYHJlcXVlc3RGbHVzaGAgYXJlXG4vLyBuZWNlc3NhcnkgdW50aWwgdGhlIG5leHQgYGZsdXNoYCBjb21wbGV0ZXMuXG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbi8vIGByZXF1ZXN0Rmx1c2hgIGlzIGFuIGltcGxlbWVudGF0aW9uLXNwZWNpZmljIG1ldGhvZCB0aGF0IGF0dGVtcHRzIHRvIGtpY2tcbi8vIG9mZiBhIGBmbHVzaGAgZXZlbnQgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS4gYGZsdXNoYCB3aWxsIGF0dGVtcHQgdG8gZXhoYXVzdFxuLy8gdGhlIGV2ZW50IHF1ZXVlIGJlZm9yZSB5aWVsZGluZyB0byB0aGUgYnJvd3NlcidzIG93biBldmVudCBsb29wLlxudmFyIHJlcXVlc3RGbHVzaDtcbi8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgbmV4dCB0YXNrIHRvIGV4ZWN1dGUgaW4gdGhlIHRhc2sgcXVldWUuIFRoaXMgaXNcbi8vIHByZXNlcnZlZCBiZXR3ZWVuIGNhbGxzIHRvIGBmbHVzaGAgc28gdGhhdCBpdCBjYW4gYmUgcmVzdW1lZCBpZlxuLy8gYSB0YXNrIHRocm93cyBhbiBleGNlcHRpb24uXG52YXIgaW5kZXggPSAwO1xuLy8gSWYgYSB0YXNrIHNjaGVkdWxlcyBhZGRpdGlvbmFsIHRhc2tzIHJlY3Vyc2l2ZWx5LCB0aGUgdGFzayBxdWV1ZSBjYW4gZ3Jvd1xuLy8gdW5ib3VuZGVkLiBUbyBwcmV2ZW50IG1lbW9yeSBleGhhdXN0aW9uLCB0aGUgdGFzayBxdWV1ZSB3aWxsIHBlcmlvZGljYWxseVxuLy8gdHJ1bmNhdGUgYWxyZWFkeS1jb21wbGV0ZWQgdGFza3MuXG52YXIgY2FwYWNpdHkgPSAxMDI0O1xuXG4vLyBUaGUgZmx1c2ggZnVuY3Rpb24gcHJvY2Vzc2VzIGFsbCB0YXNrcyB0aGF0IGhhdmUgYmVlbiBzY2hlZHVsZWQgd2l0aFxuLy8gYHJhd0FzYXBgIHVubGVzcyBhbmQgdW50aWwgb25lIG9mIHRob3NlIHRhc2tzIHRocm93cyBhbiBleGNlcHRpb24uXG4vLyBJZiBhIHRhc2sgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgYGZsdXNoYCBlbnN1cmVzIHRoYXQgaXRzIHN0YXRlIHdpbGwgcmVtYWluXG4vLyBjb25zaXN0ZW50IGFuZCB3aWxsIHJlc3VtZSB3aGVyZSBpdCBsZWZ0IG9mZiB3aGVuIGNhbGxlZCBhZ2Fpbi5cbi8vIEhvd2V2ZXIsIGBmbHVzaGAgZG9lcyBub3QgbWFrZSBhbnkgYXJyYW5nZW1lbnRzIHRvIGJlIGNhbGxlZCBhZ2FpbiBpZiBhblxuLy8gZXhjZXB0aW9uIGlzIHRocm93bi5cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHdoaWxlIChpbmRleCA8IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgIC8vIEFkdmFuY2UgdGhlIGluZGV4IGJlZm9yZSBjYWxsaW5nIHRoZSB0YXNrLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSB3aWxsXG4gICAgICAgIC8vIGJlZ2luIGZsdXNoaW5nIG9uIHRoZSBuZXh0IHRhc2sgdGhlIHRhc2sgdGhyb3dzIGFuIGVycm9yLlxuICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgcXVldWVbY3VycmVudEluZGV4XS5jYWxsKCk7XG4gICAgICAgIC8vIFByZXZlbnQgbGVha2luZyBtZW1vcnkgZm9yIGxvbmcgY2hhaW5zIG9mIHJlY3Vyc2l2ZSBjYWxscyB0byBgYXNhcGAuXG4gICAgICAgIC8vIElmIHdlIGNhbGwgYGFzYXBgIHdpdGhpbiB0YXNrcyBzY2hlZHVsZWQgYnkgYGFzYXBgLCB0aGUgcXVldWUgd2lsbFxuICAgICAgICAvLyBncm93LCBidXQgdG8gYXZvaWQgYW4gTyhuKSB3YWxrIGZvciBldmVyeSB0YXNrIHdlIGV4ZWN1dGUsIHdlIGRvbid0XG4gICAgICAgIC8vIHNoaWZ0IHRhc2tzIG9mZiB0aGUgcXVldWUgYWZ0ZXIgdGhleSBoYXZlIGJlZW4gZXhlY3V0ZWQuXG4gICAgICAgIC8vIEluc3RlYWQsIHdlIHBlcmlvZGljYWxseSBzaGlmdCAxMDI0IHRhc2tzIG9mZiB0aGUgcXVldWUuXG4gICAgICAgIGlmIChpbmRleCA+IGNhcGFjaXR5KSB7XG4gICAgICAgICAgICAvLyBNYW51YWxseSBzaGlmdCBhbGwgdmFsdWVzIHN0YXJ0aW5nIGF0IHRoZSBpbmRleCBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9mIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgIGZvciAodmFyIHNjYW4gPSAwLCBuZXdMZW5ndGggPSBxdWV1ZS5sZW5ndGggLSBpbmRleDsgc2NhbiA8IG5ld0xlbmd0aDsgc2NhbisrKSB7XG4gICAgICAgICAgICAgICAgcXVldWVbc2Nhbl0gPSBxdWV1ZVtzY2FuICsgaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUubGVuZ3RoIC09IGluZGV4O1xuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgaW5kZXggPSAwO1xuICAgIGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIGByZXF1ZXN0Rmx1c2hgIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgc3RyYXRlZ3kgYmFzZWQgb24gZGF0YSBjb2xsZWN0ZWQgZnJvbVxuLy8gZXZlcnkgYXZhaWxhYmxlIFNhdWNlTGFicyBTZWxlbml1bSB3ZWIgZHJpdmVyIHdvcmtlciBhdCB0aW1lIG9mIHdyaXRpbmcuXG4vLyBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9zcHJlYWRzaGVldHMvZC8xbUctNVVZR3VwNXF4R2RFTVdraFA2QldDejA1M05VYjJFMVFvVVRVMTZ1QS9lZGl0I2dpZD03ODM3MjQ1OTNcblxuLy8gU2FmYXJpIDYgYW5kIDYuMSBmb3IgZGVza3RvcCwgaVBhZCwgYW5kIGlQaG9uZSBhcmUgdGhlIG9ubHkgYnJvd3NlcnMgdGhhdFxuLy8gaGF2ZSBXZWJLaXRNdXRhdGlvbk9ic2VydmVyIGJ1dCBub3QgdW4tcHJlZml4ZWQgTXV0YXRpb25PYnNlcnZlci5cbi8vIE11c3QgdXNlIGBnbG9iYWxgIGluc3RlYWQgb2YgYHdpbmRvd2AgdG8gd29yayBpbiBib3RoIGZyYW1lcyBhbmQgd2ViXG4vLyB3b3JrZXJzLiBgZ2xvYmFsYCBpcyBhIHByb3Zpc2lvbiBvZiBCcm93c2VyaWZ5LCBNciwgTXJzLCBvciBNb3AuXG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblxuLy8gTXV0YXRpb25PYnNlcnZlcnMgYXJlIGRlc2lyYWJsZSBiZWNhdXNlIHRoZXkgaGF2ZSBoaWdoIHByaW9yaXR5IGFuZCB3b3JrXG4vLyByZWxpYWJseSBldmVyeXdoZXJlIHRoZXkgYXJlIGltcGxlbWVudGVkLlxuLy8gVGhleSBhcmUgaW1wbGVtZW50ZWQgaW4gYWxsIG1vZGVybiBicm93c2Vycy5cbi8vXG4vLyAtIEFuZHJvaWQgNC00LjNcbi8vIC0gQ2hyb21lIDI2LTM0XG4vLyAtIEZpcmVmb3ggMTQtMjlcbi8vIC0gSW50ZXJuZXQgRXhwbG9yZXIgMTFcbi8vIC0gaVBhZCBTYWZhcmkgNi03LjFcbi8vIC0gaVBob25lIFNhZmFyaSA3LTcuMVxuLy8gLSBTYWZhcmkgNi03XG5pZiAodHlwZW9mIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXF1ZXN0Rmx1c2ggPSBtYWtlUmVxdWVzdENhbGxGcm9tTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG5cbi8vIE1lc3NhZ2VDaGFubmVscyBhcmUgZGVzaXJhYmxlIGJlY2F1c2UgdGhleSBnaXZlIGRpcmVjdCBhY2Nlc3MgdG8gdGhlIEhUTUxcbi8vIHRhc2sgcXVldWUsIGFyZSBpbXBsZW1lbnRlZCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMCwgU2FmYXJpIDUuMC0xLCBhbmQgT3BlcmFcbi8vIDExLTEyLCBhbmQgaW4gd2ViIHdvcmtlcnMgaW4gbWFueSBlbmdpbmVzLlxuLy8gQWx0aG91Z2ggbWVzc2FnZSBjaGFubmVscyB5aWVsZCB0byBhbnkgcXVldWVkIHJlbmRlcmluZyBhbmQgSU8gdGFza3MsIHRoZXlcbi8vIHdvdWxkIGJlIGJldHRlciB0aGFuIGltcG9zaW5nIHRoZSA0bXMgZGVsYXkgb2YgdGltZXJzLlxuLy8gSG93ZXZlciwgdGhleSBkbyBub3Qgd29yayByZWxpYWJseSBpbiBJbnRlcm5ldCBFeHBsb3JlciBvciBTYWZhcmkuXG5cbi8vIEludGVybmV0IEV4cGxvcmVyIDEwIGlzIHRoZSBvbmx5IGJyb3dzZXIgdGhhdCBoYXMgc2V0SW1tZWRpYXRlIGJ1dCBkb2VzXG4vLyBub3QgaGF2ZSBNdXRhdGlvbk9ic2VydmVycy5cbi8vIEFsdGhvdWdoIHNldEltbWVkaWF0ZSB5aWVsZHMgdG8gdGhlIGJyb3dzZXIncyByZW5kZXJlciwgaXQgd291bGQgYmVcbi8vIHByZWZlcnJhYmxlIHRvIGZhbGxpbmcgYmFjayB0byBzZXRUaW1lb3V0IHNpbmNlIGl0IGRvZXMgbm90IGhhdmVcbi8vIHRoZSBtaW5pbXVtIDRtcyBwZW5hbHR5LlxuLy8gVW5mb3J0dW5hdGVseSB0aGVyZSBhcHBlYXJzIHRvIGJlIGEgYnVnIGluIEludGVybmV0IEV4cGxvcmVyIDEwIE1vYmlsZSAoYW5kXG4vLyBEZXNrdG9wIHRvIGEgbGVzc2VyIGV4dGVudCkgdGhhdCByZW5kZXJzIGJvdGggc2V0SW1tZWRpYXRlIGFuZFxuLy8gTWVzc2FnZUNoYW5uZWwgdXNlbGVzcyBmb3IgdGhlIHB1cnBvc2VzIG9mIEFTQVAuXG4vLyBodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3EvaXNzdWVzLzM5NlxuXG4vLyBUaW1lcnMgYXJlIGltcGxlbWVudGVkIHVuaXZlcnNhbGx5LlxuLy8gV2UgZmFsbCBiYWNrIHRvIHRpbWVycyBpbiB3b3JrZXJzIGluIG1vc3QgZW5naW5lcywgYW5kIGluIGZvcmVncm91bmRcbi8vIGNvbnRleHRzIGluIHRoZSBmb2xsb3dpbmcgYnJvd3NlcnMuXG4vLyBIb3dldmVyLCBub3RlIHRoYXQgZXZlbiB0aGlzIHNpbXBsZSBjYXNlIHJlcXVpcmVzIG51YW5jZXMgdG8gb3BlcmF0ZSBpbiBhXG4vLyBicm9hZCBzcGVjdHJ1bSBvZiBicm93c2Vycy5cbi8vXG4vLyAtIEZpcmVmb3ggMy0xM1xuLy8gLSBJbnRlcm5ldCBFeHBsb3JlciA2LTlcbi8vIC0gaVBhZCBTYWZhcmkgNC4zXG4vLyAtIEx5bnggMi44Ljdcbn0gZWxzZSB7XG4gICAgcmVxdWVzdEZsdXNoID0gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKGZsdXNoKTtcbn1cblxuLy8gYHJlcXVlc3RGbHVzaGAgcmVxdWVzdHMgdGhhdCB0aGUgaGlnaCBwcmlvcml0eSBldmVudCBxdWV1ZSBiZSBmbHVzaGVkIGFzXG4vLyBzb29uIGFzIHBvc3NpYmxlLlxuLy8gVGhpcyBpcyB1c2VmdWwgdG8gcHJldmVudCBhbiBlcnJvciB0aHJvd24gaW4gYSB0YXNrIGZyb20gc3RhbGxpbmcgdGhlIGV2ZW50XG4vLyBxdWV1ZSBpZiB0aGUgZXhjZXB0aW9uIGhhbmRsZWQgYnkgTm9kZS5qc+KAmXNcbi8vIGBwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIilgIG9yIGJ5IGEgZG9tYWluLlxucmF3QXNhcC5yZXF1ZXN0Rmx1c2ggPSByZXF1ZXN0Rmx1c2g7XG5cbi8vIFRvIHJlcXVlc3QgYSBoaWdoIHByaW9yaXR5IGV2ZW50LCB3ZSBpbmR1Y2UgYSBtdXRhdGlvbiBvYnNlcnZlciBieSB0b2dnbGluZ1xuLy8gdGhlIHRleHQgb2YgYSB0ZXh0IG5vZGUgYmV0d2VlbiBcIjFcIiBhbmQgXCItMVwiLlxuZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbU11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spIHtcbiAgICB2YXIgdG9nZ2xlID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbiAgICAgICAgdG9nZ2xlID0gLXRvZ2dsZTtcbiAgICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlO1xuICAgIH07XG59XG5cbi8vIFRoZSBtZXNzYWdlIGNoYW5uZWwgdGVjaG5pcXVlIHdhcyBkaXNjb3ZlcmVkIGJ5IE1hbHRlIFVibCBhbmQgd2FzIHRoZVxuLy8gb3JpZ2luYWwgZm91bmRhdGlvbiBmb3IgdGhpcyBsaWJyYXJ5LlxuLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcblxuLy8gU2FmYXJpIDYuMC41IChhdCBsZWFzdCkgaW50ZXJtaXR0ZW50bHkgZmFpbHMgdG8gY3JlYXRlIG1lc3NhZ2UgcG9ydHMgb24gYVxuLy8gcGFnZSdzIGZpcnN0IGxvYWQuIFRoYW5rZnVsbHksIHRoaXMgdmVyc2lvbiBvZiBTYWZhcmkgc3VwcG9ydHNcbi8vIE11dGF0aW9uT2JzZXJ2ZXJzLCBzbyB3ZSBkb24ndCBuZWVkIHRvIGZhbGwgYmFjayBpbiB0aGF0IGNhc2UuXG5cbi8vIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21NZXNzYWdlQ2hhbm5lbChjYWxsYmFjaykge1xuLy8gICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4vLyAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBjYWxsYmFjaztcbi8vICAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4vLyAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4vLyAgICAgfTtcbi8vIH1cblxuLy8gRm9yIHJlYXNvbnMgZXhwbGFpbmVkIGFib3ZlLCB3ZSBhcmUgYWxzbyB1bmFibGUgdG8gdXNlIGBzZXRJbW1lZGlhdGVgXG4vLyB1bmRlciBhbnkgY2lyY3Vtc3RhbmNlcy5cbi8vIEV2ZW4gaWYgd2Ugd2VyZSwgdGhlcmUgaXMgYW5vdGhlciBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAuXG4vLyBJdCBpcyBub3Qgc3VmZmljaWVudCB0byBhc3NpZ24gYHNldEltbWVkaWF0ZWAgdG8gYHJlcXVlc3RGbHVzaGAgYmVjYXVzZVxuLy8gYHNldEltbWVkaWF0ZWAgbXVzdCBiZSBjYWxsZWQgKmJ5IG5hbWUqIGFuZCB0aGVyZWZvcmUgbXVzdCBiZSB3cmFwcGVkIGluIGFcbi8vIGNsb3N1cmUuXG4vLyBOZXZlciBmb3JnZXQuXG5cbi8vIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21TZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbi8vICAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4vLyAgICAgICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4vLyAgICAgfTtcbi8vIH1cblxuLy8gU2FmYXJpIDYuMCBoYXMgYSBwcm9ibGVtIHdoZXJlIHRpbWVycyB3aWxsIGdldCBsb3N0IHdoaWxlIHRoZSB1c2VyIGlzXG4vLyBzY3JvbGxpbmcuIFRoaXMgcHJvYmxlbSBkb2VzIG5vdCBpbXBhY3QgQVNBUCBiZWNhdXNlIFNhZmFyaSA2LjAgc3VwcG9ydHNcbi8vIG11dGF0aW9uIG9ic2VydmVycywgc28gdGhhdCBpbXBsZW1lbnRhdGlvbiBpcyB1c2VkIGluc3RlYWQuXG4vLyBIb3dldmVyLCBpZiB3ZSBldmVyIGVsZWN0IHRvIHVzZSB0aW1lcnMgaW4gU2FmYXJpLCB0aGUgcHJldmFsZW50IHdvcmstYXJvdW5kXG4vLyBpcyB0byBhZGQgYSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIgdGhhdCBjYWxscyBmb3IgYSBmbHVzaC5cblxuLy8gYHNldFRpbWVvdXRgIGRvZXMgbm90IGNhbGwgdGhlIHBhc3NlZCBjYWxsYmFjayBpZiB0aGUgZGVsYXkgaXMgbGVzcyB0aGFuXG4vLyBhcHByb3hpbWF0ZWx5IDcgaW4gd2ViIHdvcmtlcnMgaW4gRmlyZWZveCA4IHRocm91Z2ggMTgsIGFuZCBzb21ldGltZXMgbm90XG4vLyBldmVuIHRoZW4uXG5cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcihjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbiAgICAgICAgLy8gV2UgZGlzcGF0Y2ggYSB0aW1lb3V0IHdpdGggYSBzcGVjaWZpZWQgZGVsYXkgb2YgMCBmb3IgZW5naW5lcyB0aGF0XG4gICAgICAgIC8vIGNhbiByZWxpYWJseSBhY2NvbW1vZGF0ZSB0aGF0IHJlcXVlc3QuIFRoaXMgd2lsbCB1c3VhbGx5IGJlIHNuYXBwZWRcbiAgICAgICAgLy8gdG8gYSA0IG1pbGlzZWNvbmQgZGVsYXksIGJ1dCBvbmNlIHdlJ3JlIGZsdXNoaW5nLCB0aGVyZSdzIG5vIGRlbGF5XG4gICAgICAgIC8vIGJldHdlZW4gZXZlbnRzLlxuICAgICAgICB2YXIgdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoaGFuZGxlVGltZXIsIDApO1xuICAgICAgICAvLyBIb3dldmVyLCBzaW5jZSB0aGlzIHRpbWVyIGdldHMgZnJlcXVlbnRseSBkcm9wcGVkIGluIEZpcmVmb3hcbiAgICAgICAgLy8gd29ya2Vycywgd2UgZW5saXN0IGFuIGludGVydmFsIGhhbmRsZSB0aGF0IHdpbGwgdHJ5IHRvIGZpcmVcbiAgICAgICAgLy8gYW4gZXZlbnQgMjAgdGltZXMgcGVyIHNlY29uZCB1bnRpbCBpdCBzdWNjZWVkcy5cbiAgICAgICAgdmFyIGludGVydmFsSGFuZGxlID0gc2V0SW50ZXJ2YWwoaGFuZGxlVGltZXIsIDUwKTtcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVUaW1lcigpIHtcbiAgICAgICAgICAgIC8vIFdoaWNoZXZlciB0aW1lciBzdWNjZWVkcyB3aWxsIGNhbmNlbCBib3RoIHRpbWVycyBhbmRcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgdGhlIGNhbGxiYWNrLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbEhhbmRsZSk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8gVGhpcyBpcyBmb3IgYGFzYXAuanNgIG9ubHkuXG4vLyBJdHMgbmFtZSB3aWxsIGJlIHBlcmlvZGljYWxseSByYW5kb21pemVkIHRvIGJyZWFrIGFueSBjb2RlIHRoYXQgZGVwZW5kcyBvblxuLy8gaXRzIGV4aXN0ZW5jZS5cbnJhd0FzYXAubWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyID0gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyO1xuXG4vLyBBU0FQIHdhcyBvcmlnaW5hbGx5IGEgbmV4dFRpY2sgc2hpbSBpbmNsdWRlZCBpbiBRLiBUaGlzIHdhcyBmYWN0b3JlZCBvdXRcbi8vIGludG8gdGhpcyBBU0FQIHBhY2thZ2UuIEl0IHdhcyBsYXRlciBhZGFwdGVkIHRvIFJTVlAgd2hpY2ggbWFkZSBmdXJ0aGVyXG4vLyBhbWVuZG1lbnRzLiBUaGVzZSBkZWNpc2lvbnMsIHBhcnRpY3VsYXJseSB0byBtYXJnaW5hbGl6ZSBNZXNzYWdlQ2hhbm5lbCBhbmRcbi8vIHRvIGNhcHR1cmUgdGhlIE11dGF0aW9uT2JzZXJ2ZXIgaW1wbGVtZW50YXRpb24gaW4gYSBjbG9zdXJlLCB3ZXJlIGludGVncmF0ZWRcbi8vIGJhY2sgaW50byBBU0FQIHByb3Blci5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aWxkZWlvL3JzdnAuanMvYmxvYi9jZGRmNzIzMjU0NmE5Y2Y4NTg1MjRiNzVjZGU2ZjllZGY3MjYyMGE3L2xpYi9yc3ZwL2FzYXAuanNcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSw5NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc2FwID0gcmVxdWlyZSgnYXNhcC9yYXcnKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8vIFN0YXRlczpcbi8vXG4vLyAwIC0gcGVuZGluZ1xuLy8gMSAtIGZ1bGZpbGxlZCB3aXRoIF92YWx1ZVxuLy8gMiAtIHJlamVjdGVkIHdpdGggX3ZhbHVlXG4vLyAzIC0gYWRvcHRlZCB0aGUgc3RhdGUgb2YgYW5vdGhlciBwcm9taXNlLCBfdmFsdWVcbi8vXG4vLyBvbmNlIHRoZSBzdGF0ZSBpcyBubyBsb25nZXIgcGVuZGluZyAoMCkgaXQgaXMgaW1tdXRhYmxlXG5cbi8vIEFsbCBgX2AgcHJlZml4ZWQgcHJvcGVydGllcyB3aWxsIGJlIHJlZHVjZWQgdG8gYF97cmFuZG9tIG51bWJlcn1gXG4vLyBhdCBidWlsZCB0aW1lIHRvIG9iZnVzY2F0ZSB0aGVtIGFuZCBkaXNjb3VyYWdlIHRoZWlyIHVzZS5cbi8vIFdlIGRvbid0IHVzZSBzeW1ib2xzIG9yIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0byBmdWxseSBoaWRlIHRoZW1cbi8vIGJlY2F1c2UgdGhlIHBlcmZvcm1hbmNlIGlzbid0IGdvb2QgZW5vdWdoLlxuXG5cbi8vIHRvIGF2b2lkIHVzaW5nIHRyeS9jYXRjaCBpbnNpZGUgY3JpdGljYWwgZnVuY3Rpb25zLCB3ZVxuLy8gZXh0cmFjdCB0aGVtIHRvIGhlcmUuXG52YXIgTEFTVF9FUlJPUiA9IG51bGw7XG52YXIgSVNfRVJST1IgPSB7fTtcbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG9iai50aGVuO1xuICB9IGNhdGNoIChleCkge1xuICAgIExBU1RfRVJST1IgPSBleDtcbiAgICByZXR1cm4gSVNfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5Q2FsbE9uZShmbiwgYSkge1xuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBMQVNUX0VSUk9SID0gZXg7XG4gICAgcmV0dXJuIElTX0VSUk9SO1xuICB9XG59XG5mdW5jdGlvbiB0cnlDYWxsVHdvKGZuLCBhLCBiKSB7XG4gIHRyeSB7XG4gICAgZm4oYSwgYik7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgTEFTVF9FUlJPUiA9IGV4O1xuICAgIHJldHVybiBJU19FUlJPUjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICB9XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpO1xuICB9XG4gIHRoaXMuXzQ1ID0gMDtcbiAgdGhpcy5fODEgPSAwO1xuICB0aGlzLl82NSA9IG51bGw7XG4gIHRoaXMuXzU0ID0gbnVsbDtcbiAgaWYgKGZuID09PSBub29wKSByZXR1cm47XG4gIGRvUmVzb2x2ZShmbiwgdGhpcyk7XG59XG5Qcm9taXNlLl8xMCA9IG51bGw7XG5Qcm9taXNlLl85NyA9IG51bGw7XG5Qcm9taXNlLl82MSA9IG5vb3A7XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gUHJvbWlzZSkge1xuICAgIHJldHVybiBzYWZlVGhlbih0aGlzLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gIH1cbiAgdmFyIHJlcyA9IG5ldyBQcm9taXNlKG5vb3ApO1xuICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlcykpO1xuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gc2FmZVRoZW4oc2VsZiwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIG5ldyBzZWxmLmNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVzID0gbmV3IFByb21pc2Uobm9vcCk7XG4gICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICBoYW5kbGUoc2VsZiwgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlcykpO1xuICB9KTtcbn07XG5mdW5jdGlvbiBoYW5kbGUoc2VsZiwgZGVmZXJyZWQpIHtcbiAgd2hpbGUgKHNlbGYuXzgxID09PSAzKSB7XG4gICAgc2VsZiA9IHNlbGYuXzY1O1xuICB9XG4gIGlmIChQcm9taXNlLl8xMCkge1xuICAgIFByb21pc2UuXzEwKHNlbGYpO1xuICB9XG4gIGlmIChzZWxmLl84MSA9PT0gMCkge1xuICAgIGlmIChzZWxmLl80NSA9PT0gMCkge1xuICAgICAgc2VsZi5fNDUgPSAxO1xuICAgICAgc2VsZi5fNTQgPSBkZWZlcnJlZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlbGYuXzQ1ID09PSAxKSB7XG4gICAgICBzZWxmLl80NSA9IDI7XG4gICAgICBzZWxmLl81NCA9IFtzZWxmLl81NCwgZGVmZXJyZWRdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLl81NC5wdXNoKGRlZmVycmVkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaGFuZGxlUmVzb2x2ZWQoc2VsZiwgZGVmZXJyZWQpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVSZXNvbHZlZChzZWxmLCBkZWZlcnJlZCkge1xuICBhc2FwKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYiA9IHNlbGYuXzgxID09PSAxID8gZGVmZXJyZWQub25GdWxmaWxsZWQgOiBkZWZlcnJlZC5vblJlamVjdGVkO1xuICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgaWYgKHNlbGYuXzgxID09PSAxKSB7XG4gICAgICAgIHJlc29sdmUoZGVmZXJyZWQucHJvbWlzZSwgc2VsZi5fNjUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIHNlbGYuXzY1KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJldCA9IHRyeUNhbGxPbmUoY2IsIHNlbGYuXzY1KTtcbiAgICBpZiAocmV0ID09PSBJU19FUlJPUikge1xuICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIExBU1RfRVJST1IpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKGRlZmVycmVkLnByb21pc2UsIHJldCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoc2VsZiwgbmV3VmFsdWUpIHtcbiAgLy8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcbiAgaWYgKG5ld1ZhbHVlID09PSBzZWxmKSB7XG4gICAgcmV0dXJuIHJlamVjdChcbiAgICAgIHNlbGYsXG4gICAgICBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpXG4gICAgKTtcbiAgfVxuICBpZiAoXG4gICAgbmV3VmFsdWUgJiZcbiAgICAodHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpXG4gICkge1xuICAgIHZhciB0aGVuID0gZ2V0VGhlbihuZXdWYWx1ZSk7XG4gICAgaWYgKHRoZW4gPT09IElTX0VSUk9SKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KHNlbGYsIExBU1RfRVJST1IpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICB0aGVuID09PSBzZWxmLnRoZW4gJiZcbiAgICAgIG5ld1ZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZVxuICAgICkge1xuICAgICAgc2VsZi5fODEgPSAzO1xuICAgICAgc2VsZi5fNjUgPSBuZXdWYWx1ZTtcbiAgICAgIGZpbmFsZShzZWxmKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkb1Jlc29sdmUodGhlbi5iaW5kKG5ld1ZhbHVlKSwgc2VsZik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHNlbGYuXzgxID0gMTtcbiAgc2VsZi5fNjUgPSBuZXdWYWx1ZTtcbiAgZmluYWxlKHNlbGYpO1xufVxuXG5mdW5jdGlvbiByZWplY3Qoc2VsZiwgbmV3VmFsdWUpIHtcbiAgc2VsZi5fODEgPSAyO1xuICBzZWxmLl82NSA9IG5ld1ZhbHVlO1xuICBpZiAoUHJvbWlzZS5fOTcpIHtcbiAgICBQcm9taXNlLl85NyhzZWxmLCBuZXdWYWx1ZSk7XG4gIH1cbiAgZmluYWxlKHNlbGYpO1xufVxuZnVuY3Rpb24gZmluYWxlKHNlbGYpIHtcbiAgaWYgKHNlbGYuXzQ1ID09PSAxKSB7XG4gICAgaGFuZGxlKHNlbGYsIHNlbGYuXzU0KTtcbiAgICBzZWxmLl81NCA9IG51bGw7XG4gIH1cbiAgaWYgKHNlbGYuXzQ1ID09PSAyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl81NC5sZW5ndGg7IGkrKykge1xuICAgICAgaGFuZGxlKHNlbGYsIHNlbGYuXzU0W2ldKTtcbiAgICB9XG4gICAgc2VsZi5fNTQgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb21pc2Upe1xuICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xufVxuXG4vKipcbiAqIFRha2UgYSBwb3RlbnRpYWxseSBtaXNiZWhhdmluZyByZXNvbHZlciBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlXG4gKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbiAqXG4gKiBNYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IGFzeW5jaHJvbnkuXG4gKi9cbmZ1bmN0aW9uIGRvUmVzb2x2ZShmbiwgcHJvbWlzZSkge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB2YXIgcmVzID0gdHJ5Q2FsbFR3byhmbiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgZG9uZSA9IHRydWU7XG4gICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIH0pXG4gIGlmICghZG9uZSAmJiByZXMgPT09IElTX0VSUk9SKSB7XG4gICAgZG9uZSA9IHRydWU7XG4gICAgcmVqZWN0KHByb21pc2UsIExBU1RfRVJST1IpO1xuICB9XG59XG5cbn0se1wiYXNhcC9yYXdcIjo5M31dLDk1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLy9UaGlzIGZpbGUgY29udGFpbnMgdGhlIEVTNiBleHRlbnNpb25zIHRvIHRoZSBjb3JlIFByb21pc2VzL0ErIEFQSVxuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbi8qIFN0YXRpYyBGdW5jdGlvbnMgKi9cblxudmFyIFRSVUUgPSB2YWx1ZVByb21pc2UodHJ1ZSk7XG52YXIgRkFMU0UgPSB2YWx1ZVByb21pc2UoZmFsc2UpO1xudmFyIE5VTEwgPSB2YWx1ZVByb21pc2UobnVsbCk7XG52YXIgVU5ERUZJTkVEID0gdmFsdWVQcm9taXNlKHVuZGVmaW5lZCk7XG52YXIgWkVSTyA9IHZhbHVlUHJvbWlzZSgwKTtcbnZhciBFTVBUWVNUUklORyA9IHZhbHVlUHJvbWlzZSgnJyk7XG5cbmZ1bmN0aW9uIHZhbHVlUHJvbWlzZSh2YWx1ZSkge1xuICB2YXIgcCA9IG5ldyBQcm9taXNlKFByb21pc2UuXzYxKTtcbiAgcC5fODEgPSAxO1xuICBwLl82NSA9IHZhbHVlO1xuICByZXR1cm4gcDtcbn1cblByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gdmFsdWU7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gTlVMTDtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBVTkRFRklORUQ7XG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSkgcmV0dXJuIFRSVUU7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHJldHVybiBGQUxTRTtcbiAgaWYgKHZhbHVlID09PSAwKSByZXR1cm4gWkVSTztcbiAgaWYgKHZhbHVlID09PSAnJykgcmV0dXJuIEVNUFRZU1RSSU5HO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgdGhlbiA9IHZhbHVlLnRoZW47XG4gICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHRoZW4uYmluZCh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZWplY3QoZXgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZVByb21pc2UodmFsdWUpO1xufTtcblxuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgIHZhciByZW1haW5pbmcgPSBhcmdzLmxlbmd0aDtcbiAgICBmdW5jdGlvbiByZXMoaSwgdmFsKSB7XG4gICAgICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgUHJvbWlzZSAmJiB2YWwudGhlbiA9PT0gUHJvbWlzZS5wcm90b3R5cGUudGhlbikge1xuICAgICAgICAgIHdoaWxlICh2YWwuXzgxID09PSAzKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwuXzY1O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsLl84MSA9PT0gMSkgcmV0dXJuIHJlcyhpLCB2YWwuXzY1KTtcbiAgICAgICAgICBpZiAodmFsLl84MSA9PT0gMikgcmVqZWN0KHZhbC5fNjUpO1xuICAgICAgICAgIHZhbC50aGVuKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0aGVuID0gdmFsLnRoZW47XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBQcm9taXNlKHRoZW4uYmluZCh2YWwpKTtcbiAgICAgICAgICAgIHAudGhlbihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFyZ3NbaV0gPSB2YWw7XG4gICAgICBpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXMoaSwgYXJnc1tpXSk7XG4gICAgfVxuICB9KTtcbn07XG5cblByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHZhbHVlKTtcbiAgfSk7XG59O1xuXG5Qcm9taXNlLnJhY2UgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpe1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyogUHJvdG90eXBlIE1ldGhvZHMgKi9cblxuUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xufTtcblxufSx7XCIuL2NvcmUuanNcIjo5NH1dLDk2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIHNob3VsZCB3b3JrIGluIGFueSBicm93c2VyIHdpdGhvdXQgYnJvd3NlcmlmeVxuXG5pZiAodHlwZW9mIFByb21pc2UucHJvdG90eXBlLmRvbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgUHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIHZhciBzZWxmID0gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudGhlbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdGhpc1xuICAgIHNlbGYudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9LCAwKVxuICAgIH0pXG4gIH1cbn1cbn0se31dLDk3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIG5vdCBcInVzZSBzdHJpY3RcIiBzbyB3ZSBjYW4gZGVjbGFyZSBnbG9iYWwgXCJQcm9taXNlXCJcblxudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwJyk7XG5cbmlmICh0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vbGliL2NvcmUuanMnKVxuICByZXF1aXJlKCcuL2xpYi9lczYtZXh0ZW5zaW9ucy5qcycpXG59XG5cbnJlcXVpcmUoJy4vcG9seWZpbGwtZG9uZS5qcycpO1xuXG59LHtcIi4vbGliL2NvcmUuanNcIjo5NCxcIi4vbGliL2VzNi1leHRlbnNpb25zLmpzXCI6OTUsXCIuL3BvbHlmaWxsLWRvbmUuanNcIjo5NixcImFzYXBcIjo5Mn1dfSx7fSxbMl0pKDIpXG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2xlc3NAMi43LjJAbGVzcy9kaXN0L2xlc3MuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(4);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(6)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../node_modules/._css-loader@0.23.1@css-loader/index.js!../../node_modules/._less-loader@4.0.5@less-loader/dist/cjs.js!./web.less\", function() {\n\t\t\tvar newContent = require(\"!!../../node_modules/._css-loader@0.23.1@css-loader/index.js!../../node_modules/._less-loader@4.0.5@less-loader/dist/cjs.js!./web.less\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3R5bGVzL3dlYi5sZXNzPzc0YWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzLy5fY3NzLWxvYWRlckAwLjIzLjFAY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvLl9sZXNzLWxvYWRlckA0LjAuNUBsZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3dlYi5sZXNzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvLl9zdHlsZS1sb2FkZXJAMC4xMy4yQHN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvLl9jc3MtbG9hZGVyQDAuMjMuMUBjc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy8uX2xlc3MtbG9hZGVyQDQuMC41QGxlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vd2ViLmxlc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy8uX2Nzcy1sb2FkZXJAMC4yMy4xQGNzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzLy5fbGVzcy1sb2FkZXJANC4wLjVAbGVzcy1sb2FkZXIvZGlzdC9janMuanMhLi93ZWIubGVzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvc3R5bGVzL3dlYi5sZXNzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(5)();\n// imports\n\n\n// module\nexports.push([module.i, \"body,\\ndiv,\\nul,\\nli,\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\ninput,\\nform,\\na,\\np {\\n  margin: 0;\\n  padding: 0;\\n}\\nhtml,\\nbody {\\n  margin: 0;\\n  padding: 0;\\n  font-size: 12px;\\n  font-family: \\\"Microsoft YaHei\\\", Arial, Helvetica, sans-serif;\\n  background: #fff;\\n  color: #222;\\n}\\nol,\\nul,\\nli,\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  list-style: none;\\n}\\na {\\n  color: #222;\\n  text-decoration: none;\\n  cursor: pointer;\\n  outline: 0;\\n}\\ni,\\nspan {\\n  font-style: normal;\\n  font-weight: normal;\\n}\\ninput,\\nbutton,\\nselect {\\n  font-family: \\\"Microsoft YaHei\\\", Arial, Helvetica, sans-serif;\\n  outline: 0;\\n}\\nli:after {\\n  clear: both;\\n}\\nul:after {\\n  clear: both;\\n}\\nimg {\\n  cursor: default;\\n}\\n.marle25 {\\n  margin-left: 0.33333333rem;\\n}\\n#container {\\n  overflow: hidden;\\n  /*相对定位*/\\n  position: relative;\\n  max-width: 750px;\\n  width: 10rem;\\n  margin: 0 auto;\\n}\\n.boss {\\n  /*绝对定位*/\\n  position: absolute;\\n  max-width: 750px;\\n  width: 10rem;\\n  height: 14.66666667rem;\\n  overflow: hidden;\\n  z-index: 99;\\n}\\n.boss .boss-left {\\n  display: block;\\n  /*相对定位*/\\n  position: relative;\\n  left: 0;\\n  width: 5rem;\\n  height: 14.66666667rem;\\n  float: left;\\n}\\n.boss .boss-right {\\n  display: block;\\n  /*相对定位*/\\n  position: relative;\\n  left: 0;\\n  width: 5rem;\\n  height: 14.66666667rem;\\n  float: right;\\n}\\n.boss-click {\\n  display: none;\\n}\\n.boss1 {\\n  animation: left-boss-go 1s linear;\\n}\\n.boss2 {\\n  animation: right-boss-go 1s linear;\\n}\\n@keyframes left-boss-go {\\n  0% {\\n    transform: translateX(0);\\n  }\\n  100% {\\n    transform: translateX(-5rem);\\n  }\\n}\\n@keyframes right-boss-go {\\n  0% {\\n    transform: translateX(0);\\n  }\\n  100% {\\n    transform: translateX(5rem);\\n  }\\n}\\n.banner {\\n  /*相对定位*/\\n  position: relative;\\n  height: 6rem;\\n  color: #fff;\\n  background: linear-gradient(to bottom, #b9deef, #89d7fb);\\n}\\n.banner .banner-top {\\n  z-index: 5;\\n  width: 10rem;\\n  height: 1rem;\\n}\\n#sliders {\\n  /*绝对定位*/\\n  position: absolute;\\n  top: 0;\\n  z-index: -1;\\n  width: 10rem;\\n  height: 6rem;\\n}\\n#sliders-wrapper {\\n  width: 60rem;\\n}\\n#sliders-wrapper .slider {\\n  float: left;\\n  width: 10rem;\\n  height: 6rem;\\n}\\n#sliders-wrapper .slider:last-child::after {\\n  clear: both;\\n}\\n#sliders-wrapper .slider img {\\n  width: 10rem;\\n  height: 6rem;\\n}\\n#real-banner {\\n  z-index: 5;\\n}\\n.chongqing-weather {\\n  display: inline-block;\\n  z-index: 5;\\n  margin-left: 0.33333333rem;\\n  line-height: 0.6rem;\\n  font-size: 0.64rem;\\n}\\n.xian {\\n  display: inline-block;\\n  /*相对定位*/\\n  position: relative;\\n  margin-left: 0.10666667rem;\\n  top: 0.06666667rem;\\n  height: 0.6rem;\\n  width: 0.08rem;\\n  background: #fff;\\n}\\n.switch {\\n  /*相对定位*/\\n  position: relative;\\n  z-index: 5;\\n  margin-left: 0.13333333rem;\\n  width: 0.4rem;\\n  height: 0.4rem;\\n  cursor: pointer;\\n}\\n.switch img {\\n  z-index: 5;\\n  width: 0.4rem;\\n  height: 0.4rem;\\n  cursor: pointer;\\n}\\n.comparison {\\n  display: block;\\n  /*相对定位*/\\n  position: relative;\\n  float: right;\\n  z-index: 5;\\n  top: 0.17333333rem;\\n  margin-right: 0.26666667rem;\\n  font-size: 0.32rem;\\n  cursor: pointer;\\n}\\n.comparison:after {\\n  clear: both;\\n}\\n.five-update {\\n  margin-left: 0.33333333rem;\\n  z-index: 5;\\n  margin-top: 0.06666667rem;\\n  font-size: 0.26666667rem;\\n}\\n.banner-main {\\n  z-index: 5;\\n  margin-top: 0.46666667rem;\\n  width: 10rem;\\n  height: 4.4rem;\\n}\\n.banner-main #tianqi {\\n  margin-left: 0.33333333rem;\\n  z-index: 5;\\n  font-size: 0.37333333rem;\\n}\\n.sun {\\n  display: block;\\n  /*绝对定位*/\\n  position: absolute;\\n  top: 0.93333333rem;\\n  left: 8.66666667rem;\\n  width: 0.8rem;\\n  height: 0.8rem;\\n}\\n.yun1 {\\n  display: block;\\n  /*绝对定位*/\\n  position: absolute;\\n  top: 1.33333333rem;\\n  left: 5.33333333rem;\\n  width: 0.73333333rem;\\n  height: 0.66666667rem;\\n  animation: piaoyun 4s linear infinite;\\n}\\n.yun2 {\\n  display: block;\\n  /*绝对定位*/\\n  position: absolute;\\n  top: 1.46666667rem;\\n  left: 3.86666667rem;\\n  width: 0.66666667rem;\\n  height: 0.66666667rem;\\n  animation: piaoyun 2.5s linear infinite;\\n}\\n.yun3 {\\n  display: block;\\n  /*绝对定位*/\\n  position: absolute;\\n  top: 2rem;\\n  left: 4.66666667rem;\\n  width: 0.66666667rem;\\n  height: 0.6rem;\\n  animation: piaoyun 3s linear infinite;\\n}\\n@keyframes piaoyun {\\n  0% {\\n    transform: translate(0, 0);\\n    opacity: 1;\\n  }\\n  50% {\\n    transform: translate(0.26666667rem, -0.4rem);\\n    opacity: 0.5;\\n  }\\n  100% {\\n    transform: translate(0, 0);\\n    opacity: 1;\\n  }\\n}\\n.condition2 {\\n  z-index: 5;\\n  width: 10rem;\\n  height: 2.26666667rem;\\n}\\n.condition2 #min-weather {\\n  display: block;\\n  float: left;\\n  margin-left: 0.33333333rem;\\n  z-index: 5;\\n  height: 2.26666667rem;\\n  width: 2.66666667rem;\\n  font-size: 1.6rem;\\n}\\n.condition2 .teperature {\\n  display: block;\\n  float: left;\\n  z-index: 5;\\n  top: 0.26666667rem;\\n  left: 0.13333333rem;\\n  width: 2.66666667rem;\\n  font-size: 0.37333333rem;\\n}\\n.condition2 .teperature:after {\\n  clear: both;\\n}\\n.condition2 .teperature #weather {\\n  display: block;\\n  /*相对定位*/\\n  position: relative;\\n  z-index: 5;\\n  top: 0.93333333rem;\\n  width: 1.06666667rem;\\n  height: 0.33333333rem;\\n  font-size: 0.37333333rem;\\n}\\n.condition2 .teperature .xiangxi {\\n  display: block;\\n  /*相对定位*/\\n  position: relative;\\n  z-index: 5;\\n  top: 0.93333333rem;\\n  width: 3.06666667rem;\\n  height: 0.53333333rem;\\n  font-size: 0.37333333rem;\\n}\\n.date-condition {\\n  margin-left: 0.33333333rem;\\n  z-index: 5;\\n  font-size: 0.34666667rem;\\n}\\n.date-condition .month-day {\\n  z-index: 5;\\n  margin-right: 0.26666667rem;\\n}\\n.twenty-four {\\n  float: left;\\n  margin-left: 0.33333333rem;\\n  z-index: 5;\\n  margin-top: 0.26666667rem;\\n  line-height: 0.6rem;\\n  width: 2rem;\\n  text-align: center;\\n  font-size: 0.32rem;\\n  background: #111;\\n  border-radius: 0.13333333rem;\\n  cursor: pointer;\\n}\\n.air {\\n  float: left;\\n  margin-left: 0.33333333rem;\\n  z-index: 5;\\n  margin-top: 0.26666667rem;\\n  line-height: 0.6rem;\\n  width: 2rem;\\n  color: #5ce14f;\\n  text-align: center;\\n  font-size: 0.32rem;\\n  background: #111;\\n  border-radius: 0.13333333rem;\\n  cursor: pointer;\\n}\\n.air .leaf {\\n  /*相对定位*/\\n  position: relative;\\n  z-index: 5;\\n  top: 0.04rem;\\n  left: -0.13333333rem;\\n  width: 0.33333333rem;\\n  height: 0.33333333rem;\\n  border-right: 1px solid #5ce14f;\\n}\\n.air:after {\\n  clear: both;\\n}\\n.main {\\n  /*相对定位*/\\n  position: relative;\\n  height: 8.53333333rem;\\n  background: linear-gradient(to bottom, #FCFAF2, #7DB9DE);\\n}\\n.main .day-condition1 {\\n  display: block;\\n  /*相对定位*/\\n  position: relative;\\n  width: 9.6rem;\\n  top: 0.26666667rem;\\n  margin: 0 auto;\\n}\\n.main .day-condition1 li {\\n  float: left;\\n  width: 1.06666667rem;\\n  height: 1.33333333rem;\\n  margin-right: 0.33333333rem;\\n  text-align: center;\\n  font-size: 0.34666667rem;\\n  color: #666;\\n}\\n.main .day-condition2 {\\n  display: block;\\n  /*相对定位*/\\n  position: relative;\\n  width: 9.6rem;\\n  top: 0.26666667rem;\\n  margin: 0 auto;\\n}\\n.main .day-condition2 li {\\n  float: left;\\n  width: 1.06666667rem;\\n  height: 1.33333333rem;\\n  margin-right: 0.33333333rem;\\n  text-align: center;\\n  font-size: 0.34666667rem;\\n  color: #666;\\n}\\n.main .day-condition3 {\\n  display: block;\\n  /*相对定位*/\\n  position: relative;\\n  width: 9.6rem;\\n  margin: 0 auto;\\n}\\n.main .day-condition3 li {\\n  float: left;\\n  width: 1.06666667rem;\\n  height: 1.33333333rem;\\n  margin-right: 0.33333333rem;\\n  text-align: center;\\n  font-size: 0.32rem;\\n  color: #666;\\n}\\n.day-condition1 li:last-child,\\n.day-condition2 li:last-child,\\n.day-condition3 li:last-child {\\n  margin-right: 0;\\n}\\n.day-condition1 li span {\\n  display: block;\\n  width: 1.06666667rem;\\n  height: 0.36rem;\\n}\\n.day-condition1 li img {\\n  display: block;\\n  width: 0.66666667rem;\\n  height: 0.66666667rem;\\n  margin: 0 auto;\\n  margin-top: 0.33333333rem;\\n}\\n#canvas {\\n  display: block;\\n  /*相对定位*/\\n  position: relative;\\n  top: -0.53333333rem;\\n  margin: 0 auto;\\n}\\n\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3R5bGVzL3dlYi5sZXNzP2QyZTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSxvR0FBcUcsY0FBYyxlQUFlLEdBQUcsZUFBZSxjQUFjLGVBQWUsb0JBQW9CLG1FQUFtRSxxQkFBcUIsZ0JBQWdCLEdBQUcsOENBQThDLHFCQUFxQixHQUFHLEtBQUssZ0JBQWdCLDBCQUEwQixvQkFBb0IsZUFBZSxHQUFHLFlBQVksdUJBQXVCLHdCQUF3QixHQUFHLDJCQUEyQixtRUFBbUUsZUFBZSxHQUFHLFlBQVksZ0JBQWdCLEdBQUcsWUFBWSxnQkFBZ0IsR0FBRyxPQUFPLG9CQUFvQixHQUFHLFlBQVksK0JBQStCLEdBQUcsY0FBYyxxQkFBcUIsbUNBQW1DLHFCQUFxQixpQkFBaUIsbUJBQW1CLEdBQUcsU0FBUyxtQ0FBbUMscUJBQXFCLGlCQUFpQiwyQkFBMkIscUJBQXFCLGdCQUFnQixHQUFHLG9CQUFvQixtQkFBbUIsbUNBQW1DLFlBQVksZ0JBQWdCLDJCQUEyQixnQkFBZ0IsR0FBRyxxQkFBcUIsbUJBQW1CLG1DQUFtQyxZQUFZLGdCQUFnQiwyQkFBMkIsaUJBQWlCLEdBQUcsZUFBZSxrQkFBa0IsR0FBRyxVQUFVLHNDQUFzQyxHQUFHLFVBQVUsdUNBQXVDLEdBQUcsMkJBQTJCLFFBQVEsK0JBQStCLEtBQUssVUFBVSxtQ0FBbUMsS0FBSyxHQUFHLDRCQUE0QixRQUFRLCtCQUErQixLQUFLLFVBQVUsa0NBQWtDLEtBQUssR0FBRyxXQUFXLG1DQUFtQyxpQkFBaUIsZ0JBQWdCLDZEQUE2RCxHQUFHLHVCQUF1QixlQUFlLGlCQUFpQixpQkFBaUIsR0FBRyxZQUFZLG1DQUFtQyxXQUFXLGdCQUFnQixpQkFBaUIsaUJBQWlCLEdBQUcsb0JBQW9CLGlCQUFpQixHQUFHLDRCQUE0QixnQkFBZ0IsaUJBQWlCLGlCQUFpQixHQUFHLDhDQUE4QyxnQkFBZ0IsR0FBRyxnQ0FBZ0MsaUJBQWlCLGlCQUFpQixH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aWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvLl9jc3MtbG9hZGVyQDAuMjMuMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiYm9keSxcXG5kaXYsXFxudWwsXFxubGksXFxuaDEsXFxuaDIsXFxuaDMsXFxuaDQsXFxuaDUsXFxuaDYsXFxuaW5wdXQsXFxuZm9ybSxcXG5hLFxcbnAge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuaHRtbCxcXG5ib2R5IHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBmb250LWZhbWlseTogXFxcIk1pY3Jvc29mdCBZYUhlaVxcXCIsIEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgY29sb3I6ICMyMjI7XFxufVxcbm9sLFxcbnVsLFxcbmxpLFxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0LFxcbmg1LFxcbmg2IHtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxufVxcbmEge1xcbiAgY29sb3I6ICMyMjI7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBvdXRsaW5lOiAwO1xcbn1cXG5pLFxcbnNwYW4ge1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG59XFxuaW5wdXQsXFxuYnV0dG9uLFxcbnNlbGVjdCB7XFxuICBmb250LWZhbWlseTogXFxcIk1pY3Jvc29mdCBZYUhlaVxcXCIsIEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XFxuICBvdXRsaW5lOiAwO1xcbn1cXG5saTphZnRlciB7XFxuICBjbGVhcjogYm90aDtcXG59XFxudWw6YWZ0ZXIge1xcbiAgY2xlYXI6IGJvdGg7XFxufVxcbmltZyB7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcbi5tYXJsZTI1IHtcXG4gIG1hcmdpbi1sZWZ0OiAwLjMzMzMzMzMzcmVtO1xcbn1cXG4jY29udGFpbmVyIHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICAvKuebuOWvueWumuS9jSovXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBtYXgtd2lkdGg6IDc1MHB4O1xcbiAgd2lkdGg6IDEwcmVtO1xcbiAgbWFyZ2luOiAwIGF1dG87XFxufVxcbi5ib3NzIHtcXG4gIC8q57ud5a+55a6a5L2NKi9cXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIG1heC13aWR0aDogNzUwcHg7XFxuICB3aWR0aDogMTByZW07XFxuICBoZWlnaHQ6IDE0LjY2NjY2NjY3cmVtO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHotaW5kZXg6IDk5O1xcbn1cXG4uYm9zcyAuYm9zcy1sZWZ0IHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgLyrnm7jlr7nlrprkvY0qL1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiA1cmVtO1xcbiAgaGVpZ2h0OiAxNC42NjY2NjY2N3JlbTtcXG4gIGZsb2F0OiBsZWZ0O1xcbn1cXG4uYm9zcyAuYm9zcy1yaWdodCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIC8q55u45a+55a6a5L2NKi9cXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogNXJlbTtcXG4gIGhlaWdodDogMTQuNjY2NjY2NjdyZW07XFxuICBmbG9hdDogcmlnaHQ7XFxufVxcbi5ib3NzLWNsaWNrIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5ib3NzMSB7XFxuICBhbmltYXRpb246IGxlZnQtYm9zcy1nbyAxcyBsaW5lYXI7XFxufVxcbi5ib3NzMiB7XFxuICBhbmltYXRpb246IHJpZ2h0LWJvc3MtZ28gMXMgbGluZWFyO1xcbn1cXG5Aa2V5ZnJhbWVzIGxlZnQtYm9zcy1nbyB7XFxuICAwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gIH1cXG4gIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTVyZW0pO1xcbiAgfVxcbn1cXG5Aa2V5ZnJhbWVzIHJpZ2h0LWJvc3MtZ28ge1xcbiAgMCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICB9XFxuICAxMDAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDVyZW0pO1xcbiAgfVxcbn1cXG4uYmFubmVyIHtcXG4gIC8q55u45a+55a6a5L2NKi9cXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGhlaWdodDogNnJlbTtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgI2I5ZGVlZiwgIzg5ZDdmYik7XFxufVxcbi5iYW5uZXIgLmJhbm5lci10b3Age1xcbiAgei1pbmRleDogNTtcXG4gIHdpZHRoOiAxMHJlbTtcXG4gIGhlaWdodDogMXJlbTtcXG59XFxuI3NsaWRlcnMge1xcbiAgLyrnu53lr7nlrprkvY0qL1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgei1pbmRleDogLTE7XFxuICB3aWR0aDogMTByZW07XFxuICBoZWlnaHQ6IDZyZW07XFxufVxcbiNzbGlkZXJzLXdyYXBwZXIge1xcbiAgd2lkdGg6IDYwcmVtO1xcbn1cXG4jc2xpZGVycy13cmFwcGVyIC5zbGlkZXIge1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICB3aWR0aDogMTByZW07XFxuICBoZWlnaHQ6IDZyZW07XFxufVxcbiNzbGlkZXJzLXdyYXBwZXIgLnNsaWRlcjpsYXN0LWNoaWxkOjphZnRlciB7XFxuICBjbGVhcjogYm90aDtcXG59XFxuI3NsaWRlcnMtd3JhcHBlciAuc2xpZGVyIGltZyB7XFxuICB3aWR0aDogMTByZW07XFxuICBoZWlnaHQ6IDZyZW07XFxufVxcbiNyZWFsLWJhbm5lciB7XFxuICB6LWluZGV4OiA1O1xcbn1cXG4uY2hvbmdxaW5nLXdlYXRoZXIge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgei1pbmRleDogNTtcXG4gIG1hcmdpbi1sZWZ0OiAwLjMzMzMzMzMzcmVtO1xcbiAgbGluZS1oZWlnaHQ6IDAuNnJlbTtcXG4gIGZvbnQtc2l6ZTogMC42NHJlbTtcXG59XFxuLnhpYW4ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgLyrnm7jlr7nlrprkvY0qL1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbWFyZ2luLWxlZnQ6IDAuMTA2NjY2NjdyZW07XFxuICB0b3A6IDAuMDY2NjY2NjdyZW07XFxuICBoZWlnaHQ6IDAuNnJlbTtcXG4gIHdpZHRoOiAwLjA4cmVtO1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG59XFxuLnN3aXRjaCB7XFxuICAvKuebuOWvueWumuS9jSovXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB6LWluZGV4OiA1O1xcbiAgbWFyZ2luLWxlZnQ6IDAuMTMzMzMzMzNyZW07XFxuICB3aWR0aDogMC40cmVtO1xcbiAgaGVpZ2h0OiAwLjRyZW07XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5zd2l0Y2ggaW1nIHtcXG4gIHotaW5kZXg6IDU7XFxuICB3aWR0aDogMC40cmVtO1xcbiAgaGVpZ2h0OiAwLjRyZW07XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5jb21wYXJpc29uIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgLyrnm7jlr7nlrprkvY0qL1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgei1pbmRleDogNTtcXG4gIHRvcDogMC4xNzMzMzMzM3JlbTtcXG4gIG1hcmdpbi1yaWdodDogMC4yNjY2NjY2N3JlbTtcXG4gIGZvbnQtc2l6ZTogMC4zMnJlbTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLmNvbXBhcmlzb246YWZ0ZXIge1xcbiAgY2xlYXI6IGJvdGg7XFxufVxcbi5maXZlLXVwZGF0ZSB7XFxuICBtYXJnaW4tbGVmdDogMC4zMzMzMzMzM3JlbTtcXG4gIHotaW5kZXg6IDU7XFxuICBtYXJnaW4tdG9wOiAwLjA2NjY2NjY3cmVtO1xcbiAgZm9udC1zaXplOiAwLjI2NjY2NjY3cmVtO1xcbn1cXG4uYmFubmVyLW1haW4ge1xcbiAgei1pbmRleDogNTtcXG4gIG1hcmdpbi10b3A6IDAuNDY2NjY2NjdyZW07XFxuICB3aWR0aDogMTByZW07XFxuICBoZWlnaHQ6IDQuNHJlbTtcXG59XFxuLmJhbm5lci1tYWluICN0aWFucWkge1xcbiAgbWFyZ2luLWxlZnQ6IDAuMzMzMzMzMzNyZW07XFxuICB6LWluZGV4OiA1O1xcbiAgZm9udC1zaXplOiAwLjM3MzMzMzMzcmVtO1xcbn1cXG4uc3VuIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgLyrnu53lr7nlrprkvY0qL1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwLjkzMzMzMzMzcmVtO1xcbiAgbGVmdDogOC42NjY2NjY2N3JlbTtcXG4gIHdpZHRoOiAwLjhyZW07XFxuICBoZWlnaHQ6IDAuOHJlbTtcXG59XFxuLnl1bjEge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICAvKue7neWvueWumuS9jSovXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDEuMzMzMzMzMzNyZW07XFxuICBsZWZ0OiA1LjMzMzMzMzMzcmVtO1xcbiAgd2lkdGg6IDAuNzMzMzMzMzNyZW07XFxuICBoZWlnaHQ6IDAuNjY2NjY2NjdyZW07XFxuICBhbmltYXRpb246IHBpYW95dW4gNHMgbGluZWFyIGluZmluaXRlO1xcbn1cXG4ueXVuMiB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIC8q57ud5a+55a6a5L2NKi9cXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMS40NjY2NjY2N3JlbTtcXG4gIGxlZnQ6IDMuODY2NjY2NjdyZW07XFxuICB3aWR0aDogMC42NjY2NjY2N3JlbTtcXG4gIGhlaWdodDogMC42NjY2NjY2N3JlbTtcXG4gIGFuaW1hdGlvbjogcGlhb3l1biAyLjVzIGxpbmVhciBpbmZpbml0ZTtcXG59XFxuLnl1bjMge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICAvKue7neWvueWumuS9jSovXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDJyZW07XFxuICBsZWZ0OiA0LjY2NjY2NjY3cmVtO1xcbiAgd2lkdGg6IDAuNjY2NjY2NjdyZW07XFxuICBoZWlnaHQ6IDAuNnJlbTtcXG4gIGFuaW1hdGlvbjogcGlhb3l1biAzcyBsaW5lYXIgaW5maW5pdGU7XFxufVxcbkBrZXlmcmFtZXMgcGlhb3l1biB7XFxuICAwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIDApO1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcbiAgNTAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMC4yNjY2NjY2N3JlbSwgLTAuNHJlbSk7XFxuICAgIG9wYWNpdHk6IDAuNTtcXG4gIH1cXG4gIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAwKTtcXG4gICAgb3BhY2l0eTogMTtcXG4gIH1cXG59XFxuLmNvbmRpdGlvbjIge1xcbiAgei1pbmRleDogNTtcXG4gIHdpZHRoOiAxMHJlbTtcXG4gIGhlaWdodDogMi4yNjY2NjY2N3JlbTtcXG59XFxuLmNvbmRpdGlvbjIgI21pbi13ZWF0aGVyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBtYXJnaW4tbGVmdDogMC4zMzMzMzMzM3JlbTtcXG4gIHotaW5kZXg6IDU7XFxuICBoZWlnaHQ6IDIuMjY2NjY2NjdyZW07XFxuICB3aWR0aDogMi42NjY2NjY2N3JlbTtcXG4gIGZvbnQtc2l6ZTogMS42cmVtO1xcbn1cXG4uY29uZGl0aW9uMiAudGVwZXJhdHVyZSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgei1pbmRleDogNTtcXG4gIHRvcDogMC4yNjY2NjY2N3JlbTtcXG4gIGxlZnQ6IDAuMTMzMzMzMzNyZW07XFxuICB3aWR0aDogMi42NjY2NjY2N3JlbTtcXG4gIGZvbnQtc2l6ZTogMC4zNzMzMzMzM3JlbTtcXG59XFxuLmNvbmRpdGlvbjIgLnRlcGVyYXR1cmU6YWZ0ZXIge1xcbiAgY2xlYXI6IGJvdGg7XFxufVxcbi5jb25kaXRpb24yIC50ZXBlcmF0dXJlICN3ZWF0aGVyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgLyrnm7jlr7nlrprkvY0qL1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogNTtcXG4gIHRvcDogMC45MzMzMzMzM3JlbTtcXG4gIHdpZHRoOiAxLjA2NjY2NjY3cmVtO1xcbiAgaGVpZ2h0OiAwLjMzMzMzMzMzcmVtO1xcbiAgZm9udC1zaXplOiAwLjM3MzMzMzMzcmVtO1xcbn1cXG4uY29uZGl0aW9uMiAudGVwZXJhdHVyZSAueGlhbmd4aSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIC8q55u45a+55a6a5L2NKi9cXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDU7XFxuICB0b3A6IDAuOTMzMzMzMzNyZW07XFxuICB3aWR0aDogMy4wNjY2NjY2N3JlbTtcXG4gIGhlaWdodDogMC41MzMzMzMzM3JlbTtcXG4gIGZvbnQtc2l6ZTogMC4zNzMzMzMzM3JlbTtcXG59XFxuLmRhdGUtY29uZGl0aW9uIHtcXG4gIG1hcmdpbi1sZWZ0OiAwLjMzMzMzMzMzcmVtO1xcbiAgei1pbmRleDogNTtcXG4gIGZvbnQtc2l6ZTogMC4zNDY2NjY2N3JlbTtcXG59XFxuLmRhdGUtY29uZGl0aW9uIC5tb250aC1kYXkge1xcbiAgei1pbmRleDogNTtcXG4gIG1hcmdpbi1yaWdodDogMC4yNjY2NjY2N3JlbTtcXG59XFxuLnR3ZW50eS1mb3VyIHtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbWFyZ2luLWxlZnQ6IDAuMzMzMzMzMzNyZW07XFxuICB6LWluZGV4OiA1O1xcbiAgbWFyZ2luLXRvcDogMC4yNjY2NjY2N3JlbTtcXG4gIGxpbmUtaGVpZ2h0OiAwLjZyZW07XFxuICB3aWR0aDogMnJlbTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGZvbnQtc2l6ZTogMC4zMnJlbTtcXG4gIGJhY2tncm91bmQ6ICMxMTE7XFxuICBib3JkZXItcmFkaXVzOiAwLjEzMzMzMzMzcmVtO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG4uYWlyIHtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbWFyZ2luLWxlZnQ6IDAuMzMzMzMzMzNyZW07XFxuICB6LWluZGV4OiA1O1xcbiAgbWFyZ2luLXRvcDogMC4yNjY2NjY2N3JlbTtcXG4gIGxpbmUtaGVpZ2h0OiAwLjZyZW07XFxuICB3aWR0aDogMnJlbTtcXG4gIGNvbG9yOiAjNWNlMTRmO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgZm9udC1zaXplOiAwLjMycmVtO1xcbiAgYmFja2dyb3VuZDogIzExMTtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMTMzMzMzMzNyZW07XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5haXIgLmxlYWYge1xcbiAgLyrnm7jlr7nlrprkvY0qL1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogNTtcXG4gIHRvcDogMC4wNHJlbTtcXG4gIGxlZnQ6IC0wLjEzMzMzMzMzcmVtO1xcbiAgd2lkdGg6IDAuMzMzMzMzMzNyZW07XFxuICBoZWlnaHQ6IDAuMzMzMzMzMzNyZW07XFxuICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjNWNlMTRmO1xcbn1cXG4uYWlyOmFmdGVyIHtcXG4gIGNsZWFyOiBib3RoO1xcbn1cXG4ubWFpbiB7XFxuICAvKuebuOWvueWumuS9jSovXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBoZWlnaHQ6IDguNTMzMzMzMzNyZW07XFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCAjRkNGQUYyLCAjN0RCOURFKTtcXG59XFxuLm1haW4gLmRheS1jb25kaXRpb24xIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgLyrnm7jlr7nlrprkvY0qL1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IDkuNnJlbTtcXG4gIHRvcDogMC4yNjY2NjY2N3JlbTtcXG4gIG1hcmdpbjogMCBhdXRvO1xcbn1cXG4ubWFpbiAuZGF5LWNvbmRpdGlvbjEgbGkge1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICB3aWR0aDogMS4wNjY2NjY2N3JlbTtcXG4gIGhlaWdodDogMS4zMzMzMzMzM3JlbTtcXG4gIG1hcmdpbi1yaWdodDogMC4zMzMzMzMzM3JlbTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGZvbnQtc2l6ZTogMC4zNDY2NjY2N3JlbTtcXG4gIGNvbG9yOiAjNjY2O1xcbn1cXG4ubWFpbiAuZGF5LWNvbmRpdGlvbjIge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICAvKuebuOWvueWumuS9jSovXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB3aWR0aDogOS42cmVtO1xcbiAgdG9wOiAwLjI2NjY2NjY3cmVtO1xcbiAgbWFyZ2luOiAwIGF1dG87XFxufVxcbi5tYWluIC5kYXktY29uZGl0aW9uMiBsaSB7XFxuICBmbG9hdDogbGVmdDtcXG4gIHdpZHRoOiAxLjA2NjY2NjY3cmVtO1xcbiAgaGVpZ2h0OiAxLjMzMzMzMzMzcmVtO1xcbiAgbWFyZ2luLXJpZ2h0OiAwLjMzMzMzMzMzcmVtO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgZm9udC1zaXplOiAwLjM0NjY2NjY3cmVtO1xcbiAgY29sb3I6ICM2NjY7XFxufVxcbi5tYWluIC5kYXktY29uZGl0aW9uMyB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIC8q55u45a+55a6a5L2NKi9cXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHdpZHRoOiA5LjZyZW07XFxuICBtYXJnaW46IDAgYXV0bztcXG59XFxuLm1haW4gLmRheS1jb25kaXRpb24zIGxpIHtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgd2lkdGg6IDEuMDY2NjY2NjdyZW07XFxuICBoZWlnaHQ6IDEuMzMzMzMzMzNyZW07XFxuICBtYXJnaW4tcmlnaHQ6IDAuMzMzMzMzMzNyZW07XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBmb250LXNpemU6IDAuMzJyZW07XFxuICBjb2xvcjogIzY2NjtcXG59XFxuLmRheS1jb25kaXRpb24xIGxpOmxhc3QtY2hpbGQsXFxuLmRheS1jb25kaXRpb24yIGxpOmxhc3QtY2hpbGQsXFxuLmRheS1jb25kaXRpb24zIGxpOmxhc3QtY2hpbGQge1xcbiAgbWFyZ2luLXJpZ2h0OiAwO1xcbn1cXG4uZGF5LWNvbmRpdGlvbjEgbGkgc3BhbiB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiAxLjA2NjY2NjY3cmVtO1xcbiAgaGVpZ2h0OiAwLjM2cmVtO1xcbn1cXG4uZGF5LWNvbmRpdGlvbjEgbGkgaW1nIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDAuNjY2NjY2NjdyZW07XFxuICBoZWlnaHQ6IDAuNjY2NjY2NjdyZW07XFxuICBtYXJnaW46IDAgYXV0bztcXG4gIG1hcmdpbi10b3A6IDAuMzMzMzMzMzNyZW07XFxufVxcbiNjYW52YXMge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICAvKuebuOWvueWumuS9jSovXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB0b3A6IC0wLjUzMzMzMzMzcmVtO1xcbiAgbWFyZ2luOiAwIGF1dG87XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzLy5fY3NzLWxvYWRlckAwLjIzLjFAY3NzLWxvYWRlciEuL25vZGVfbW9kdWxlcy8uX2xlc3MtbG9hZGVyQDQuMC41QGxlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vYXBwL3N0eWxlcy93ZWIubGVzc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLl9jc3MtbG9hZGVyQDAuMjMuMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcz9mMWM5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX2Nzcy1sb2FkZXJAMC4yMy4xQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\tlinkElement.rel = \"stylesheet\";\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLl9zdHlsZS1sb2FkZXJAMC4xMy4yQHN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanM/ZTc5ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUEsNkJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xudmFyIHN0eWxlc0luRG9tID0ge30sXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xuXHRcdHZhciBtZW1vO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG1lbW87XG5cdFx0fTtcblx0fSxcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHNlbGYubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcblx0fSksXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuXHR9KSxcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIDxoZWFkPi5cblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cdGxpbmtFbGVtZW50LnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xuXHRyZXR1cm4gbGlua0VsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuXHRcdGlmKG5ld09iaikge1xuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHRpZihzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rRWxlbWVudC5ocmVmO1xuXG5cdGxpbmtFbGVtZW50LmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYylcblx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy8uX3N0eWxlLWxvYWRlckAwLjEzLjJAc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n");

/***/ })
/******/ ]);